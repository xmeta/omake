<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>



<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.08">
<LINK rel="stylesheet" type="text/css" href="omake-doc.css">
<TITLE>
Base library
</TITLE>
</HEAD>
<BODY >
<A HREF="omake-rules.html"><IMG SRC ="previous_motif.gif" ALT="Previous"></A>
<A HREF="omake-toc.html"><IMG SRC ="contents_motif.gif" ALT="Up"></A>
<A HREF="omake-system.html"><IMG SRC ="next_motif.gif" ALT="Next"></A>
<HR>
<A HREF="http://omake.metaprl.org/">OMake Home</A>
<A HREF="omake-toc.html">Table of contents</A>
<A HREF="omake.html">Guide</A>
<A HREF="omake-options.html">Options</A>
<A HREF="omake-all-index.html">Index</A>
<A HREF="omake-var-index.html">Variables</A>
<A HREF="omake-fun-index.html">Functions</A>
<A HREF="omake-obj-index.html">Objects</A>
<A HREF="omake-target-index.html">Targets</A>

<H1 CLASS="chapter"><A NAME="htoc80">Chapter&nbsp;7</A>&nbsp;&nbsp;Base library</H1>
<A NAME="chapter:base"></A>

<A NAME="toc58"></A>
<H2 CLASS="section"><A NAME="htoc81">7.1</A>&nbsp;&nbsp;Builtin variables</H2>
<A NAME="@default40"></A><A NAME="@var0"></A><A NAME="var:OSTYPE"></A>
<H4 CLASS="subsubsection">OSTYPE</H4>
 Set to the machine architecture <TT>omake</TT> is running on. Possible values are
 <CODE>Unix</CODE> (for all Unix versions, including Linux and Mac OS X), <CODE>Win32</CODE>
 (for MS-Windows, OMake compiled with MSVC++ or Mingw), and <CODE>Cygwin</CODE> (for
 MS-Windows, OMake compiled with Cygwin).
<A NAME="@default41"></A><A NAME="@var1"></A><A NAME="var:SYSNAME"></A>
<H4 CLASS="subsubsection">SYSNAME</H4>
 The name of the operating system for the current machine.
<A NAME="@default42"></A><A NAME="@var2"></A><A NAME="var:NODENAME"></A>
<H4 CLASS="subsubsection">NODENAME</H4>
 The hostname of the current machine.
<A NAME="@default43"></A><A NAME="@var3"></A><A NAME="var:OS_VERSION"></A>
<H4 CLASS="subsubsection">OS_VERSION</H4>
 The operating system release.
<A NAME="@default44"></A><A NAME="@var4"></A><A NAME="var:MACHINE"></A>
<H4 CLASS="subsubsection">MACHINE</H4>
 The machine architecture, e.g. <CODE>i386</CODE>, <CODE>sparc</CODE>, etc.
<A NAME="@default45"></A><A NAME="@var5"></A><A NAME="var:HOST"></A>
<H4 CLASS="subsubsection">HOST</H4>
 Same as <CODE>NODENAME</CODE>.
<A NAME="@default46"></A><A NAME="@var6"></A><A NAME="var:OMAKE_VERSION"></A>
<H4 CLASS="subsubsection">OMAKE_VERSION</H4>
 Version of OMake.
<A NAME="@default47"></A><A NAME="@var7"></A><A NAME="var:USER"></A>
<H4 CLASS="subsubsection">USER</H4>
 The login name of the user executing the process.
<A NAME="@default48"></A><A NAME="@var8"></A><A NAME="var:HOME"></A>
<H4 CLASS="subsubsection">HOME</H4>
 The home directory of the user executing the process.
<A NAME="@default49"></A><A NAME="@var9"></A><A NAME="var:PID"></A>
<H4 CLASS="subsubsection">PID</H4>
 The OMake process id.
<A NAME="toc59"></A>
<H2 CLASS="section"><A NAME="htoc82">7.2</A>&nbsp;&nbsp;Boolean functions and control flow</H2>
<A NAME="@default50"></A><A NAME="@fun5"></A><A NAME="fun:not"></A>
<H4 CLASS="subsubsection">not</H4>
<PRE CLASS="verbatim">
   $(not e) : String
      e : String
</PRE>
Boolean values in omake are represented by case-insensitive strings. The
<EM>false</EM> value can be represented by the strings <CODE>false</CODE>, <CODE>no</CODE>,
<CODE>nil</CODE>, <CODE>undefined</CODE> or <CODE>0</CODE>, and everything else is true. The
<CODE>not</CODE> function negates a Boolean value.<BR>
<BR>
For example, <CODE>$(not false)</CODE> expands to the string <CODE>true</CODE>, and <CODE>$(not hello world)</CODE> expands to <CODE>false</CODE>.
<A NAME="@default51"></A><A NAME="@fun6"></A><A NAME="fun:equal"></A>
<H4 CLASS="subsubsection">equal</H4>
<PRE CLASS="verbatim">
   $(equal e1, e2) : String
      e1 : String
      e2 : String
</PRE>
The <CODE>equal</CODE> function tests for equality of two values.<BR>
<BR>
For example <CODE>$(equal a, b)</CODE> expands to <CODE>false</CODE>, and <CODE>$(equal hello world, hello world)</CODE> expands to <CODE>true</CODE>.
<A NAME="@default52"></A><A NAME="@fun7"></A><A NAME="fun:and"></A>
<H4 CLASS="subsubsection">and</H4>
<PRE CLASS="verbatim">
    $(and e1, ..., en) : String
       e1, ..., en: Sequence
</PRE>
The <CODE>and</CODE> function evaluates to the conjunction of its arguments.<BR>
<BR>
For example, in the following code, <CODE>X</CODE> is true, and <CODE>Y</CODE> is false.
<PRE CLASS="verbatim">
    A = a
    B = b
    X = $(and $(equal $(A), a) true $(equal $(B), b))
    Y = $(and $(equal $(A), a) true $(equal $(A), $(B)))
</PRE><A NAME="@default53"></A><A NAME="@fun8"></A><A NAME="fun:or"></A>
<H4 CLASS="subsubsection">or</H4>
<PRE CLASS="verbatim">
   $(or e1, ..., en) : String
      e1, ..., en: String Sequence
</PRE>
The <CODE>or</CODE> function evaluates to the disjunction of its arguments.<BR>
<BR>
For example, in the following code, <CODE>X</CODE> is true, and <CODE>Y</CODE> is false.
<PRE CLASS="verbatim">
    A = a
    B = b
    X = $(or $(equal $(A), a) false $(equal $(A), $(B)))
    Y = $(or $(equal $(A), $(B)) $(equal $(A), b))
</PRE>
<A NAME="@default54"></A><A NAME="@fun9"></A><A NAME="fun:if"></A>
<H4 CLASS="subsubsection">if</H4>
<PRE CLASS="verbatim">
    $(if e1, e2[, e3]) : value
       e1 : String
       e2, e3 : value
</PRE>
The <CODE>if</CODE> function represents a conditional based on a Boolean value.
For example <CODE>$(if $(equal a, b), c, d)</CODE> evaluates to <CODE>d</CODE>.<BR>
<BR>
Conditionals may also be declared with an alternate syntax.
<PRE CLASS="verbatim">
   if e1
      body1
   elseif e2
      body2
   ...
   else
      bodyn
</PRE>
If the expression <CODE>e1</CODE> is not false, then the expressions in <CODE>body1</CODE>
are evaluated and the result is returned as the value of the conditional. Otherwise,
if <CODE>e1</CODE> evaluates to false, the evaluation continues with the <CODE>e2</CODE>
expression. If none of the conditional expressions is true, then the expressions
in <CODE>bodyn</CODE> are evaluated and the result is returned as the value
of the conditional.<BR>
<BR>
There can be any number of <CODE>elseif</CODE> clauses; the <CODE>else</CODE> clause is
optional.<BR>
<BR>
Note that each branch of the conditional defines its own scope, so variables
defined in the branches are normally not visible outside the conditional.
The <CODE>export</CODE> command may be used to export the variables defined in
a scope. For example, the following expression represents a common idiom
for defining the C compiler configuration.
<PRE CLASS="verbatim">
   if $(equal $(OSTYPE), Win32)
      CC = cl
      CFLAGS += /DWIN32
      export
   else
      CC = gcc
      CFLAGS += -g -O2
      export
</PRE><A NAME="@default55"></A><A NAME="@fun10"></A><A NAME="fun:switch"></A>
<H4 CLASS="subsubsection">switch</H4>
<A NAME="@default56"></A><A NAME="@fun11"></A><A NAME="fun:match"></A>
<H4 CLASS="subsubsection">match</H4>
The <CODE>switch</CODE> and <CODE>match</CODE> functions perform pattern matching.<BR>
<BR>
<CODE>$(switch &lt;arg&gt;, &lt;pattern_1&gt;, &lt;value_1&gt;, ..., &lt;pattern_n&gt;, &lt;value_n&gt;)</CODE>
<CODE>$(match &lt;arg&gt;, &lt;pattern_1&gt;, &lt;value_1&gt;, ..., &lt;pattern_n&gt;, &lt;value_n&gt;)</CODE><BR>
<BR>
The number of <CODE>&lt;pattern&gt;/&lt;value&gt;</CODE> pairs is arbitrary. They strictly
alternate; the total number of arguments to <CODE>&lt;match&gt;</CODE> must be odd.<BR>
<BR>
The <CODE>&lt;arg&gt;</CODE> is evaluated to a string, and compared with <CODE>&lt;pattern_1&gt;</CODE>.
If it matches, the result of the expression is <CODE>&lt;value_1&gt;</CODE>. Otherwise
evaluation continues with the remaining patterns until a match is found.
If no pattern matches, the value is the empty string.<BR>
<BR>
The <CODE>switch</CODE> function uses string comparison to compare
the argument with the patterns. For example, the following
expression defines the <CODE>FILE</CODE> variable to be either
<CODE>foo</CODE>, <CODE>bar</CODE>, or the empty string, depending
on the value of the <CODE>OSTYPE</CODE> variable.
<PRE CLASS="verbatim">
    FILE = $(switch $(OSTYPE), Win32, foo, Unix, bar)
</PRE>
The <CODE>match</CODE> function uses regular expression patterns (see the
<CODE>grep</CODE> function). If a match is found, the variables
<CODE>$1, $2, ...</CODE> are bound to the substrings matched between
<CODE>\(</CODE> and <CODE>\)</CODE> delimiters.
The <CODE>$0</CODE> variable contains the entire match, and <CODE>$*</CODE>
is an array of the matched substrings.
to the matched substrings.
<PRE CLASS="verbatim">
    FILE = $(match foo_xyz/bar.a, foo_\\\(.*\\\)/\\\(.*\\\)\.a, foo_$2/$1.o)
</PRE>
The <CODE>switch</CODE> and <CODE>match</CODE> functions also have an alternate (more usable)
form.
<PRE CLASS="verbatim">
   match e
   case pattern1
      body1
   case pattern2
      body2
   ...
   default
      bodyd
</PRE>
If the value of expression <CODE>e</CODE> matches <CODE>pattern_i</CODE> and no previous pattern,
then <CODE>body_i</CODE> is evaluated and returned as the result of the <CODE>match</CODE>.
The <CODE>switch</CODE> function uses string comparison; the <CODE>match</CODE> function
uses regular expression matching.
<PRE CLASS="verbatim">
   match $(FILE)
   case $".*\(\.[^\/.]*\)"
      println(The string $(FILE) has suffix $1)
   default
      println(The string $(FILE) has no suffix)
</PRE>
<A NAME="@default57"></A><A NAME="@fun12"></A><A NAME="fun:try"></A>
<H4 CLASS="subsubsection">try</H4>
<PRE CLASS="verbatim">
   try
      try-body
   catch class1(v1)
      catch-body
   when expr
      when-body
   ...
   finally
      finally-body
</PRE>
The <CODE>try</CODE> form is used for exception handling.
First, the expressions in the <CODE>try-body</CODE> are evaluated.<BR>
<BR>
If evaluation results in a value <CODE>v</CODE> without raising an
exception, then the expressions in the <CODE>finally-body</CODE>
are evaluated and the value <CODE>v</CODE> is returned as the result.<BR>
<BR>
If evaluation of the <CODE>try-body</CODE> results in a exception object <CODE>obj</CODE>,
the <CODE>catch</CODE> clauses are examined in order. When examining <CODE>catch</CODE>
clause <CODE>catch class(v)</CODE>, if the exception object <CODE>obj</CODE>
is an instance of the class name <CODE>class</CODE>, the variable <CODE>v</CODE> is bound
to the exception object, and the expressions in the <CODE>catch-body</CODE>
are evaluated.<BR>
<BR>
If a <CODE>when</CODE> clause is encountered while a <CODE>catch</CODE> body is being evaluated,
the predicate <CODE>expr</CODE> is evaluated. If the result is true, evaluation continues
with the expressions in the <CODE>when-body</CODE>. Otherwise, the next <CODE>catch</CODE>
clause is considered for evaluation.<BR>
<BR>
If evaluation of a <CODE>catch-body</CODE> or <CODE>when-body</CODE> completes successfully,
returning a value <CODE>v</CODE>, without encountering another <CODE>when</CODE> clause,
then the expressions in the <CODE>finally-body</CODE>
are evaluated and the value <CODE>v</CODE> is returned as the result.<BR>
<BR>
There can be any number of <CODE>catch</CODE> clauses; the <CODE>finally</CODE> clause
is optional.
<BR>
<BR>
<A NAME="@default58"></A><A NAME="@fun13"></A><A NAME="fun:raise"></A>
<H4 CLASS="subsubsection">raise</H4>
<PRE CLASS="verbatim">
   raise exn
      exn : Exception
</PRE>
The <CODE>raise</CODE> function raises an exception.
The <CODE>exn</CODE> object can be any object. However,
the normal convention is to raise an <CODE>Exception</CODE>
object.
<A NAME="@default59"></A><A NAME="@fun14"></A><A NAME="fun:exit"></A>
<H4 CLASS="subsubsection">exit</H4>
<PRE CLASS="verbatim">
   exit(code)
      code : Int
</PRE>
The <CODE>exit</CODE> function terminates <TT>omake</TT> abnormally.<BR>
<BR>
<CODE>$(exit &lt;code&gt;)</CODE><BR>
<BR>
The <CODE>exit</CODE> function takes one integer argument, which is exit code.
Non-zero values indicate abnormal termination.
<A NAME="@default60"></A><A NAME="@fun15"></A><A NAME="fun:defined"></A>
<H4 CLASS="subsubsection">defined</H4>
<PRE CLASS="verbatim">
   $(defined sequence) : String
      sequence : Sequence
</PRE>
The <CODE>defined</CODE> function test whether all the variables in the sequence are
currently defined. For example, the following code defines the <CODE>X</CODE> variable
if it is not already defined.
<PRE CLASS="verbatim">
    if $(not $(defined X))
       X = a b c
       export
</PRE><A NAME="@default61"></A><A NAME="@fun16"></A><A NAME="fun:defined-env"></A>
<H4 CLASS="subsubsection">defined-env</H4>
<PRE CLASS="verbatim">
   $(defined-env sequence) : String
      sequence : String
</PRE>
The <CODE>defined-env</CODE> function tests whether a variable is defined
as part of the process environment.<BR>
<BR>
For example, the following code adds the <CODE>-g</CODE> compile
option if the environment variable <CODE>DEBUG</CODE> is defined.
<PRE CLASS="verbatim">
if $(defined-env DEBUG)
    CFLAGS += -g
    export
</PRE><A NAME="@default62"></A><A NAME="@fun17"></A><A NAME="fun:getenv"></A>
<H4 CLASS="subsubsection">getenv</H4>
<PRE CLASS="verbatim">
   $(getenv name) : String
   $(getenv name, default) : String
</PRE>
The <CODE>getenv</CODE> function gets the value of a variable from
the process environment. The function takes one or two arguments.<BR>
<BR>
In the single argument form, an exception is raised if the variable
variable is not defined in the environment. In the two-argument form,
the second argument is returned as the result if the value is not
defined.<BR>
<BR>
For example, the following code defines the variable <CODE>X</CODE>
to be a space-separated list of elements of the <CODE>PATH</CODE>
environment variable if it is defined, and to <CODE>/bin /usr/bin</CODE>
otherwise.
<PRE CLASS="verbatim">
    X = $(split $(PATHSEP), $(getenv PATH, /bin:/usr/bin))
</PRE>
You may also use the alternate form.
<PRE CLASS="verbatim">
     getenv(NAME)
         default
</PRE><A NAME="@default63"></A><A NAME="@fun18"></A><A NAME="fun:setenv"></A>
<H4 CLASS="subsubsection">setenv</H4>
<PRE CLASS="verbatim">
   setenv(name, value)
      name : String
      value : String
</PRE>
The <CODE>setenv</CODE> function sets the value of a variable in
the process environment. Environment variables are scoped
like normal variables.<BR>
<BR>
<A NAME="@default64"></A><A NAME="@fun19"></A><A NAME="fun:get-registry"></A>
<H4 CLASS="subsubsection">get-registry</H4>
<PRE CLASS="verbatim">
   get-registry(hkey, key, field) : String
   get-registry(hkey, key, field, default) : String
       hkey : String
       key : String
       field : String
</PRE>
The <CODE>get-registry</CODE> function retrieves a string value from the
system registry on Win32. On other architectures, there is no
registry.<BR>
<BR>
The <CODE>hive</CODE> (I think that is the right word), indicates which part
of the registry to use. It should be one of the following values.
<UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>HKEY_CLASSES_ROOT</CODE>
<LI CLASS="li-itemize"><CODE>HKEY_CURRENT_CONFIG</CODE>
<LI CLASS="li-itemize"><CODE>HKEY_CURRENT_USER</CODE>
<LI CLASS="li-itemize"><CODE>HKEY_LOCAL_MACHINE</CODE>
<LI CLASS="li-itemize"><CODE>HKEY_USERS</CODE>
</UL>
Refer to the Microsoft documentation if you want to know what these mean.<BR>
<BR>
The <CODE>key</CODE> is the field you want to get from the registry.
It should have a form like <CODE>A\B\C</CODE> (if you use forward slashes, they will
be converted to backslashes). The field is the sub-field of the key.<BR>
<BR>
In the 4-argument form, the <CODE>default</CODE> is returned on failure.
You may also use the alternate form.
<PRE CLASS="verbatim">
    get-registry(hkey, key, field)
       default
</PRE>
<A NAME="@default65"></A><A NAME="@fun20"></A><A NAME="fun:getvar"></A>
<H4 CLASS="subsubsection">getvar</H4>
<PRE CLASS="verbatim">
   $(getvar name) : String
</PRE>
The <CODE>getvar</CODE> function gets the value of a variable.<BR>
<BR>
An exception is raised if the variable
variable is not defined.<BR>
<BR>
For example, the following code defines X to be the string abc.
<PRE CLASS="verbatim">
    NAME = foo
    foo_1 = abc
    X = $(getvar $(NAME)_1)
</PRE><A NAME="@default66"></A><A NAME="@fun21"></A><A NAME="fun:setvar"></A>
<H4 CLASS="subsubsection">setvar</H4>
<PRE CLASS="verbatim">
   setvar(name, value)
      name : String
      value : String
</PRE>
The <CODE>setvar</CODE> function defines a new variable. For example, the
following code defines the variable <CODE>X</CODE> to be the string <CODE>abc</CODE>.
<PRE CLASS="verbatim">
   NAME = X
   setvar($(NAME), abc)
</PRE><A NAME="toc60"></A>
<H2 CLASS="section"><A NAME="htoc83">7.3</A>&nbsp;&nbsp;Arrays and sequences</H2>
<A NAME="@default67"></A><A NAME="@fun22"></A><A NAME="fun:array"></A>
<H4 CLASS="subsubsection">array</H4>
<PRE CLASS="verbatim">
    $(array elements) : Array
       elements : Sequence
</PRE>
The <CODE>array</CODE> function creates an array from a sequence.
If the <CODE>&lt;arg&gt;</CODE> is a string, the elements of the array
are the whitespace-separated elements of the string, respecting
quotes.<BR>
<BR>
In addition, array variables can be declared as follows.
<PRE CLASS="verbatim">
    A[] =
       &lt;val1&gt;
       ...
       &lt;valn&gt;
</PRE>
In this case, the elements of the array are exactly
<CODE>&lt;val1&gt;</CODE>, ..., <CODE>&lt;valn&gt;</CODE>, and whitespace is
preserved literally.
<A NAME="@default68"></A><A NAME="@fun23"></A><A NAME="fun:split"></A>
<H4 CLASS="subsubsection">split</H4>
<PRE CLASS="verbatim">
   $(split sep, elements) : Array
      sep : String
      elements : Sequence
</PRE>
The <CODE>split</CODE> function takes two arguments, a string of separators, and
a string argument. The result is an array of elements determined by
splitting the elements by all occurrence of the separator in the
<CODE>elements</CODE> sequence.<BR>
<BR>
For example, in the following code, the <CODE>X</CODE> variable is
defined to be the array <CODE>/bin /usr/bin /usr/local/bin</CODE>.
<PRE CLASS="verbatim">
    PATH = /bin:/usr/bin:/usr/local/bin
    X = $(split :, $(PATH))
</PRE>
The <CODE>sep</CODE> argument may be omitted. In this case <CODE>split</CODE> breaks its
arguments along the white space. Quotations are not split.
<A NAME="@default69"></A><A NAME="@fun24"></A><A NAME="fun:concat"></A>
<H4 CLASS="subsubsection">concat</H4>
<PRE CLASS="verbatim">
   $(concat sep, elements) : String
      sep : String
      elements : Sequence
</PRE>
The <CODE>concat</CODE> function takes two arguments, a separator string, and
a sequence of elements. The result is a string formed by concatenating
the elements, placing the separator between adjacent elements.<BR>
<BR>
For example, in the following code, the <CODE>X</CODE> variable is
defined to be the string <CODE>foo_x_bar_x_baz</CODE>.
<PRE CLASS="verbatim">
    X = foo  bar     baz
    Y = $(concat _x_, $(X))
</PRE><A NAME="@default70"></A><A NAME="@fun25"></A><A NAME="fun:length"></A>
<H4 CLASS="subsubsection">length</H4>
<PRE CLASS="verbatim">
   $(length sequence) : Int
      sequence : Sequence
</PRE>
The <CODE>length</CODE> function returns the number of elements in its argument.<BR>
<BR>
For example, the expression <CODE>$(length a  b "c d")</CODE> evaluates to 3.
<A NAME="@default71"></A><A NAME="@fun26"></A><A NAME="fun:nth"></A>
<H4 CLASS="subsubsection">nth</H4>
<PRE CLASS="verbatim">
   $(nth i, sequence) : value
      i : Int
      sequence : Sequence
   raises RuntimeException
</PRE>
The <CODE>nth</CODE> function returns the nth element of its argument, treated as
a list. Counting starts at 0. An exception is raised if the index is not in bounds.<BR>
<BR>
For example, the expression <CODE>$(nth 1, a "b c" d)</CODE> evaluates to <CODE>"b c"</CODE>.
<A NAME="@default72"></A><A NAME="@fun27"></A><A NAME="fun:nth-hd"></A>
<H4 CLASS="subsubsection">nth-hd</H4>
<PRE CLASS="verbatim">
   $(nth-hd i, sequence) : value
      i : Int
      sequence : Sequence
   raises RuntimeException
</PRE>
The <CODE>nth-hd</CODE> function returns the first <CODE>i</CODE> elements of
the sequence. An exception is raised if the sequence is not
at least <CODE>i</CODE> elements long.<BR>
<BR>
For example, the expression <CODE>$(nth-hd 2, a "b c" d)</CODE> evaluates to <CODE>a "b c"</CODE>.<BR>
<BR>
<A NAME="@default73"></A><A NAME="@fun28"></A><A NAME="fun:nth-tl"></A>
<H4 CLASS="subsubsection">nth-tl</H4>
<PRE CLASS="verbatim">
   $(nth-tl i, sequence) : value
      i : Int
      sequence : Sequence
   raises RuntimeException
</PRE>
The <CODE>nth-tl</CODE> function skips <CODE>i</CODE> elements of the sequence
and returns the rest. An exception is raised if the sequence is not
at least <CODE>i</CODE> elements long.<BR>
<BR>
For example, the expression <CODE>$(nth-tl 1, a "b c" d)</CODE> evaluates to <CODE>"b c" d</CODE>.<BR>
<BR>
<A NAME="@default74"></A><A NAME="@fun29"></A><A NAME="fun:subrange"></A>
<H4 CLASS="subsubsection">subrange</H4>
<PRE CLASS="verbatim">
   $(subrange off, len, sequent) : value
      off : Int
      len : Int
      sequence : Sequence
   raises RuntimeException
</PRE>
The <CODE>subrange</CODE> function returns a subrange of the sequence.
Counting starts at 0. An exception is raised if the specified
range is not in bounds.<BR>
<BR>
For example, the expression <CODE>$(subrange 1, 2, a "b c" d e)</CODE> evaluates to <CODE>"b c" d</CODE>.
<A NAME="@default75"></A><A NAME="@fun30"></A><A NAME="fun:rev"></A>
<H4 CLASS="subsubsection">rev</H4>
<PRE CLASS="verbatim">
    $(rev sequence) : Sequence
       sequence : Sequence
</PRE>
The <CODE>rev</CODE> function returns the elements of a sequence in reverse order.
For example, the expression <CODE>$(rev a "b c" d)</CODE> evaluates to <CODE>d "b c" a</CODE>.
<A NAME="@default76"></A><A NAME="@fun31"></A><A NAME="fun:string"></A>
<H4 CLASS="subsubsection">string</H4>
<PRE CLASS="verbatim">
   $(string sequence) : String
      sequence : Sequence
</PRE>
The <CODE>string</CODE> function flattens a sequence into a single string.
This is similar to the <CODE>concat</CODE> function, but the elements are
separated by whitespace. The result is treated as a unit; whitespace
is significant.
<A NAME="@default77"></A><A NAME="@fun32"></A><A NAME="fun:quote"></A>
<H4 CLASS="subsubsection">quote</H4>
<PRE CLASS="verbatim">
   $(quote sequence) : String
      sequence : Sequence
</PRE>
The <CODE>quote</CODE> function flattens a sequence into a single string
and adds quotes around the string. Inner quotation symbols are
escaped.<BR>
<BR>
For example, the expression <CODE>$(quote a "b c" d)</CODE> evaluates
to <CODE>"a \"b c\" d"</CODE>, and <CODE>$(quote abc)</CODE> evaluates to
<CODE>"abc"</CODE>.
<A NAME="@default78"></A><A NAME="@fun33"></A><A NAME="fun:quote-argv"></A>
<H4 CLASS="subsubsection">quote-argv</H4>
<PRE CLASS="verbatim">
   $(quote-argv sequence) : String
      sequence : Sequence
</PRE>
The <CODE>quote-argv</CODE> function flattens a sequence into a single string,
and adds quotes around the string. The quotation is formed so that
a command-line parse can separate the string back into its components.
<A NAME="@default79"></A><A NAME="@fun34"></A><A NAME="fun:html-string"></A>
<H4 CLASS="subsubsection">html-string</H4>
<PRE CLASS="verbatim">
   $(html-string sequence) : String
      sequence : Sequence
</PRE>
The <CODE>html-string</CODE> function flattens a sequence into a single string,
and escaped special HTML characters.
This is similar to the <CODE>concat</CODE> function, but the elements are
separated by whitespace. The result is treated as a unit; whitespace
is significant.
<A NAME="@default80"></A><A NAME="@fun35"></A><A NAME="fun:addsuffix"></A>
<H4 CLASS="subsubsection">addsuffix</H4>
<PRE CLASS="verbatim">
   $(addsuffix suffix, sequence) : Array
      suffix : String
      sequence : Sequence
</PRE>
The <CODE>addsuffix</CODE> function adds a suffix to each component of sequence.
The number of elements in the array is exactly the same as the number of
elements in the sequence.<BR>
<BR>
For example, <CODE>$(addsuffix .c, a b "c d")</CODE> evaluates to <CODE>a.c b.c "c d".c</CODE>.
<A NAME="@default81"></A><A NAME="@fun36"></A><A NAME="fun:mapsuffix"></A>
<H4 CLASS="subsubsection">mapsuffix</H4>
<PRE CLASS="verbatim">
   $(mapsuffix suffix, sequence) : Array
      suffix : value
      sequence : Sequence
</PRE>
The <CODE>mapsuffix</CODE> function adds a suffix to each component of sequence.
It is similar to <CODE>addsuffix</CODE>, but uses array concatenation instead
of string concatenation. The number of elements in the array is
twice the number of elements in the sequence.<BR>
<BR>
For example, <CODE>$(mapsuffix .c, a b "c d")</CODE> evaluates to <CODE>a .c b .c "c d" .c</CODE>.
<A NAME="@default82"></A><A NAME="@fun37"></A><A NAME="fun:addsuffixes"></A>
<H4 CLASS="subsubsection">addsuffixes</H4>
<PRE CLASS="verbatim">
   $(addsuffixes suffixes, sequence) : Array
      suffixes : Sequence
      sequence : Sequence
</PRE>
The <CODE>addsuffixes</CODE> function adds all suffixes in its first argument
to each component of a sequence. If <CODE>suffixes</CODE> has <CODE>n</CODE> elements,
and <CODE>sequence</CODE> has <CODE>m</CODE> elements, the the result has <CODE>n * m</CODE> elements.<BR>
<BR>
For example, the <CODE>$(addsuffixes .c .o, a b c)</CODE> expressions evaluates to
<CODE>a.c a.o b.c b.o c.o c.a</CODE>.
<A NAME="@default83"></A><A NAME="@fun38"></A><A NAME="fun:removeprefix"></A>
<H4 CLASS="subsubsection">removeprefix</H4>
<PRE CLASS="verbatim">
   $(removeprefix prefix, sequence) : Array
      prefix : String
      sequence : Array
</PRE>
The <CODE>removeprefix</CODE> function removes a prefix from each component
of a sequence.
<A NAME="@default84"></A><A NAME="@fun39"></A><A NAME="fun:removesuffix"></A>
<H4 CLASS="subsubsection">removesuffix</H4>
<PRE CLASS="verbatim">
   $(removesuffix sequence) : Array
      sequence : String
</PRE>
The <CODE>removesuffix</CODE> function removes the suffixes from each component
of a sequence.<BR>
<BR>
For example, <CODE>$(removesuffix a.c b.foo "c d")</CODE> expands to <CODE>a b "c d"</CODE>.
<A NAME="@default85"></A><A NAME="@fun40"></A><A NAME="fun:replacesuffixes"></A>
<H4 CLASS="subsubsection">replacesuffixes</H4>
<PRE CLASS="verbatim">
   $(replacesuffixes old-suffixes, new-suffixes, sequence) : Array
      old-suffixes : Sequence
      new-suffixes : Sequence
      sequence : Sequence
</PRE>
The <CODE>replacesuffixes</CODE> function modifies the suffix of each component
in sequence. The <CODE>old-suffixes</CODE> and <CODE>new-suffixes</CODE> sequences
should have the same length.<BR>
<BR>
For example, <CODE>$(replacesuffixes, .h .c, .o .o, a.c b.h c.z)</CODE> expands to <CODE>a.o b.o c.z</CODE>.
<A NAME="@default86"></A><A NAME="@fun41"></A><A NAME="fun:addprefix"></A>
<H4 CLASS="subsubsection">addprefix</H4>
<PRE CLASS="verbatim">
   $(addprefix prefix, sequence) : Array
      prefix : String
      sequence : Sequence
</PRE>
The <CODE>addprefix</CODE> function adds a prefix to each component of a sequence.
The number of element in the result array is exactly the same as the number
of elements in the argument sequence.<BR>
<BR>
For example, <CODE>$(addprefix foo/, a b "c d")</CODE> evaluates to <CODE>foo/a foo/b foo/"c d"</CODE>.
<A NAME="@default87"></A><A NAME="@fun42"></A><A NAME="fun:mapprefix"></A>
<H4 CLASS="subsubsection">mapprefix</H4>
<PRE CLASS="verbatim">
   $(mapprefix prefix, sequence) : Array
      prefix : String
      sequence : Sequence
</PRE>
The <CODE>mapprefix</CODE> function adds a prefix to each component of a sequence.
It is similar to <CODE>addprefix</CODE>, but array concatenation is used instead of
string concatenation. The result array contains twice as many elements
as the argument sequence.<BR>
<BR>
For example, <CODE>$(mapprefix foo, a b "c d")</CODE> expands to <CODE>foo a foo b foo "c d"</CODE>.
<A NAME="@default88"></A><A NAME="@fun43"></A><A NAME="fun:add-wrapper"></A>
<H4 CLASS="subsubsection">add-wrapper</H4>
<PRE CLASS="verbatim">
   $(add-wrapper prefix, suffix, sequence) : Array
      prefix : String
      suffix : String
      sequence : Sequence
</PRE>
The <CODE>add-wrapper</CODE> functions adds both a prefix and a suffix to each component of a sequence.
For example, the expression <CODE>$(add-wrapper dir/, .c, a b)</CODE> evaluates to
<CODE>dir/a.c dir/b.c</CODE>. String concatenation is used. The array result
has the same number of elements as the argument sequence.
<A NAME="@default89"></A><A NAME="@fun44"></A><A NAME="fun:set"></A>
<H4 CLASS="subsubsection">set</H4>
<PRE CLASS="verbatim">
   $(set sequence) : Array
      sequence : Sequence
</PRE>
The <CODE>set</CODE> function sorts a set of string components, eliminating duplicates.<BR>
<BR>
For example, <CODE>$(set z y z "m n" w a)</CODE> expands to <CODE>"m n" a w y z</CODE>.
<A NAME="@default90"></A><A NAME="@fun45"></A><A NAME="fun:mem"></A>
<H4 CLASS="subsubsection">mem</H4>
<PRE CLASS="verbatim">
   $(mem elem, sequence) : Boolean
      elem : String
      sequence : Sequence
</PRE>
The <CODE>mem</CODE> function tests for membership in a sequence.<BR>
<BR>
For example, <CODE>$(mem "m n", y z "m n" w a)</CODE> evaluates to <CODE>true</CODE>,
while <CODE>$(mem m n, y z "m n" w a)</CODE> evaluates to <CODE>false</CODE>.
<A NAME="@default91"></A><A NAME="@fun46"></A><A NAME="fun:intersection"></A>
<H4 CLASS="subsubsection">intersection</H4>
<PRE CLASS="verbatim">
   $(intersection sequence1, sequence2) : Array
      sequence1 : Sequence
      sequence2 : Sequence
</PRE>
The <CODE>intersection</CODE> function takes two arguments, treats them
as sets of strings, and computes their intersection. The order of the result
is undefined, and it may contain duplicates. Use the <CODE>set</CODE>
function to sort the result and eliminate duplicates in the result
if desired.<BR>
<BR>
For example, the expression <CODE>$(intersection c a b a, b a)</CODE> evaluates to
<CODE>a b a</CODE>.
<A NAME="@default92"></A><A NAME="@fun47"></A><A NAME="fun:intersects"></A>
<H4 CLASS="subsubsection">intersects</H4>
<PRE CLASS="verbatim">
   $(intersects sequence1, sequence2) : Boolean
      sequence1 : Sequence
      sequence2 : Sequence
</PRE>
The <CODE>intersects</CODE> function tests whether two sets have a non-empty intersection.
This is slightly more efficient than computing the intersection and testing whether
it is empty.<BR>
<BR>
For example, the expression <CODE>$(intersects a b c, d c e)</CODE> evaluates to <CODE>true</CODE>,
and <CODE>$(intersects a b c a, d e f)</CODE> evaluates to <CODE>false</CODE>.
<A NAME="@default93"></A><A NAME="@fun48"></A><A NAME="fun:set-diff"></A>
<H4 CLASS="subsubsection">set-diff</H4>
<PRE CLASS="verbatim">
   $(set-diff sequence1, sequence2) : Array
      sequence1 : Sequence
      sequence2 : Sequence
</PRE>
The <CODE>set-diff</CODE> function takes two arguments, treats them
as sets of strings, and computes their difference (all the elements of the
first set that are not present in the second one). The order of the result
is undefined and it may contain duplicates. Use the <CODE>set</CODE>
function to sort the result and eliminate duplicates in the result
if desired.<BR>
<BR>
For example, the expression <CODE>$(set-diff c a b a e, b a)</CODE> evaluates to
<CODE>c e</CODE>.
<A NAME="@default94"></A><A NAME="@fun49"></A><A NAME="fun:filter"></A>
<H4 CLASS="subsubsection">filter</H4>
<PRE CLASS="verbatim">
   $(filter patterns, sequence) : Array
      patterns : Sequence
      sequence : Sequence
</PRE>
The <CODE>filter</CODE> function picks elements from a sequence.
The patterns is a non-empty sequence of patterns, each may contain one occurrence of the wildcard
<CODE>%</CODE> character.<BR>
<BR>
For example <CODE>$(filter %.h %.o, a.c x.o b.h y.o "hello world".c)</CODE> evaluates to <CODE>x.o b.h y.o</CODE>.
<A NAME="@default95"></A><A NAME="@fun50"></A><A NAME="fun:filter-out"></A>
<H4 CLASS="subsubsection">filter-out</H4>
<PRE CLASS="verbatim">
   $(filter-out patterns, sequence) : Array
      patterns : Sequence
      sequence : Sequence
</PRE>
The <CODE>filter-out</CODE> function removes elements from a sequence.
The patterns is a non-empty sequence of patterns, each may contain one occurrence of the wildcard
<CODE>%</CODE> character.<BR>
<BR>
For example <CODE>$(filter-out %.c %.h, a.c x.o b.h y.o "hello world".c)</CODE> evaluates to <CODE>x.o y.o</CODE>.
<A NAME="@default96"></A><A NAME="@fun51"></A><A NAME="fun:capitalize"></A>
<H4 CLASS="subsubsection">capitalize</H4>
<PRE CLASS="verbatim">
   $(capitalize sequence) : Array
      sequence : Sequence
</PRE>
The <CODE>capitalize</CODE> function capitalizes each word in a sequence.
For example, <CODE>$(capitalize through the looking Glass)</CODE> evaluates to
<CODE>Through The Looking Glass</CODE>.
<A NAME="@default97"></A><A NAME="@fun52"></A><A NAME="fun:uncapitalize"></A>
<H4 CLASS="subsubsection">uncapitalize</H4>
<PRE CLASS="verbatim">
   $(uncapitalize sequence) : Array
      sequence : Sequence
</PRE>
The <CODE>uncapitalize</CODE> function uncapitalizes each word in its argument.<BR>
<BR>
For example, <CODE>$(uncapitalize through the looking Glass)</CODE> evaluates to
<CODE>through the looking glass</CODE>.
<A NAME="@default98"></A><A NAME="@fun53"></A><A NAME="fun:uppercase"></A>
<H4 CLASS="subsubsection">uppercase</H4>
<PRE CLASS="verbatim">
   $(uppercase sequence) : Array
      sequence : Sequence
</PRE>
The <CODE>uppercase</CODE> function converts each word in a sequence to uppercase.
For example, <CODE>$(uppercase through the looking Glass)</CODE> evaluates to
<CODE>THROUGH THE LOOKING GLASS</CODE>.
<A NAME="@default99"></A><A NAME="@fun54"></A><A NAME="fun:lowercase"></A>
<H4 CLASS="subsubsection">lowercase</H4>
<PRE CLASS="verbatim">
   $(lowercase sequence) : Array
      sequence : Sequence
</PRE>
The <CODE>lowercase</CODE> function reduces each word in its argument to lowercase.<BR>
<BR>
For example, <CODE>$(lowercase through tHe looking Glass)</CODE> evaluates to
<CODE>through the looking glass</CODE>.
<A NAME="@default100"></A><A NAME="@fun55"></A><A NAME="fun:system"></A>
<H4 CLASS="subsubsection">system</H4>
<PRE CLASS="verbatim">
   system(s)
      s : Sequence
</PRE>
The <CODE>system</CODE> function is used to evaluate a shell expression.
This function is used internally by <TT>omake</TT> to evaluate
shell commands.<BR>
<BR>
For example, the following program is equivalent to the
expression <CODE>system(ls foo)</CODE>.
<PRE CLASS="verbatim">
   ls foo
</PRE><A NAME="@default101"></A><A NAME="@fun56"></A><A NAME="fun:shell"></A>
<H4 CLASS="subsubsection">shell</H4>
<PRE CLASS="verbatim">
   $(shell command) : Array
   $(shella command) : Array
   $(shell-code command) : Int
      command : Sequence
</PRE>
The <CODE>shell</CODE> function evaluates a command using the command shell,
and returns the whitespace-separated words of the standard output as the result.<BR>
<BR>
The <CODE>shella</CODE> function acts similarly, but it returns the lines
as separate items in the array.<BR>
<BR>
The <CODE>shell-code</CODE> function returns the exit code. The output is not
diverted.<BR>
<BR>
For example, if the current directory contains the files <CODE>OMakeroot</CODE>,
<CODE>OMakefile</CODE>, and <CODE>hello.c</CODE>, then <CODE>$(shell ls)</CODE> evaluates to
<CODE>hello.c OMakefile OMakeroot</CODE> (on a Unix system).
<A NAME="while"></A>
<A NAME="@default102"></A><A NAME="@fun57"></A><A NAME="fun:while"></A>
<H4 CLASS="subsubsection">while</H4>
<PRE CLASS="verbatim">
   while &lt;test&gt;
      &lt;body&gt;
</PRE>
&ndash;or&ndash;
<PRE CLASS="verbatim">
    while &lt;test&gt;
    case &lt;test1&gt;
       &lt;body1&gt;
    ...
    case &lt;testn&gt;
       &lt;bodyn&gt;
    default
       &lt;bodyd&gt;
</PRE>
The loop is executed while the test is true.
In the first form, the <CODE>&lt;body&gt;</CODE> is executed on every loop iteration.
In the second form, the body <CODE>&lt;bodyI&gt;</CODE> is selected, as the first
case where the test <CODE>&lt;testI&gt;</CODE> is true. If none apply, the optional
default case is evaluated. If no cases are true, the loop exits.
The environment is automatically exported.<BR>
<BR>
Examples.<BR>
<BR>
Iterate for <CODE>i</CODE> from <CODE>0</CODE> to <CODE>9</CODE>.
<PRE CLASS="verbatim">
    i = 0
    while $(lt $i, 10)
       echo $i
       i = $(add $i, 1)
</PRE>
The following example is equivalent.
<PRE CLASS="verbatim">
   i = 0
   while true
   case $(lt $i, 10)
      echo $i
      i = $(add $i, 1)
</PRE>
The following example is similar, but some special cases are printed.
value is printed.
<PRE CLASS="verbatim">
    i = 0
    while $(lt $i, 10)
    case $(equal $i, 0)
       echo zero
    case $(equal $i, 1)
       echo one
    default
       echo $i
</PRE><A NAME="toc61"></A>
<H2 CLASS="section"><A NAME="htoc84">7.4</A>&nbsp;&nbsp;Arithmetic</H2>
<A NAME="@default103"></A><A NAME="@fun58"></A><A NAME="fun:int"></A>
<H4 CLASS="subsubsection">int</H4>
The <CODE>int</CODE> function can be used to create integers.
It returns an <CODE>Int</CODE> object.<BR>
<BR>
<CODE>$(int 17)</CODE>.<BR>
<BR>
<A NAME="@default104"></A><A NAME="@fun59"></A><A NAME="fun:float"></A>
<H4 CLASS="subsubsection">float</H4>
The <CODE>float</CODE> function can be used to create floating-point numbers.
It returns a <CODE>Float</CODE> object.<BR>
<BR>
<CODE>$(float 3.1415926)</CODE>.

<H3 CLASS="subsection"><A NAME="htoc85">7.4.1</A>&nbsp;&nbsp;Basic arithmetic</H3>
<A NAME="@default105"></A><A NAME="@fun60"></A><A NAME="fun:neg"></A>
<A NAME="@default106"></A><A NAME="@fun61"></A><A NAME="fun:add"></A>
<A NAME="@default107"></A><A NAME="@fun62"></A><A NAME="fun:sub"></A>
<A NAME="@default108"></A><A NAME="@fun63"></A><A NAME="fun:mul"></A>
<A NAME="@default109"></A><A NAME="@fun64"></A><A NAME="fun:div"></A>
<A NAME="@default110"></A><A NAME="@fun65"></A><A NAME="fun:mod"></A>
<A NAME="@default111"></A><A NAME="@fun66"></A><A NAME="fun:lnot"></A>
<A NAME="@default112"></A><A NAME="@fun67"></A><A NAME="fun:land"></A>
<A NAME="@default113"></A><A NAME="@fun68"></A><A NAME="fun:lor"></A>
<A NAME="@default114"></A><A NAME="@fun69"></A><A NAME="fun:lxor"></A>
<A NAME="@default115"></A><A NAME="@fun70"></A><A NAME="fun:lsl"></A>
<A NAME="@default116"></A><A NAME="@fun71"></A><A NAME="fun:lsr"></A>
<A NAME="@default117"></A><A NAME="@fun72"></A><A NAME="fun:asr"></A>
The following functions can be used to perform basic arithmetic.
<UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>$(neg &lt;numbers&gt;)</CODE>: arithmetic inverse
<LI CLASS="li-itemize"><CODE>$(add &lt;numbers&gt;)</CODE>: addition.
<LI CLASS="li-itemize"><CODE>$(sub &lt;numbers&gt;)</CODE>: subtraction.
<LI CLASS="li-itemize"><CODE>$(mul &lt;numbers&gt;)</CODE>: multiplication.
<LI CLASS="li-itemize"><CODE>$(div &lt;numbers&gt;)</CODE>: division.
<LI CLASS="li-itemize"><CODE>$(mod &lt;numbers&gt;)</CODE>: remainder.
<LI CLASS="li-itemize"><CODE>$(lnot &lt;numbers&gt;)</CODE>: bitwise inverse.
<LI CLASS="li-itemize"><CODE>$(land &lt;numbers&gt;)</CODE>: bitwise and.
<LI CLASS="li-itemize"><CODE>$(lor &lt;numbers&gt;)</CODE>: bitwise or.
<LI CLASS="li-itemize"><CODE>$(lxor &lt;numbers&gt;)</CODE>: bitwise exclusive-or.
<LI CLASS="li-itemize"><CODE>$(lsl &lt;numbers&gt;)</CODE>: logical shift left.
<LI CLASS="li-itemize"><CODE>$(lsr &lt;numbers&gt;)</CODE>: logical shift right.
<LI CLASS="li-itemize"><CODE>$(asr &lt;numbers&gt;)</CODE>: arithmetic shift right.
</UL>

<H3 CLASS="subsection"><A NAME="htoc86">7.4.2</A>&nbsp;&nbsp;Comparisons</H3>
<A NAME="@default118"></A><A NAME="@fun73"></A><A NAME="fun:lt"></A>
<A NAME="@default119"></A><A NAME="@fun74"></A><A NAME="fun:le"></A>
<A NAME="@default120"></A><A NAME="@fun75"></A><A NAME="fun:eq"></A>
<A NAME="@default121"></A><A NAME="@fun76"></A><A NAME="fun:ge"></A>
<A NAME="@default122"></A><A NAME="@fun77"></A><A NAME="fun:gt"></A>
<A NAME="@default123"></A><A NAME="@fun78"></A><A NAME="fun:ult"></A>
<A NAME="@default124"></A><A NAME="@fun79"></A><A NAME="fun:ule"></A>
<A NAME="@default125"></A><A NAME="@fun80"></A><A NAME="fun:uge"></A>
<A NAME="@default126"></A><A NAME="@fun81"></A><A NAME="fun:ugt"></A>
The following functions can be used to perform numerical comparisons.
<UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>$(lt &lt;numbers&gt;)</CODE>: less then.
<LI CLASS="li-itemize"><CODE>$(le &lt;numbers&gt;)</CODE>: no more than.
<LI CLASS="li-itemize"><CODE>$(eq &lt;numbers&gt;)</CODE>: equal.
<LI CLASS="li-itemize"><CODE>$(ge &lt;numbers&gt;)</CODE>: no less than.
<LI CLASS="li-itemize"><CODE>$(gt &lt;numbers&gt;)</CODE>: greater than.
<LI CLASS="li-itemize"><CODE>$(ult &lt;numbers&gt;)</CODE>: unsigned less than.
<LI CLASS="li-itemize"><CODE>$(ule &lt;numbers&gt;)</CODE>: unsigned greater than.
<LI CLASS="li-itemize"><CODE>$(uge &lt;numbers&gt;)</CODE>: unsigned greater than or equal.
<LI CLASS="li-itemize"><CODE>$(ugt &lt;numbers&gt;)</CODE>: unsigned greater than.
</UL>
<A NAME="toc62"></A>
<H2 CLASS="section"><A NAME="htoc87">7.5</A>&nbsp;&nbsp;First-class functions</H2>
<A NAME="@default127"></A><A NAME="@fun82"></A><A NAME="fun:fun"></A>
<H4 CLASS="subsubsection">fun</H4>
The <CODE>fun</CODE> form introduces anonymous functions.<BR>
<BR>
<CODE>$(fun &lt;v1&gt;, ..., &lt;vn&gt;, &lt;body&gt;)</CODE><BR>
<BR>
The last argument is the body of the function.
The other arguments are the parameter names.<BR>
<BR>
The three following definitions are equivalent.
<PRE CLASS="verbatim">
    F(X, Y) =
       return($(addsuffix $(Y), $(X)))

    F = $(fun X, Y, $(addsuffix $(Y), $(X)))

    F =
       fun(X, Y)
          value $(addsuffix $(Y), $(X))
</PRE><A NAME="@default128"></A><A NAME="@fun83"></A><A NAME="fun:apply"></A>
<H4 CLASS="subsubsection">apply</H4>
The <CODE>apply</CODE> operator is used to apply a function.<BR>
<BR>
<CODE>$(apply &lt;fun&gt;, &lt;args&gt;)</CODE><BR>
<BR>
Suppose we have the following function definition.
<PRE CLASS="verbatim">
    F(X, Y) =
       return($(addsuffix $(Y), $(X)))
</PRE>
The the two expressions below are equivalent.
<PRE CLASS="verbatim">
    X = F(a b c, .c)
    X = $(apply $(F), a b c, .c)
</PRE><A NAME="@default129"></A><A NAME="@fun84"></A><A NAME="fun:applya"></A>
<H4 CLASS="subsubsection">applya</H4>
The <CODE>applya</CODE> operator is used to apply a function to
an array of arguments.<BR>
<BR>
<CODE>$(applya &lt;fun&gt;, &lt;args&gt;)</CODE><BR>
<BR>
For example, in the following program, the value
of <CODE>Z</CODE> is <CODE>file.c</CODE>.
<PRE CLASS="verbatim">
    F(X, Y) =
       return($(addsuffix $(Y), $(X)))
    args[] =
       file
       .c
    Z = $(applya $(F), $(args))
</PRE><A NAME="toc63"></A>
<H2 CLASS="section"><A NAME="htoc88">7.6</A>&nbsp;&nbsp;Iteration and mapping</H2>
<A NAME="@default130"></A><A NAME="@fun85"></A><A NAME="fun:foreach"></A>
<H4 CLASS="subsubsection">foreach</H4>
The <CODE>foreach</CODE> function maps a function over a sequence.
<PRE CLASS="verbatim">
    $(foreach &lt;fun&gt;, &lt;args&gt;)

    foreach(&lt;var&gt;, &lt;args&gt;)
       &lt;body&gt;
</PRE>
For example, the following program defines the variable <CODE>X</CODE>
as an array <CODE>a.c b.c c.c</CODE>.
<PRE CLASS="verbatim">
    X =
       foreach(x, a b c)
          value $(x).c

    # Equivalent expression
    X = $(foreach $(fun x, $(x).c), abc)
</PRE>
There is also an abbreviated syntax.<BR>
<BR>
The <CODE>export</CODE> form can also be used in a <CODE>foreach</CODE>
body. The final value of <CODE>X</CODE> is <CODE>a.c b.c c.c</CODE>.
<PRE CLASS="verbatim">
    X =
    foreach(x, a b c)
       X += $(x).c
       export
</PRE><A HREF="http://omake.metaprl.org/">OMake Home</A>
<A HREF="omake-toc.html">Table of contents</A>
<A HREF="omake.html">Guide</A>
<A HREF="omake-options.html">Options</A>
<A HREF="omake-all-index.html">Index</A>
<A HREF="omake-var-index.html">Variables</A>
<A HREF="omake-fun-index.html">Functions</A>
<A HREF="omake-obj-index.html">Objects</A>
<A HREF="omake-target-index.html">Targets</A>
<HR>
<A HREF="omake-rules.html"><IMG SRC ="previous_motif.gif" ALT="Previous"></A>
<A HREF="omake-toc.html"><IMG SRC ="contents_motif.gif" ALT="Up"></A>
<A HREF="omake-system.html"><IMG SRC ="next_motif.gif" ALT="Next"></A>
</BODY>
</HTML>
