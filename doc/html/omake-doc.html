<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- Manual page created with latex2man --
-- Author of latex2man: Juergen.Vollmer@informatik-vollmer.de --
-- NOTE: This file is generated, DO NOT EDIT. -->
<html>
<head><title>OMAKE</title></head>
<body bgcolor="white">
<h1 align=center>
The OMake build system
</h1>
<h4 align=center>Jason Hickey <em>et. al.</em></h4>
<h4 align=center>April 11, 2006</h4>
<h4 align=center>Version 0.9.6.9</h4>
<tt>omake</tt>
is a build system designed to scale from small projects to very large projects
spanning many directories. <tt>omake</tt>
uses a syntax similar to <em>make</em>(1),
with many
additional features, including accurate automated dependency analysis based on MD5 digests.
<h3>Table of Contents</h3>
<ul>
<li><a href="#section_1">Description </a>
<ul>
<li><a href="#section_2">Automatic dependency analysis </a></li>
<li><a href="#section_3">Content-based dependency analysis </a></li>
</ul>
<li><a href="#section_4">OMake quickstart guide </a>
<ul>
<li><a href="#section_5">For users already familiar with make </a></li>
<li><a href="#section_6">Building a small C program </a></li>
<li><a href="#section_7">Larger projects </a></li>
<li><a href="#section_8">Subdirectories </a></li>
<li><a href="#section_9">Other things to consider </a></li>
<li><a href="#section_10">Building OCaml programs </a></li>
</ul>
<li><a href="#section_11">Notes </a>
<ul>
<li><a href="#section_12">The OMakefile and OMakeroot files </a></li>
</ul>
<li><a href="#section_13">Multiple version support </a>
<ul>
<li><a href="#section_14">Notes </a></li>
</ul>
<li><a href="#section_15">Synopsis </a></li>
<li><a href="#section_16">Command-line options </a></li>
<li><a href="#section_17">OMake concepts and syntax </a>
<ul>
<li><a href="#section_18">Variables </a></li>
<li><a href="#section_19">Adding to a variable definition </a></li>
<li><a href="#section_20">Arrays </a></li>
<li><a href="#section_21">Special characters and quoting </a></li>
<li><a href="#section_22">Function definitions </a></li>
<li><a href="#section_23">Comments </a></li>
<li><a href="#section_24">File inclusion </a></li>
<li><a href="#section_25">Scoping, sections </a></li>
<li><a href="#section_26">Conditionals </a></li>
<li><a href="#section_27">Matching </a></li>
</ul>
<li><a href="#section_28">Objects </a>
<ul>
<li><a href="#section_29">Classes </a></li>
<li><a href="#section_30">Inheritance </a></li>
</ul>
<li><a href="#section_31">Special objects/sections </a>
<ul>
<li><a href="#section_32">private. </a></li>
<li><a href="#section_33">protected. </a></li>
<li><a href="#section_34">public. </a></li>
<li><a href="#section_35">static. </a></li>
<li><a href="#section_36">Short syntax for scoping objects </a></li>
<li><a href="#section_37">Modular programming </a></li>
</ul>
<li><a href="#section_38">Rules </a>
<ul>
<li><a href="#section_39">Implicit rules </a></li>
<li><a href="#section_40">Bounded implicit rules </a></li>
<li><a href="#section_41">section </a></li>
<li><a href="#section_42">section rule </a></li>
</ul>
<li><a href="#section_43">Special dependencies </a>
<ul>
<li><a href="#section_44">:exists: </a></li>
<li><a href="#section_45">:effects: </a></li>
<li><a href="#section_46">:value: </a></li>
</ul>
<li><a href="#section_47">.SCANNER rules </a>
<ul>
<li><a href="#section_48">Named scanners, and the :scanner: target </a></li>
<li><a href="#section_49">Notes </a></li>
</ul>
<li><a href="#section_50">Other special targets </a>
<ul>
<li><a href="#section_51">.DEFAULT </a></li>
<li><a href="#section_52">.SUBDIRS </a></li>
<li><a href="#section_53">.INCLUDE </a></li>
<li><a href="#section_54">.PHONY </a></li>
</ul>
<li><a href="#section_55">Rule scoping </a>
<ul>
<li><a href="#section_56">Scoping of implicit rules </a></li>
<li><a href="#section_57">Scoping of .SCANNER rules </a></li>
<li><a href="#section_58">Scoping for .PHONY targets </a></li>
</ul>
<li><a href="#section_59">The OSH shell </a>
<ul>
<li><a href="#section_60">Startup </a></li>
<li><a href="#section_61">Aliases </a></li>
<li><a href="#section_62">Interactive syntax </a></li>
<li><a href="#section_63">See also </a></li>
</ul>
<li><a href="#section_64">Builtin variables </a>
<ul>
<li><a href="#section_65">OSTYPE </a></li>
<li><a href="#section_66">SYSNAME </a></li>
<li><a href="#section_67">NODENAME </a></li>
<li><a href="#section_68">OS_VERSION </a></li>
<li><a href="#section_69">MACHINE </a></li>
<li><a href="#section_70">HOST </a></li>
<li><a href="#section_71">OMAKE_VERSION </a></li>
<li><a href="#section_72">USER </a></li>
<li><a href="#section_73">HOME </a></li>
<li><a href="#section_74">PID </a></li>
</ul>
<li><a href="#section_75">Boolean functions and control flow </a>
<ul>
<li><a href="#section_76">not </a></li>
<li><a href="#section_77">equal </a></li>
<li><a href="#section_78">and </a></li>
<li><a href="#section_79">or </a></li>
<li><a href="#section_80">if </a></li>
<li><a href="#section_81">switch, match </a></li>
<li><a href="#section_82">try </a></li>
<li><a href="#section_83">raise </a></li>
<li><a href="#section_84">exit </a></li>
<li><a href="#section_85">defined </a></li>
<li><a href="#section_86">defined-env </a></li>
<li><a href="#section_87">getenv </a></li>
<li><a href="#section_88">setenv </a></li>
<li><a href="#section_89">get-registry </a></li>
<li><a href="#section_90">getvar </a></li>
<li><a href="#section_91">setvar </a></li>
</ul>
<li><a href="#section_92">Arrays and sequences </a>
<ul>
<li><a href="#section_93">array </a></li>
<li><a href="#section_94">split </a></li>
<li><a href="#section_95">concat </a></li>
<li><a href="#section_96">length </a></li>
<li><a href="#section_97">nth </a></li>
<li><a href="#section_98">nth-hd </a></li>
<li><a href="#section_99">nth-tl </a></li>
<li><a href="#section_100">sub </a></li>
<li><a href="#section_101">rev </a></li>
<li><a href="#section_102">string </a></li>
<li><a href="#section_103">quote </a></li>
<li><a href="#section_104">quote-argv </a></li>
<li><a href="#section_105">html-string </a></li>
<li><a href="#section_106">addsuffix </a></li>
<li><a href="#section_107">mapsuffix </a></li>
<li><a href="#section_108">addsuffixes </a></li>
<li><a href="#section_109">removeprefix </a></li>
<li><a href="#section_110">removesuffix </a></li>
<li><a href="#section_111">replacesuffixes </a></li>
<li><a href="#section_112">addprefix </a></li>
<li><a href="#section_113">mapprefix </a></li>
<li><a href="#section_114">add-wrapper </a></li>
<li><a href="#section_115">set </a></li>
<li><a href="#section_116">mem </a></li>
<li><a href="#section_117">intersection </a></li>
<li><a href="#section_118">intersects </a></li>
<li><a href="#section_119">set-diff </a></li>
<li><a href="#section_120">filter </a></li>
<li><a href="#section_121">filter-out </a></li>
<li><a href="#section_122">capitalize </a></li>
<li><a href="#section_123">uncapitalize </a></li>
<li><a href="#section_124">uppercase </a></li>
<li><a href="#section_125">lowercase </a></li>
<li><a href="#section_126">system </a></li>
<li><a href="#section_127">shell </a></li>
</ul>
<li><a href="#section_128">Arithmetic </a>
<ul>
<li><a href="#section_129">int </a></li>
<li><a href="#section_130">float </a></li>
<li><a href="#section_131">Basic arithmetic </a></li>
<li><a href="#section_132">Comparisons </a></li>
</ul>
<li><a href="#section_133">First-class functions </a>
<ul>
<li><a href="#section_134">fun </a></li>
<li><a href="#section_135">apply </a></li>
<li><a href="#section_136">applya </a></li>
</ul>
<li><a href="#section_137">Iteration and mapping </a>
<ul>
<li><a href="#section_138">foreach </a></li>
</ul>
<li><a href="#section_139">File operations </a>
<ul>
<li><a href="#section_140">file, dir </a></li>
<li><a href="#section_141">tmpfile </a></li>
<li><a href="#section_142">in </a></li>
<li><a href="#section_143">which </a></li>
<li><a href="#section_144">where </a></li>
<li><a href="#section_145">exists-in-path </a></li>
<li><a href="#section_146">basename </a></li>
<li><a href="#section_147">rootname </a></li>
<li><a href="#section_148">dirof </a></li>
<li><a href="#section_149">fullname </a></li>
<li><a href="#section_150">absname </a></li>
<li><a href="#section_151">homename </a></li>
<li><a href="#section_152">suffix </a></li>
<li><a href="#section_153">file-exists, target-exists, target-is-proper </a></li>
<li><a href="#section_154">filter-exists, filter-targets, filter-proper-targets </a></li>
<li><a href="#section_155">file-sort </a></li>
<li><a href="#section_156">sort rule </a></li>
<li><a href="#section_157">file-check-sort </a></li>
<li><a href="#section_158">glob </a></li>
<li><a href="#section_159">ls </a></li>
<li><a href="#section_160">subdirs </a></li>
<li><a href="#section_161">mkdir </a></li>
<li><a href="#section_162">Stat </a></li>
<li><a href="#section_163">stat </a></li>
<li><a href="#section_164">unlink </a></li>
<li><a href="#section_165">rename </a></li>
<li><a href="#section_166">link </a></li>
<li><a href="#section_167">symlink </a></li>
<li><a href="#section_168">readlink </a></li>
<li><a href="#section_169">chmod </a></li>
<li><a href="#section_170">chown </a></li>
<li><a href="#section_171">umask </a></li>
<li><a href="#section_172">digest </a></li>
<li><a href="#section_173">find-in-path </a></li>
<li><a href="#section_174">digest-path </a></li>
<li><a href="#section_175">rehash </a></li>
<li><a href="#section_176">vmount </a></li>
<li><a href="#section_177">add-project-directories </a></li>
<li><a href="#section_178">remove-project-directories </a></li>
<li><a href="#section_179">test </a></li>
<li><a href="#section_180">find </a></li>
</ul>
<li><a href="#section_181">IO functions </a>
<ul>
<li><a href="#section_182">Standard channels </a></li>
<li><a href="#section_183">fopen </a></li>
<li><a href="#section_184">close </a></li>
<li><a href="#section_185">read </a></li>
<li><a href="#section_186">write </a></li>
<li><a href="#section_187">lseek </a></li>
<li><a href="#section_188">rewind </a></li>
<li><a href="#section_189">tell </a></li>
<li><a href="#section_190">flush </a></li>
<li><a href="#section_191">dup </a></li>
<li><a href="#section_192">dup2 </a></li>
<li><a href="#section_193">set-nonblock </a></li>
<li><a href="#section_194">set-close-on-exec-mode </a></li>
<li><a href="#section_195">pipe </a></li>
<li><a href="#section_196">mkfifo </a></li>
<li><a href="#section_197">select </a></li>
<li><a href="#section_198">lockf </a></li>
<li><a href="#section_199">InetAddr </a></li>
<li><a href="#section_200">Host </a></li>
<li><a href="#section_201">gethostbyname </a></li>
<li><a href="#section_202">Protocol </a></li>
<li><a href="#section_203">getprotobyname </a></li>
<li><a href="#section_204">Service </a></li>
<li><a href="#section_205">getservbyname </a></li>
<li><a href="#section_206">socket </a></li>
<li><a href="#section_207">bind </a></li>
<li><a href="#section_208">listen </a></li>
<li><a href="#section_209">accept </a></li>
<li><a href="#section_210">connect </a></li>
<li><a href="#section_211">getchar </a></li>
<li><a href="#section_212">gets </a></li>
<li><a href="#section_213">fgets </a></li>
<li><a href="#section_214">Printing functions </a></li>
<li><a href="#section_215">Value printing functions </a></li>
</ul>
<li><a href="#section_216">Higher-level IO functions </a>
<ul>
<li><a href="#section_217">Regular expressions </a></li>
<li><a href="#section_218">cat </a></li>
<li><a href="#section_219">grep </a></li>
<li><a href="#section_220">awk </a></li>
<li><a href="#section_221">fsubst </a></li>
<li><a href="#section_222">Lexer </a></li>
<li><a href="#section_223">Lexer matching </a></li>
<li><a href="#section_224">Extending lexer definitions </a></li>
<li><a href="#section_225">Threading the lexer object </a></li>
<li><a href="#section_226">Parser </a></li>
<li><a href="#section_227">Calling the parser </a></li>
<li><a href="#section_228">Parsing control </a></li>
<li><a href="#section_229">Extending parsers </a></li>
<li><a href="#section_230">gettimeofday </a></li>
</ul>
<li><a href="#section_231">Shell functions </a>
<ul>
<li><a href="#section_232">echo </a></li>
<li><a href="#section_233">jobs </a></li>
<li><a href="#section_234">cd </a></li>
<li><a href="#section_235">bg </a></li>
<li><a href="#section_236">fg </a></li>
<li><a href="#section_237">stop </a></li>
<li><a href="#section_238">wait </a></li>
<li><a href="#section_239">kill </a></li>
<li><a href="#section_240">history </a></li>
</ul>
<li><a href="#section_241">Pervasives </a>
<ul>
<li><a href="#section_242">Object </a></li>
<li><a href="#section_243">Map </a></li>
<li><a href="#section_244">Number </a></li>
<li><a href="#section_245">Int </a></li>
<li><a href="#section_246">Float </a></li>
<li><a href="#section_247">Sequence </a></li>
<li><a href="#section_248">Array </a></li>
<li><a href="#section_249">String </a></li>
<li><a href="#section_250">Fun </a></li>
<li><a href="#section_251">Rule </a></li>
<li><a href="#section_252">Target </a></li>
<li><a href="#section_253">Node </a></li>
<li><a href="#section_254">File </a></li>
<li><a href="#section_255">Dir </a></li>
<li><a href="#section_256">Channel </a></li>
<li><a href="#section_257">InChannel </a></li>
<li><a href="#section_258">OutChannel </a></li>
<li><a href="#section_259">Location </a></li>
<li><a href="#section_260">Position </a></li>
<li><a href="#section_261">Exception </a></li>
<li><a href="#section_262">RuntimeException </a></li>
<li><a href="#section_263">Shell </a></li>
</ul>
<li><a href="#section_264">Build functions </a>
<ul>
<li><a href="#section_265">OMakeFlags </a></li>
<li><a href="#section_266">OMakeVersion </a></li>
<li><a href="#section_267">cmp-versions </a></li>
<li><a href="#section_268">DefineCommandVars </a></li>
</ul>
<li><a href="#section_269">The OMakeroot file </a>
<ul>
<li><a href="#section_270">Variables </a></li>
<li><a href="#section_271">System variables </a></li>
</ul>
<li><a href="#section_272">Building C programs </a>
<ul>
<li><a href="#section_273">C configuration variables </a></li>
<li><a href="#section_274">CGeneratedFiles, LocalCGeneratedFiles </a></li>
<li><a href="#section_275">StaticCLibrary </a></li>
<li><a href="#section_276">StaticCLibraryCopy </a></li>
<li><a href="#section_277">StaticCLibraryInstall </a></li>
<li><a href="#section_278">StaticCObject, StaticCObjectCopy, StaticCObjectInstall </a></li>
<li><a href="#section_279">CProgram </a></li>
<li><a href="#section_280">CProgramCopy </a></li>
<li><a href="#section_281">CProgramInstall </a></li>
<li><a href="#section_282">CXXProgram, CXXProgramInstall </a></li>
</ul>
<li><a href="#section_283">Building OCaml programs </a>
<ul>
<li><a href="#section_284">Variables for OCaml programs </a></li>
<li><a href="#section_285">OCaml command flags </a></li>
<li><a href="#section_286">Library variables </a></li>
<li><a href="#section_287">OCamlGeneratedFiles, LocalOCamlGeneratedFiles </a></li>
<li><a href="#section_288">OCamlLibrary </a></li>
<li><a href="#section_289">OCamlLibraryCopy </a></li>
<li><a href="#section_290">OCamlLibraryInstall </a></li>
<li><a href="#section_291">OCamlProgram </a></li>
<li><a href="#section_292">OCamlProgramCopy </a></li>
<li><a href="#section_293">OCamlProgramInstall </a></li>
</ul>
<li><a href="#section_294">Building LaTeX programs</a>
<ul>
<li><a href="#section_295">Configuration variables </a></li>
<li><a href="#section_296">LaTeXDocument </a></li>
<li><a href="#section_297">TeXGeneratedFiles, LocalTeXGeneratedFiles </a></li>
<li><a href="#section_298">LaTeXDocumentCopy </a></li>
<li><a href="#section_299">LaTeXDocumentInstall </a></li>
</ul>
<li><a href="#section_300">Examining the dependency graph </a>
<ul>
<li><a href="#section_301">dependencies, dependencies-all </a></li>
<li><a href="#section_302">target </a></li>
<li><a href="#section_303">rule </a></li>
</ul>
<li><a href="#section_304">References </a>
<ul>
<li><a href="#section_305">See Also </a></li>
<li><a href="#section_306">Version </a></li>
<li><a href="#section_307">License and Copyright </a></li>
<li><a href="#section_308">Author </a></li>
</ul>
</li>
</ul>
<p>
<h2><a name="section_1">Description</a></h2>

<p>
<tt>omake</tt>
is designed for building projects that might have source files in several directories.
Projects are normally specified using an <tt>OMakefile</tt>
in each of the project directories, and an
<tt>OMakeroot</tt>
file in the root directory of the project. The <tt>OMakeroot</tt>
file specifies
general build rules, and the <tt>OMakefile</tt>s
specify the build parameters specific to each of the
subdirectories. When <tt>omake</tt>
runs, it walks the configuration tree, evaluating rules from all
of the <tt>OMakefile</tt>s.
The project is then built from the entire collection of build rules.
<p>
<h4><a name="section_2">Automatic dependency analysis</a></h4>

<p>
Dependency analysis has always been problematic with the <em>make</em>(1)
program. <tt>omake</tt>
addresses this by adding the <tt>.SCANNER</tt> target, which specifies a command to produce
dependencies. For example, the following rule
<p>
<pre>
    .SCANNER: %.o: %.c
        $(CC) $(INCLUDE) -MM $&lt;
</pre>
<p>
is the standard way to generate dependencies for <tt>.c</tt> files. <tt>omake</tt>
will automatically
run the scanner when it needs to determine dependencies for a file.
<p>
<h4><a name="section_3">Content-based dependency analysis</a></h4>

<p>
Dependency analysis in omake uses MD5 digests to determine whether files have changed. After each
run, <tt>omake</tt>
stores the dependency information in a file called <tt>.omakedb</tt>
in the project
root directory. When a rule is considered for execution, the command is not executed if the target,
dependencies, and command sequence are unchanged since the last run of <tt>omake</tt>.
As an
optimization, <tt>omake</tt>
does not recompute the digest for a file that has an unchanged
modification time, size, and inode number.
<p>
See the following manual pages for more information.
<p>
<dl compact>
<dt><a href="omake-quickstart.html">omake-quickstart</a>
</dt>
<dd>
A quickstart guide to using <tt>omake</tt>.
</dd>
<dt><a href="omake-options.html">omake-options</a>
</dt>
<dd>
Command-line options for <tt>omake</tt>.
</dd>
<dt><a href="omake-root.html">omake-root</a>
</dt>
<dd>
The system <tt>OMakeroot</tt>
contains the default specification of how to build C, OCaml, and
LaTeXprograms.
</dd>
<dt><a href="omake-language.html">omake-language</a>
</dt>
<dd>
The <tt>omake</tt>
language, including a description of objects, expressions, and values.
</dd>
<dt><a href="omake-shell.html">omake-shell</a>
</dt>
<dd>
Using the <tt>omake</tt>
shell for command-line interpretation.
</dd>
<dt><a href="omake-rules.html">omake-rules</a>
</dt>
<dd>
Using <tt>omake</tt>
rules to build program.
</dd>
<dt><a href="omake-base.html">omake-base</a>
</dt>
<dd>
Functions and variables in the core standard library.
</dd>
<dt><a href="omake-system.html">omake-system</a>
</dt>
<dd>
Functions on files, input/output, and system commands.
</dd>
<dt><a href="omake-pervasives.html">omake-pervasives</a>
</dt>
<dd>
Pervasives defines the built-in objects.
</dd>
<dt><a href="osh.html">osh</a>
</dt>
<dd>
The <tt>osh</tt>
command-line interpreter.
</dd>
<dt><a href="omake-doc.html">omake-doc</a>
</dt>
<dd>
All the OMake documentation in a single page.
</dd>
</dl>
<p>
<h2><a name="section_4">OMake quickstart guide</a></h2>

<p>
<h4><a name="section_5">For users already familiar with make</a></h4>

<p>
For users already familiar with the <em>make</em>(1)
command, here is a list of
differences to keep in mind when using <tt>omake</tt>.
<p>
<ul compact>
<li>In <tt>omake</tt>, you are much less likely to define build rules of your own.
The system provides many standard function (like <tt>StaticCLibrary</tt> and <tt>CProgram</tt>)
to specify these builds more simply.
</li>
<li>Implicit rules using <tt>.SUFFIXES</tt> and the <tt>.suf1.suf2:</tt> are not supported.
You should use wildcard patterns instead <tt>%.suf2: %.suf1</tt>.
</li>
<li>Scoping is significant: you should define variables and <tt>.PHONY</tt> targets before they are used.
</li>
<li>Subdirectories are incorporated into a project using the <tt>.SUBDIRS:</tt>
target.
</li>
</ul>
<p>
<h4><a name="section_6">Building a small C program</a></h4>

<p>
To start a new project, the easiest method is to change directories to the project
root and use the command <tt>omake --install</tt> to install default <tt>OMakefile</tt>s.
<p>
<pre>
    $ cd ~/newproject
    $ omake --install
    *** omake: creating OMakeroot
    *** omake: creating OMakefile
    *** omake: project files OMakefile and OMakeroot have been installed
    *** omake: you should edit these files before continuing
</pre>
<p>
The default <tt>OMakefile</tt>
contains sections for building C and OCaml programs.
For now, we'll build a simple C project.
<p>
Suppose we have a C file called <tt>hello_code.c</tt> containing the following code:
<p>
<pre>
    #include &lt;stdio.h&gt;

    int main(int argc, char **argv)
    {
        printf("Hello world\n");
        return 0;
    }
</pre>
<p>
To build the program a program <tt>hello</tt> from this file, we can use the <tt>CProgram</tt> function.
The <tt>OMakefile</tt>
contains just one line that specifies that the program <tt>hello</tt> is
to be built from the source code in the <tt>hello_code.c</tt> file (note that file suffixes
are not passed to these functions).
<p>
<pre>
    CProgram(hello, hello_code)
</pre>
<p>
Now we can run <tt>omake</tt>
to build the project. Note that the first time we run <tt>omake</tt>,
it both scans the <tt>hello_code.c</tt> file for dependencies, and compiles it using the <tt>cc</tt>
compiler. The status line printed at the end indicates how many files were scanned, how many
were built, and how many MD5 digests were computed.
<p>
<pre>
    $ omake hello
    *** omake: reading OMakefiles
    *** omake: finished reading OMakefiles (0.0 sec)
    - scan . hello_code.o
    + cc -I. -MM hello_code.c
    - build . hello_code.o
    + cc -I. -c -o hello_code.o hello_code.c
    - build . hello
    + cc -o hello hello_code.o
    *** omake: done (0.5 sec, 1/6 scans, 2/6 rules, 5/22 digests)
    $ omake
    *** omake: reading OMakefiles
    *** omake: finished reading OMakefiles (0.1 sec)
    *** omake: done (0.1 sec, 0/4 scans, 0/4 rules, 0/9 digests)
</pre>
<p>
If we want to change the compile options, we can redefine the <tt>CC</tt> and <tt>CFLAGS</tt>
variables <em>before</em>
the <tt>CProgram</tt> line. In this example, we will use the <tt>gcc</tt>
compiler with the <tt>-g</tt> option. In addition, we will specify a <tt>.DEFAULT</tt> target
to be built by default. The <tt>EXE</tt> variable is defined to be <tt>.exe</tt> on <tt>Win32</tt>
systems; it is empty otherwise.
<p>
<pre>
    CC = gcc
    CFLAGS += -g
    CProgram(hello, hello_code)
    .DEFAULT: hello$(EXE)
</pre>
<p>
Here is the corresponding run for <tt>omake</tt>.
<p>
<pre>
    $ omake
    *** omake: reading OMakefiles
    *** omake: finished reading OMakefiles (0.0 sec)
    - scan . hello_code.o
    + gcc -g -I. -MM hello_code.c
    - build . hello_code.o
    + gcc -g -I. -c -o hello_code.o hello_code.c
    - build . hello
    + gcc -g -o hello hello_code.o
    *** omake: done (0.4 sec, 1/7 scans, 2/7 rules, 3/22 digests)
</pre>
<p>
We can, of course, include multiple files in the program. Suppose we write a new
file <tt>hello_helper.c</tt>. We would include this in the project as follows.
<p>
<pre>
    CC = gcc
    CFLAGS += -g
    CProgram(hello, hello_code hello_helper)
    .DEFAULT: hello$(EXE)
</pre>
<p>
<h4><a name="section_7">Larger projects</a></h4>

<p>
As the project grows it is likely that we will want to build libraries of code.
Libraries can be built using the <tt>StaticCLibrary</tt> function. Here is an example
of an <tt>OMakefile</tt>
with two libraries.
<p>
<pre>
    CC = gcc
    CFLAGS += -g

    FOO_FILES = foo_a foo_b
    BAR_FILES = bar_a bar_b bar_c

    StaticCLibrary(libfoo, $(FOO_FILES))
    StaticCLibrary(libbar, $(BAR_FILES))

    # The hello program is linked with both libraries
    LIBS = libfoo libbar
    CProgram(hello, hello_code hello_helper)

    .DEFAULT: hello$(EXE)
</pre>
<p>
<h4><a name="section_8">Subdirectories</a></h4>

<p>
As the project grows even further, it is a good idea to split it into several directories.
Suppose we place the <tt>libfoo</tt> and <tt>libbar</tt> into subdirectories.
<p>
In each subdirectory, we define an <tt>OMakefile</tt>
for that directory. For example, here
is an example <tt>OMakefile</tt>
for the <tt>foo</tt> subdirectory.
<p>
<pre>
    INCLUDES += .. ../bar

    FOO_FILES = foo_a foo_b
    StaticCLibrary(libfoo, $(FOO_FILES))
</pre>
<p>
Note the the <tt>INCLUDES</tt> variable is defined to include the other directories in the project.
<p>
Now, the next step is to link the subdirectories into the main project. The project <tt>OMakefile</tt>
should be modified to include a <tt>.SUBDIRS:</tt> target.
<p>
<pre>
    # Project configuration
    CC = gcc
    CFLAGS += -g

    # Subdirectories
    .SUBDIRS: foo bar

    # The libraries are now in subdirectories
    LIBS = foo/libfoo bar/libbar

    CProgram(hello, hello_code hello_helper)

    .DEFAULT: hello$(EXE)
</pre>
<p>
Note that the variables <tt>CC</tt> and <tt>CFLAGS</tt> are defined <em>before</em>
the <tt>.SUBDIRS</tt>
target. These variables remain defined in the subdirectories, so that <tt>libfoo</tt> and <tt>libbar</tt>
use <tt>gcc -g</tt>.
<p>
If the two directories are to be configured differently, we have two choices. The <tt>OMakefile</tt>
in each subdirectory can be modified with its configuration (this is how it would normally be done).
Alternatively, we can also place the change in the root <tt>OMakefile</tt>.
<p>
<pre>
    # Default project configuration
    CC = gcc
    CFLAGS += -g

    # libfoo uses the default configuration
    .SUBDIRS: foo

    # libbar uses the optimizing compiler
    CFLAGS += -O3
    .SUBDIRS: bar

    # Main program
    LIBS = foo/libfoo bar/libbar
    CProgram(hello, hello_code hello_helper)

    .DEFAULT: hello$(EXE)
</pre>
<p>
Note that the way we have specified it, the <tt>CFLAGS</tt> variable also contains the <tt>-O3</tt>
option for the <tt>CProgram</tt>, and <tt>hello_code.c</tt> and <tt>hello_helper.c</tt> file will both be
compiled with the <tt>-O3</tt> option. If we want to make the change truly local to <tt>libbar</tt>, we
can put the <tt>bar</tt> subdirectory in its own scope using the <tt>section</tt> form.
<p>
<pre>
    # Default project configuration
    CC = gcc
    CFLAGS += -g

    # libfoo uses the default configuration
    .SUBDIRS: foo

    # libbar uses the optimizing compiler
    section
        CFLAGS += -O3
        .SUBDIRS: bar

    # Main program does not use the optimizing compiler
    LIBS = foo/libfoo bar/libbar
    CProgram(hello, hello_code hello_helper)

    .DEFAULT: hello$(EXE)
</pre>
<p>
Later, suppose we decide to port this project to <tt>Win32</tt>, and we discover that we need
different compiler flags and an additional library.
<p>
<pre>
    # Default project configuration
    if $(equal $(OSTYPE), Win32)
        CC = cl /nologo
        CFLAGS += /DWIN32 /MT
        export
    else
        CC = gcc
        CFLAGS += -g
        export

    # libfoo uses the default configuration
    .SUBDIRS: foo

    # libbar uses the optimizing compiler
    section
        CFLAGS += $(if $(equal $(OSTYPE), Win32), $(EMPTY), -O3)
        .SUBDIRS: bar

    # Default libraries
    LIBS = foo/libfoo bar/libbar

    # We need libwin32 only on Win32
    if $(equal $(OSTYPE), Win32)
       LIBS += win32/libwin32

       .SUBDIRS: win32
       export

    # Main program does not use the optimizing compiler
    CProgram(hello, hello_code hello_helper)

    .DEFAULT: hello$(EXE)
</pre>
<p>
Note the use of the <tt>export</tt> directives to export the variable definitions from the
if-statements. Variables in <tt>omake</tt>
are <em>scoped</em>---variables
in nested blocks (blocks
with greater indentation), are not normally defined in outer blocks. The <tt>export</tt> directive
specifies that the variable definitions in the nested blocks should be exported to their parent
block.
<p>
Finally, for this example, we decide to copy all libraries into a common <tt>lib</tt> directory. We
first define a directory variable, and replace occurrences of the <tt>lib</tt> string with the
variable.
<p>
<pre>
    # The common lib directory
    LIB = $(dir lib)

    # phony target to build just the libraries
    .PHONY: makelibs

    # Default project configuration
    if $(equal $(OSTYPE), Win32)
        CC = cl /nologo
        CFLAGS += /DWIN32 /MT
        export
    else
        CC = gcc
        CFLAGS += -g
        export

    # libfoo uses the default configuration
    .SUBDIRS: foo

    # libbar uses the optimizing compiler
    section
        CFLAGS += $(if $(equal $(OSTYPE), Win32), $(EMPTY), -O3)
        .SUBDIRS: bar

    # Default libraries
    LIBS = $(LIB)/libfoo $(LIB)/libbar

    # We need libwin32 only on Win32
    if $(equal $(OSTYPE), Win32)
       LIBS += $(LIB)/libwin32

       .SUBDIRS: win32
       export

    # Main program does not use the optimizing compiler
    CProgram(hello, hello_code hello_helper)

    .DEFAULT: hello$(EXE)
</pre>
<p>
In each subdirectory, we modify the <tt>OMakefile</tt>s
in the library directories to install them
into the <tt>$(LIB)</tt> directory. Here is the relevant change to <tt>foo/OMakefile</tt>.
<p>
<pre>
    INCLUDES += .. ../bar

    FOO_FILES = foo_a foo_b
    StaticCLibraryInstall(makelib, $(LIB), libfoo, $(FOO_FILES))
</pre>
<p>
Directory (and file names) evaluate to relative pathnames. Within the <tt>foo</tt> directory, the
<tt>$(LIB)</tt> variable evaluates to <tt>../lib</tt>.
<p>
As another example, instead of defining the <tt>INCLUDES</tt> variable separately
in each subdirectory, we can define it in the toplevel as follows.
<p>
<pre>
    INCLUDES = $(ROOT) $(dir foo bar win32)
</pre>
<p>
In the <tt>foo</tt> directory, the <tt>INCLUDES</tt> variable will evaluate to
the string <tt>.. . ../bar ../win32</tt>. In the <tt>bar</tt> directory,
it would be <tt>.. ../foo . ../win32</tt>. In the root directory it
would be <tt>. foo bar win32</tt>.
<p>
<h4><a name="section_9">Other things to consider</a></h4>

<p>
<tt>omake</tt>
also handles recursive subdirectories. For example, suppose the <tt>foo</tt>
directory itself contains several subdirectories. The <tt>foo/OMakefile</tt>
would then
contain its own <tt>.SUBDIRS</tt> target, and each of its subdirectories would
contain its own <tt>OMakefile</tt>.
<p>
<h4><a name="section_10">Building OCaml programs</a></h4>

<p>
By default, <tt>omake</tt>
is also configured with functions for building OCaml programs.
The functions for OCaml program use the <tt>OCaml</tt> prefix. For example, suppose
we reconstruct the previous example in OCaml, and we have a file called <tt>hello_code.ml</tt>
that contains the following code.
<p>
<pre>
   open Printf

   let () = printf "Hello world\n"
</pre>
<p>
An example <tt>OMakefile</tt>
for this simple project would contain the following.
<p>
<pre>
    # Use the byte-code compiler
    BYTE_ENABLED = true
    NATIVE_ENABLED = false
    OCAMLCFLAGS += -g

    # Build the program
    OCamlProgram(hello, hello_code)
    .DEFAULT: hello.run
</pre>
<p>
Next, suppose the we have two library subdirectories: the <tt>foo</tt> subdirectory
is written in C, the <tt>bar</tt> directory is written in OCaml, and we need to
use the standard OCaml <tt>Unix</tt> module.
<p>
<pre>
    # Default project configuration
    if $(equal $(OSTYPE), Win32)
        CC = cl /nologo
        CFLAGS += /DWIN32 /MT
        export
    else
        CC = gcc
        CFLAGS += -g
        export

    # Use the byte-code compiler
    BYTE_ENABLED = true
    NATIVE_ENABLED = false
    OCAMLCFLAGS += -g

    # library subdirectories
    INCLUDES += $(dir foo bar)
    OCAMLINCLUDES += $(dir foo bar)
    .SUBDIRS: foo bar

    # C libraries
    LIBS = foo/libfoo

    # OCaml libraries
    OCAML_LIBS = bar/libbar

    # Also use the Unix module
    OCAML_OTHER_LIBS = unix

    # The main program
    OCamlProgram(hello, hello_code hello_helper)

    .DEFAULT: hello
</pre>
<p>
The <tt>foo/OMakefile</tt>
would be configured as a C library.
<p>
<pre>
    FOO_FILES = foo_a foo_b
    StaticCLibrary(libfoo, $(FOO_FILES))
</pre>
<p>
The <tt>bar/OMakefile</tt>
would build an ML library.
<p>
<pre>
   BAR_FILES = bar_a bar_b bar_c
   OCamlLibrary(libbar, $(BAR_FILES))
</pre>
<p>
<h2><a name="section_11">Notes</a></h2>

<p>
<h4><a name="section_12">The OMakefile and OMakeroot files</a></h4>

<p>
<tt>OMake</tt>
uses the <tt>OMakefile</tt>
and <tt>OMakeroot</tt>
files for configuring a project. The
syntax of these files is the same, but their role is slightly different. For one thing, every
project must have exactly one <tt>OMakeroot</tt>
file in the project root directory. This file serves
to identify the project root, and it contains code that sets up the project. In contrast, a
multi-directory project will often have an <tt>OMakefile</tt>
in each of the project subdirectories,
specifying how to build the files in that subdirectory.
<p>
Normally, the <tt>OMakeroot</tt>
file is boilerplate. The following listing is a typical example.
<p>
<pre>
    include $(STDLIB)/build/Common
    include $(STDLIB)/build/C
    include $(STDLIB)/build/OCaml
    include $(STDLIB)/build/LaTeX

    # Redefine the command-line variables
    DefineCommandVars(.)

    # The current directory is part of the project
    .SUBDIRS: .
</pre>
<p>
The <tt>include</tt> lines include the standard configuration files needed for the project. The
<tt>$(STDLIB)</tt> represents the <tt>omake</tt>
library directory. The only required configuration
file is <tt>Common</tt>. The others are optional; for example, the <tt>$(STDLIB)/build/OCaml</tt> file
is needed only when the project contains programs written in OCaml.
<p>
The <tt>DefineCommandVars</tt> function defines any variables specified on the command line (as
arguments of the form <tt>VAR=&lt;value&gt;</tt>). The <tt>.SUBDIRS</tt> line specifies that the current
directory is part of the project (so the <tt>OMakefile</tt> should be read).
<p>
Normally, the <tt>OMakeroot</tt> file should be small and project-independent. Any project-specific
configuration should be placed in the <tt>OMakefiles</tt> of the project.
<p>
<h2><a name="section_13">Multiple version support</a></h2>

<p>
OMake version <tt>0.9.6</tt> introduced preliminary support for multiple, simultaneous versions of a
project. Versioning uses the <tt>vmount(dir1, dir2)</tt> function, which defines a &ldquo;virtual mount&rdquo;
of directory <tt>dir1</tt> over directory <tt>dir2</tt>. A &ldquo;virtual mount&rdquo; is like a transparent
mount in Unix, where the files from <tt>dir1</tt> appear in the <tt>dir2</tt> namespace, but new files
are created in <tt>dir2</tt>. More precisely, the filename <tt>dir2/foo</tt> refers to: a) the file
<tt>dir1/foo</tt> if it exists, or b) <tt>dir2/foo</tt> otherwise.
<p>
The <tt>vmount</tt> function makes it easy to specify multiple versions of a project. Suppose we have
a project where the source files are in the directory <tt>src/</tt>, and we want to compile two
versions, one with debugging support and one optimized. We create two directories, <tt>debug</tt>
and
<tt>opt</tt>,
and mount the <tt>src</tt>
directory over them.
<p>
<pre>
    section
        CFLAGS += -g
        vmount(-l, src, debug)
        .SUBDIRS: debug

    section
        CFLAGS += -O3
        vmount(-l, src, opt)
        .SUBDIRS: opt
</pre>
<p>
Here, we are using <tt>section</tt> blocks to define the scope of the <tt>vmount</tt>---you may not need
them in your project.
<p>
The <tt>-l</tt> option is optional. It specifies that files form the <tt>src</tt> directory should be
linked into the target directories (or copied, if the system is Win32). The links are added as
files are referenced. If no options are given, then files are not copied or linked, but filenames
are translated to refer directly to the <tt>src/</tt> files.
<p>
Now, when a file is referenced in the <tt>debug</tt> directory, it is linked from the <tt>src</tt>
directory if it exists. For example, when the file <tt>debug/OMakefile</tt> is read, the
<tt>src/OMakefile</tt> is linked into the <tt>debug/</tt> directory.
<p>
The <tt>vmount</tt> model is fairly transparent. The <tt>OMakefile</tt>s can be written <em>as if</em>
referring to files in the <tt>src/</tt> directory---they need not be aware of mounting.
However, there are a few points to keep in mind.
<p>
<h4><a name="section_14">Notes</a></h4>

<p>
<ul compact>
<li>When using the <tt>vmount</tt> function for versioning, it wise to keep the source files
distinct from the compiled versions. For example, suppose the source directory contained a file
<tt>src/foo.o</tt>. When mounted, the <tt>foo.o</tt> file will be the same in all versions, which is
probably not what you want. It is better to keep the <tt>src/</tt> directory pristine, containing no
compiled code.
<p>
</li>
<li>When using the <tt>vmount -l</tt> option, files are linked into the version directory only if
they are referenced in the project. Functions that examine the filesystem (like <tt>$(ls ...)</tt>)
may produce unexpected results.
</li>
</ul>
<p>
<h2><a name="section_15">Synopsis</a></h2>

<p>
<tt>omake</tt>
[<b>-k</b>]
[<b>-j</b><i>count</i>]
[<b>-n</b>]
[<b>-s</b>]
[<b>-S</b>]
[<b>-p</b>]
[<b>-P</b>]
[<b>-w</b>]
[<b>-t</b>]
[<b>-u</b>]
[<b>-U</b>]
[<b>-R</b>]
[<b>--project</b>]
[<b>--progress</b>]
[<b>--no-progress</b>]
[<b>--print-status</b>]
[<b>--no-print-status</b>]
[<b>--print-exit</b>]
[<b>--no-print-exit</b>]
[<b>--print-dependencies</b>]
[<b>--show-dependencies</b><i> target</i>]
[<b>--force-dotomake</b>]
[<b>--dotomake</b><i> dir</i>]
[<b>--flush-includes</b>]
[<b>--configure</b>]
[<b>--install</b>]
[<b>--install-all</b>]
[<b>--install-force</b>]
[<b>--version</b>]
[<i>filename...</i>]
[<b>var-definition...</b>]
<p>
<h2><a name="section_16">Command-line options</a></h2>

<p>
<dl compact>
<dt><b>-k</b>
</dt>
<dd> Do not abort when a build command fails;
continue to build as much of the project as possible.
<p>
</dd>
<dt><b>-n</b>
</dt>
<dd> Print the commands that would be executed, but do no execute them.
This can be used to see what would happen if the project were to be built.
<p>
</dd>
<dt><b>-s</b>
</dt>
<dd> Do not print commands as they are executed (be &ldquo;silent&rdquo;).
<p>
</dd>
<dt><b>-S</b>
</dt>
<dd> Do not print commands as they are executed <em>unless</em>
they produce output.
<p>
</dd>
<dt><b>--progress</b>
</dt>
<dd> Print a progress indicator.
This is normally used with the <b>-s</b>
or <b>-S</b>
options.
<p>
</dd>
<dt><b>--no-progress</b>
</dt>
<dd> Do not print a progress indicator (default).
<p>
</dd>
<dt><b>--print-exit</b>
</dt>
<dd> Print termination codes when commands complete.
<p>
</dd>
<dt><b>--no-print-exit</b>
</dt>
<dd> Do not print termination codes when commands complete (default).
<p>
</dd>
<dt><b>-w</b>
</dt>
<dd> Print directory information in <tt>make</tt>
format as commands are executed.
This is mainly useful for editors that expect <tt>make</tt>-style
directory information for determining the location of errors.
<p>
</dd>
<dt><b>-p</b>
</dt>
<dd> Watch the filesystem for changes, and continue the build until it succeeds. If this
option is specified, <tt>omake</tt>
will restart the build whenever source files are modified.
<p>
</dd>
<dt><b>-P</b>
</dt>
<dd> Watch the filesystem for changes forever. If this option is specified, <tt>omake</tt>
will restart the build whenever source files are modified.
<p>
</dd>
<dt><b>-R</b>
</dt>
<dd> Ignore the current directory and build the project from its root directory. When
<tt>omake</tt>
is run in a subdirectory of a project, it normally builds files within the current
directory and its subdirectories. If the <b>-R</b>
option is specified, the build is performed as if
<tt>omake</tt>
were run in the project root.
<p>
</dd>
<dt><b>-t</b>
</dt>
<dd> Update the <tt>omake</tt>
database to force the project to be considered up-to-date.
<p>
</dd>
<dt><b>-U</b>
</dt>
<dd> Do not trust cached build information. This will force the entire project to be rebuilt.
<p>
</dd>
<dt><b>--depend</b>
</dt>
<dd> Do not trust cached dependency information. This will force files to be rescanned
for dependency information.
<p>
</dd>
<dt><b>--configure</b>
</dt>
<dd> Re-run <tt>static.\</tt> sections of the included omake files, instead of
trusting the cached results.
<p>
</dd>
<dt>[<b>--force-dotomake</b>]
</dt>
<dd> Always use the <tt>$HOME/.omake</tt> for the <tt>.omc</tt> cache files.
<p>
</dd>
<dt>[<b>--dotomake</b><i> dir</i>]
</dt>
<dd> Use the specified directory instead of the <tt>$HOME/.omake</tt>
for the placement of the <tt>.omc</tt> cache files.
<p>
</dd>
<dt><b>-j</b><i>count</i>
</dt>
<dd> Run multiple build commands in parallel. The <i>count</i>
specifies a
bound on the number of commands to run simultaneously. In addition, the count may specify servers
for remote execution of commands in the form <tt>server=count</tt>. For example, the option
<tt>-j 2:small.host.org=1:large.host.org=4</tt> would specify that up to 2 jobs can be executed
locally, 1 on the server <tt>small.host.org</tt> and 4 on <tt>large.host.org</tt>. Each remote server
must use the same filesystem location for the project.
<p>
Remote execution is currently an experimental feature. Remote filesystems like NFS do not provide
adequate file consistency for this to work.
<p>
</dd>
<dt><b>--print-dependencies</b>
</dt>
<dd> Print dependency information for the targets on the command line.
<p>
</dd>
<dt><b>--show-dependencies</b><i> target</i>
</dt>
<dd> Print dependency information <em>if</em>
the <tt>target</tt> is built.
<p>
</dd>
<dt><b>--install</b>
</dt>
<dd> Install default files <tt>OMakefile</tt>
and <tt>OMakeroot</tt>
into the current
directory. You would typically do this to start a project in the current directory.
<p>
</dd>
<dt><b>--install-all</b>
</dt>
<dd> In addition to installing files <tt>OMakefile</tt>
and <tt>OMakeroot</tt>,
install default <tt>OMakefile</tt>s
into each subdirectory of the current directory.
<em>cvs</em>(1)
rules are used for filtering the subdirectory list. For example, <tt>OMakefile</tt>s
are not copied into directories called <tt>CVS</tt>, <tt>RCCS</tt>, etc.
<p>
</dd>
<dt><b>--install-force</b>
</dt>
<dd> Normally, <tt>omake</tt>
will prompt before it overwrites any
existing <tt>OMakefile</tt>.
If this option is given, all files are forcibly overwritten
without prompting.
<p>
</dd>
<dt><b>var-definition</b>
</dt>
<dd> <tt>omake</tt>
variables can also be defined on the command
line in the form <tt>name=value</tt>. For example, the <tt>CFLAGS</tt> variable might be defined
on the command line with the argument <tt>CFLAGS="-Wall -g"</tt>.
</dd>
</dl>
<p>
In addition, <tt>omake</tt>
supports a number of debugging flags on the command line. Run
<tt>omake --help</tt> to get a summary of these flags.
<p>
<h2><a name="section_17">OMake concepts and syntax</a></h2>

<p>
Projects are specified to <tt>omake</tt>
with <tt>OMakefile</tt>s.
The <tt>OMakefile</tt>
has a format
similar to a <tt>Makefile</tt>.
An <tt>OMakefile</tt>
has three main kinds of syntactic objects:
variable definitions, function definitions, and rule definitions.
<p>
<h4><a name="section_18">Variables</a></h4>

<p>
Variables are defined with the following syntax. The name is any sequence of alphanumeric
characters, underscore <tt>_</tt>, and hyphen <tt>-</tt>.
<p>
<pre>
   &lt;name&gt; = &lt;value&gt;
</pre>
<p>
Values are defined as a sequence of literal characters and variable expansions. A variable
expansion has the form <tt>$(&lt;name&gt;)</tt>, which represents the value of the <tt>&lt;name&gt;</tt>
variable in the current environment. Some examples are shown below.
<p>
<pre>
   CC = gcc
   CFLAGS = -Wall -g
   COMMAND = $(CC) $(CFLAGS) -O2
</pre>
<p>
In this example, the value of the <tt>COMMAND</tt> variable is the string <tt>gcc -Wall -g -O2</tt>.
<p>
Unlike <em>make</em>(1),
variable expansion is <em>eager</em>
and <em>functional</em>
(see also the section
on Scoping). That is, variable values are expanded immediately and new variable definitions do not
affect old ones. For example, suppose we extend the previous example with following variable
definitions.
<p>
<pre>
   X = $(COMMAND)
   COMMAND = $(COMMAND) -O3
   Y = $(COMMAND)
</pre>
<p>
In this example, the value of the <tt>X</tt> variable is the string <tt>gcc -Wall -g -O2</tt> as
before, and the value of the <tt>Y</tt> variable is <tt>gcc -Wall -g -O2 -O3</tt>.
<p>
<h4><a name="section_19">Adding to a variable definition</a></h4>

<p>
Variables definitions may also use the += operator, which adds the new text to an existing
definition. The following two definitions are equivalent.
<p>
<pre>
   # Add options to the CFLAGS variable
   CFLAGS = $(CFLAGS) -Wall -g

   # The following definition is equivalent
   CFLAGS += -Wall -g
</pre>
<p>
<h4><a name="section_20">Arrays</a></h4>

<p>
Arrays can be defined by appending the <tt>[]</tt> sequence to the variable name and defining initial
values for the elements as separate lines. Whitespace is significant on each line. The following
code sequence prints <tt>c d e</tt>.
<p>
<pre>
    X[] =
        a b
        c d e
        f

    println($(nth 2, $(X)))
</pre>
<p>
<h4><a name="section_21">Special characters and quoting</a></h4>

<p>
The following characters are special to <tt>omake</tt>:
<tt>$():,=#\</tt>. To treat
any of these characters as normal text, they should be escaped with the backslash
character <tt>\</tt>.
<p>
<pre>
    DOLLAR = \$
</pre>
<p>
Newlines may also be escaped with a backslash to concatenate several lines.
<p>
<pre>
    FILES = a.c\
            b.c\
            c.c
</pre>
<p>
Note that the backslash is <em>not</em>
an escape for any other character, so the following
works as expected (that is, it preserves the backslashes in the string).
<p>
<pre>
    DOSTARGET = C:\WINDOWS\control.ini
</pre>
<p>
An alternative mechanism for quoting special text is the use <tt>$"..."</tt> escapes. The number of
double-quotations is arbitrary. The outermost quotations are not included in the text.
<p>
<pre>
    A = $""String containing "quoted text" ""
    B = $"""Multi-line
        text.
        The # character is not special"""
</pre>
<p>
<h4><a name="section_22">Function definitions</a></h4>

<p>
Functions are defined using the following syntax.
<p>
<pre>
   &lt;name&gt;(&lt;params&gt;) =
      &lt;indented-body&gt;
</pre>
<p>
The parameters are a comma-separated list of identifiers, and the body must be placed on a separate
set of lines that are indented from the function definition itself. For example, the following text
defines a function that concatenates its arguments, separating them with a colon.
<p>
<pre>
    ColonFun(a, b) =
        return($(a):$(b))
</pre>
<p>
The <tt>return</tt> expression can be used to return a value from the function. A <tt>return</tt>
statement is not required; if it is omitted, the returned value is the value of the last expression
in the body to be evaluated. NOTE: as of version <tt>0.9.6</tt>, <tt>return</tt> is a control
operation, causing the function to immediately return. In the following example, when the argument
<tt>a</tt> is true, the function <tt>f</tt> immediately returns the value 1 without evaluating the print
statement.
<p>
<pre>
    f(a) =
       if $(a)
          return 1
       println(The argument is false)
       return 0
</pre>
<p>
In many cases, you may wish to return a value from a section or code block without returning from
the function. In this case, you would use the <tt>value</tt> operator. In fact, the <tt>value</tt>
operator is not limited to functions, it can be used any place where a value is required. In the
following definition, the variable <tt>X</tt> is defined as 1 or 2, depending on the value of a,
then result is printed, and returned from the function.
<p>
<pre>
    f_value(a) =
       X =
          if $(a)
             value 1
          else
             value 2
       println(The value of X is $(X))
       value $(X)
</pre>
<p>
Functions are called using the GNU-make syntax, <tt>$(&lt;name&gt; &lt;args))</tt>,
where <tt>&lt;args&gt;</tt> is a comma-separated list of values. For example,
in the following program, the variable <tt>X</tt> contains the
value <tt>foo:bar</tt>.
<p>
<pre>
   X = $(ColonFun foo, bar)
</pre>
<p>
If the value of a function is not needed, the function may also be called
using standard function call notation. For example, the following program
prints the string &ldquo;She says: Hello world&rdquo;.
<p>
<pre>
    Printer(name) =
        println($(name) says: Hello world)

    Printer(She)
</pre>
<p>
<h4><a name="section_23">Comments</a></h4>

<p>
Comments begin with the <tt>#</tt> character and continue to the end of the line.
<p>
<h4><a name="section_24">File inclusion</a></h4>

<p>
Files may be included with the <tt>include</tt> form. The included file must use
the same syntax as an <tt>OMakefile</tt>.
<p>
<pre>
    include files.omake
</pre>
<p>
<h4><a name="section_25">Scoping, sections</a></h4>

<p>
Scopes in <tt>omake</tt>
are defined by indentation level. When indentation is
increased, such as in the body of a function, a new scope is introduced.
<p>
The <tt>section</tt> form can also be used to define a new scope. For example, the following code
prints the line <tt>X = 2</tt>, followed by the line <tt>X = 1</tt>.
<p>
<pre>
    X = 1
    section
        X = 2
        println(X = $(X))

    println(X = $(X))
</pre>
<p>
This result may seem surprising--the variable definition within the
<tt>section</tt> is not visible outside the scope of the <tt>section</tt>.
<p>
The <tt>export</tt> form can be used to circumvent this restriction by
exporting variable values from an inner scope. It must be the final
expression in a scope. For example, if we modify the previous example
by adding an <tt>export</tt> expression, the new value for the <tt>X</tt>
variable is retained, and the code prints the line <tt>X = 2</tt> twice.
<p>
<pre>
    X = 1
    section
        X = 2
        println(X = $(X))
        export

    println(X = $(X))
</pre>
<p>
There are also cases where separate scoping is quite important. For example,
each <tt>OMakefile</tt>
is evaluated in its own scope. Since each part of a project
may have its own configuration, it is important that variable definitions in one
<tt>OMakefile</tt>
do not affect the definitions in another.
<p>
To give another example, in some cases it is convenient to specify a
separate set of variables for different build targets. A frequent
idiom in this case is to use the <tt>section</tt> command to define a
separate scope.
<p>
<pre>
   section
      CFLAGS += -g
      %.c: %.y
          $(YACC) $&lt;
      .SUBDIRS: foo

   .SUBDIRS: bar baz
</pre>
<p>
In this example, the <tt>-g</tt> option is added to the <tt>CFLAGS</tt>
variable by the <tt>foo</tt> subdirectory, but not by the <tt>bar</tt> and
<tt>baz</tt> directories. The implicit rules are scoped as well and in this
example, the newly added yacc rule will be inherited by the <tt>foo</tt>
subdirectory, but not by the <tt>bar</tt> and <tt>baz</tt> ones; furthermore
this implicit rule will not be in scope in the current directory.
<p>
<h4><a name="section_26">Conditionals</a></h4>

<p>
Top level conditionals have the following form.
<p>
<pre>
    if &lt;test&gt;
       &lt;true-clause&gt;
    elseif &lt;text&gt;
       &lt;elseif-clause&gt;
    else
       &lt;else-clause&gt;
</pre>
<p>
The <tt>&lt;test&gt;</tt> expression is evaluated, and if it evaluates to a
<em>true</em>
value (see the Logic section), the code for the
<tt>&lt;true-clause&gt;</tt> is evaluated; otherwise the remaining clauses
are evaluated. There may be multiple <tt>elseif</tt> clauses;
both the <tt>elseif</tt> and <tt>else</tt> clauses are optional.
Note that the clauses are indented, so they introduce new
scopes.
<p>
The following example illustrates a typical use of a conditional. The
<tt>OSTYPE</tt> variable is the current machine architecture.
<p>
<pre>
    # Common suffixes for files
    if $(equal $(OSTYPE), Win32)
       EXT_LIB = .lib
       EXT_OBJ = .obj
       EXT_ASM = .asm
       EXE = .exe
       export
    elseif $(mem $(OSTYPE), Unix Cygwin)
       EXT_LIB = .a
       EXT_OBJ = .o
       EXT_ASM = .s
       EXE =
       export
    else
       # Abort on other architectures
       eprintln(OS type $(OSTYPE) is not recognized)
       exit(1)
</pre>
<p>
<h4><a name="section_27">Matching</a></h4>

<p>
Pattern matching is performed with the <tt>switch</tt> and <tt>match</tt> forms.
<p>
<pre>
    switch &lt;string&gt;
    case &lt;pattern1&gt;
        &lt;clause1&gt;
    case &lt;pattern2&gt;
        &lt;clause2&gt;
    ...
    default
       &lt;default-clause&gt;
</pre>
<p>
The number of cases is arbitrary.
The <tt>default</tt> clause is optional; however, if it is used it should
be the last clause in the pattern match.
<p>
For <tt>switch</tt>, the string is compared with the patterns literally.
<p>
<pre>
    switch $(HOST)
    case mymachine
        println(Building on mymachine)
    default
        println(Building on some other machine)
</pre>
<p>
Patterns need not be constant strings. The following function tests
for a literal match against <tt>pattern1</tt>, and a match against
<tt>pattern2</tt> with <tt>##</tt> delimiters.
<p>
<pre>
   Switch2(s, pattern1, pattern2) =
      switch $(s)
      case $(pattern1)
          println(Pattern1)
      case $"##$(pattern2)##"
          println(Pattern2)
      default
          println(Neither pattern matched)
</pre>
<p>
For <tt>match</tt> the patterns are <em>egrep</em>(1)-style
regular expressions.
The numeric variables <tt>$1, $2, ...</tt> can be used to retrieve values
that are matched by <tt>\(...\)</tt> expressions.
<p>
<pre>
    match $(NODENAME)@$(SYSNAME)@$(RELEASE)
    case $"mymachine.*@\(.*\)@\(.*\)"
        println(Compiling on mymachine; sysname $1 and release $2 are ignored)

    case $".*@Linux@.*2\.4\.\(.*\)"
        println(Compiling on a Linux 2.4 system; subrelease is $1)

    default
        eprintln(Machine configuration not implemented)
        exit(1)
</pre>
<p>
<h2><a name="section_28">Objects</a></h2>

<p>
OMake is an object-oriented language. Generally speaking, an object is a value that contains fields
and methods. An object is defined with a <tt>.</tt> suffix for a variable. For example, the
following object might be used to specify a point $(1, 5)$ on the two-dimensional plane.
<p>
<pre>
    Coord. =
        x = 1
        y = 5
        print(message) =
           println($"$(message): the point is ($(x), $(y)")

    # Define X to be 5
    X = $(Coord.x)

    # This prints the string, "Hi: the point is (1, 5)"
    Coord.print(Hi)
</pre>
<p>
The fields <tt>x</tt> and <tt>y</tt> represent the coordinates of the point. The method <tt>print</tt>
prints out the position of the point.
<p>
<h4><a name="section_29">Classes</a></h4>

<p>
We can also define <em>classes</em>.
For example, suppose we wish to define a generic <tt>Point</tt>
class with some methods to create, move, and print a point. A class is really just an object with
a name, defined with the <tt>class</tt> directive.
<p>
<pre>
    Point. =
        class Point

        # Default values for the fields
        x = 0
        y = 0

        # Create a new point from the coordinates
        new(x, y) =
           this.x = $(x)
           this.y = $(y)
           return $(this)

        # Move the point to the right
        move-right() =
           x = $(add $(x), 1)
           return $(this)

        # Print the point
        print() =
           println($"The point is ($(x), $(y)")

    p1 = $(Point.new 1, 5)
    p2 = $(p1.move-right)

    # Prints "The point is (1, 5)"
    p1.print()

    # Prints "The point is (2, 5)"
    p2.print()
</pre>
<p>
Note that the variable <tt>$(this)</tt> is used to refer to the current object. Also, classes and
objects are <em>functional</em>---the
<tt>new</tt> and <tt>move-right</tt> methods return new objects. In
this example, the object <tt>p2</tt> is a different object from <tt>p1</tt>, which retains the original
$(1, 5)$ coordinates.
<p>
<h4><a name="section_30">Inheritance</a></h4>

<p>
Classes and objects support inheritance (including multiple inheritance) with the <tt>extends</tt>
directive. The following definition of <tt>Point3D</tt> defines a point with <tt>x</tt>, <tt>y</tt>, and
<tt>z</tt> fields. The new object inherits all of the methods and fields of the parent classes/objects.
<p>
<pre>
    Z. =
       z = 0

    Point3D. =
       extends $(Point)
       extends $(Z)
       class Point3D

       print() =
          println($"The 3D point is ($(x), $(y), $(z))")

    # The "new" method was not redefined, so this
    # defines a new point (1, 5, 0).
    p = $(Point3D.new 1, 5)
</pre>
<p>
<h2><a name="section_31">Special objects/sections</a></h2>

<p>
Objects provide one way to manage the OMake namespace. There are also four special objects that are
further used to control the namespace.
<p>
<h4><a name="section_32">private.</a></h4>

<p>
The <tt>private.</tt> section is used to define variables that are private to the current file/scope.
The values are not accessible outside the scope. Variables defined in a <tt>private.</tt> object can
be accessed only from within the section where they are defined.
<p>
<pre>
    Obj. =
       private. =
          X = 1

       print() =
          println(The value of X is: $(X))

    # Prints:
    #    The private value of X is: 1
    Obj.print()

    # This is an error--X is private in Obj
    y = $(Obj.X)
</pre>
<p>
In addition, private definitions do not affect the global value of a variable.
<p>
<pre>
   # The public value of x is 1
   x = 1
   f() =
       println(The public value of x is: $(x))

   # This object uses a private value of x
   Obj. =
       private. =
          x = 2

       print() =
          x = 3
          println(The private value of x is: $(x))
          f()

   # Prints:
   #    The private value of x is: 3
   #    The public value of x is: 1
   Obj.print()
</pre>
<p>
Private variables have two additional properties.
<p>
<ol compact>
<li value =1>Private variables are local to the file in which they are defined.
</li>
<li value =2>Private variables are not exported by the <tt>export</tt> directive, unless they are
mentioned explicitly.
<p>
<pre>
       private. =
          FLAG = true

       section
          FLAG = false
          export

       # FLAG is still true
       section
          FLAG = false
          export FLAG

       # FLAG is now false
</pre>
</li>
</ol>
<p>
<h4><a name="section_33">protected.</a></h4>

<p>
The <tt>protected.</tt> object is used to define fields that are local to an object. They can
be accessed as fields, but they are not passed dynamically to other functions. The purpose of a
protected variable is to prevent a variable definition within the object from affecting other parts
of the project.
<p>
<pre>
    X = 1
    f() =
       println(The public value of X is: $(X))

    # Prints:
    #    The public value of X is: 2
    section
       X = 2
       f()

    # X is a protected field in the object
    Obj. =
       protected. =
          X = 3

       print() =
          println(The protected value of X is: $(X))
          f()

    # Prints:
    #    The protected value of X is: 3
    #    The public value of X is: 1
    Obj.print()

    # This is legal, it defines Y as 3
    Y = $(Obj.X)
</pre>
<p>
In general, it is a good idea to define object variables as protected. The resulting code is more
modular because variables in your object will not produce unexpected clashes with variables defined
in other parts of the project.
<p>
<h4><a name="section_34">public.</a></h4>

<p>
The <tt>public.</tt> object is used to specify public dynamically-scoped variables. In the following
example, the <tt>public.</tt> object specifies that the value <tt>X = 4</tt> is to be dynamically
scoped. Public variables <em>are not</em>
defined as fields of an object.
<p>
<pre>
    X = 1
    f() =
       println(The public value of X is: $(X))

    # Prints:
    #    The public value of X is: 2
    section
       X = 2
       f()

    Obj. =
       protected. =
          X = 3

       print() =
          println(The protected value of X is: $(X))
          public. =
             X = 4
          f()

    # Prints:
    #    The protected value of X is: 3
    #    The public value of X is: 4
    Obj.print()
</pre>
<p>
<h4><a name="section_35">static.</a></h4>

<p>
The <tt>static.</tt> object is used to specify values that are persistent across runs of OMake. They
are frequently used for configuring a project. Configuring a project can be expensive, so the
<tt>static.</tt> object ensure that the configuration is performed just once. In the following
(somewhat trivial) example, a <tt>static</tt> section is used to determine if the LaTeX command is
available. The <tt>$(where latex)</tt> function returns the full pathname for <tt>latex</tt>, or
<tt>false</tt> if the command is not found.
<p>
<pre>
   static. =
      LATEX_ENABLED = false
      print(--- Determining if LaTeX is installed )
      if $(where latex)
          LATEX_ENABLED = true
          export

      if $(LATEX_ENABLED)
         println($'(enabled)')
      else
         println($'(disabled)')
</pre>
<p>
As a matter of style, a <tt>static.</tt> section that is used for configuration should print what it
is doing, using <tt>---</tt> as a print prefix.
<p>
<h4><a name="section_36">Short syntax for scoping objects</a></h4>

<p>
The usual dot-notation can be used for private, protected, and public variables (but not
static variables).
<p>
<pre>
    # Public definition of X
    public.X = 1

    # Private definition of X
    private.X = 2

    # Prints:
    #    The public value of X is: 1
    #    The private value of X is: 2
    println(The public value of X is: $(public.X))
    println(The private value of X is: $(private.X))
</pre>
<p>
<h4><a name="section_37">Modular programming</a></h4>

<p>
The scoping objects help provide a form of modularity. When you write a new file or program,
explicit scoping declarations can be used to define an explicit interface for your code, and help
avoid name clashes with other parts of the project. Variable definitions are public by default, but
you can control this with private definitions.
<p>
<pre>
    # These variables are private to this file
    private. =
       FILES = foo1 foo2 foo3
       SUFFIX = .o
       OFILES = $(addsuffix $(SUFFIX), $(FILES))

    # These variables are public
    public. =
       CFLAGS += -g

    # Build the files with the -g option
    $(OFILES):
</pre>
<p>
<h2><a name="section_38">Rules</a></h2>

<p>
Rules are used by OMake to specify how to build files. At its simplest, a rule has the following
form.
<p>
<pre>
    &lt;target&gt;: &lt;dependencies&gt;
        &lt;commands&gt;
</pre>
<p>
The <tt>&lt;target&gt;</tt> is the name of a file to be built. The <tt>&lt;dependencies&gt;</tt> are a list of
files that are needed before the <tt>&lt;target&gt;</tt> can be built. The <tt>&lt;commands&gt;</tt> are a list of
indented lines specifying commands to build the target. For example, the following rule specifies
how to compile a file <tt>hello.c</tt>.
<p>
<pre>
    hello.o: hello.c
        $(CC) $(CFLAGS) -c -o hello.o hello.c
</pre>
<p>
This rule states that the <tt>hello.o</tt>
file depends on the <tt>hello.c</tt>
file. If the
<tt>hello.c</tt>
file has changed, the command <tt>$(CC) $(CFLAGS) -c -o hello.o hello.c</tt> is to
be executed to update the target file <tt>hello.o</tt>.
<p>
A rule can have an arbitrary number of commands. The individual command lines are executed
independently by the command shell. The commands do not have to begin with a tab, but they must be
indented from the dependency line.
<p>
In addition to normal variables, the following special variables may be used in the body of a rule.
<p>
<ul compact>
<li><tt>$*</tt>: the target name, without a suffix.
</li>
<li><tt>$@</tt>: the target name.
</li>
<li><tt>$^</tt>: a list of the sources, in alphabetical order, with
duplicates removed.
</li>
<li><tt>$</tt>+: all the sources, in the original order.
</li>
<li><tt>$&lt;</tt>: the first source.
</li>
</ul>
<p>
For example, the above <tt>hello.c</tt> rule may be simplified as follows.
<p>
<pre>
    hello.o: hello.c
        $(CC) $(CFLAGS) -c -o $@ $&lt;
</pre>
<p>
Unlike normal values, the variables in a rule body are expanded lazily, and binding is dynamic. The
following function definition illustrates some of the issues.
<p>
<pre>
    CLibrary(name, files) =
        OFILES = $(addsuffix .o, $(files))

        $(name).a: $(OFILES)
            $(AR) cq $@ $(OFILES)
</pre>
<p>
This function defines a rule to build a program called <tt>$(name)</tt> from a list of <tt>.o</tt>
files. The files in the argument are specified without a suffix, so the first line of the function
definition defines a variable <tt>OFILES</tt> that adds the <tt>.o</tt> suffix to each of the file
names. The next step defines a rule to build a target library <tt>$(name).a</tt> from the
<tt>$(OFILES)</tt> files. The expression <tt>$(AR)</tt> is evaluated when the function is called, and
the value of the variable <tt>AR</tt> is taken from the caller's scope (see also the section on
Scoping).
<p>
<h4><a name="section_39">Implicit rules</a></h4>

<p>
Rules may also be implicit. That is, the files may be specified by wildcard patterns.
The wildcard character is <tt>%</tt>. For example, the following rule specifies a default
rule for building <tt>.o</tt> files.
<p>
<pre>
    %.o: %.c
        $(CC) $(CFLAGS) -c -o $@ $*.c
</pre>
<p>
This rule is a template for building an arbitrary <tt>.o</tt> file from
a <tt>.c</tt> file.
<p>
By default, implicit rules are only used for the targets in the current
directory. However subdirectories included via the <tt>.SUBDIRS</tt> rules
inherit all the implicit rules that are in scope (see also the section on
Scoping).
<p>
<h4><a name="section_40">Bounded implicit rules</a></h4>

<p>
Implicit rules may specify the set of files they apply to. The following syntax is used.
<p>
<pre>
    &lt;targets&gt;: &lt;pattern&gt;: &lt;dependencies&gt;
        &lt;commands&gt;
</pre>
<p>
For example, the following rule applies only to the files <tt>a.o</tt> and <tt>b.o</tt>.
<p>
<pre>
   a.o b.o: %.o: %.c
        $(CC) $(CFLAGS) -DSPECIAL -c $*.c
</pre>
<p>
<h4><a name="section_41">section</a></h4>

<p>
Frequently, the commands in a rule body are expressions to be evaluated by the shell. <tt>omake</tt>
also allows expressions to be evaluated by <tt>omake</tt>
itself.
<p>
The syntax of these &ldquo;computed rules&rdquo; uses the <tt>section</tt> expression. The following rule uses
the <tt>omake</tt>
IO functions to produce the target <tt>hello.c</tt>.
<p>
<pre>
    hello.c:
        section
            FP = fopen(hello.c, w)
            fprintln($(FP), $""#include &lt;stdio.h&gt; int main() { printf("Hello world\n"); }"")
            close($(FP))
</pre>
<p>
This example uses the quotation <tt>$""...""</tt> to quote the text being printed. These quotes are
not included in the output file. The <tt>fopen</tt>, <tt>fprintln</tt>, and <tt>close</tt> functions
perform file IO as discussed in the IO section.
<p>
In addition, commands that are function calls, or special expressions, are interpreted correctly.
Since the <tt>fprintln</tt> function can take a file directly, the above rule can be abbreviated as
follows.
<p>
<pre>
    hello.c:
       fprintln($@, $""#include &lt;stdio.h&gt; int main() { printf("Hello world\n"); }"")
</pre>
<p>
<h4><a name="section_42">section rule</a></h4>

<p>
Rules can also be computed using the <tt>section rule</tt> form, where a rule body is expected instead
of an expression. In the following rule, the file <tt>a.c</tt> is copied onto the <tt>hello.c</tt> file
if it exists, otherwise <tt>hello.c</tt> is created from the file <tt>default.c</tt>.
<p>
<pre>
    hello.c:
        section rule
           if $(target-exists a.c)
              hello.c: a.c
                 cat a.c &gt; hello.c
           else
              hello.c: default.c
                 cp default.c hello.c
</pre>
<p>
<h2><a name="section_43">Special dependencies</a></h2>

<p>
<h4><a name="section_44">:exists:</a></h4>

<p>
In some cases, the contents of a dependency do not matter, only whether the file exists or not. In
this case, the <tt>:exists:</tt> qualifier can be used for the dependency.
<p>
<pre>
    foo.c: a.c :exists: .flag
       if $(test -e .flag)
           $(CP) a.c $@
</pre>
<p>
<h4><a name="section_45">:effects:</a></h4>

<p>
Some commands produce files by side-effect. For example, the
<em>latex</em>(1)
command produces a <tt>.aux</tt> file as a side-effect of
producing a <tt>.dvi</tt> file. In this case, the <tt>:effects:</tt>
qualifier can be used to list the side-effect explicitly.
<tt>omake</tt>
is careful to avoid simultaneously running programs that
have overlapping side-effects.
<p>
<pre>
    paper.dvi: paper.tex :effects: paper.aux
        latex paper
</pre>
<p>
<h4><a name="section_46">:value:</a></h4>

The <tt>:value:</tt> dependency is used to specify that the rule execution depends on the value of an
expression. For example, the following rule
<p>
<pre>
    a: b c :value: $(X)
        ...
</pre>
<p>
specifies that &ldquo;a&rdquo; should be recompiled if the value of <tt>$(X)</tt> changes
(X does not have to be a filename). This is intended to allow greater
control over dependencies.
<p>
In addition, it can be used instead of other kinds of dependencies. For example,
the following rule:
<p>
<pre>
    a: b :exists: c
        commands
</pre>
<p>
is the same as
<p>
<pre>
    a: b :value: $(target-exists c)
        commands
</pre>
<p>
Notes:
<ul compact>
<li>The values are arbitrary (they are not limited to variables)
</li>
<li>The values are evaluated at rule expansion time, so expressions
containing variables like <tt>$@</tt>, <tt>$^</tt>, etc are legal.
</li>
</ul>
<p>
<h2><a name="section_47">.SCANNER rules</a></h2>

<p>
Scanner rules define a way to specify automatic dependency scanning. A <tt>.SCANNER</tt> rule has the
following form.
<p>
<pre>
    .SCANNER: target: dependencies
        commands
</pre>
<p>
The rule is used to compute additional dependencies that might be defined in the source files for
the specified target. The scanner produces dependencies for the specified target (which may be a
pattern) by running the commands, which <em>must</em>
produce output that is compatible with omake.
For example, on GNU systems the <tt>gcc -MM foo.c</tt> produces dependencies for the file <tt>foo.c</tt>
(based on <tt>#include</tt> information).
<p>
We can use this to specify a scanner for C files that adds the scanned dependencies for the
<tt>.o</tt> file. The following scanner specifies that dependencies for a file, say <tt>foo.o</tt> can
be computed by running <tt>gcc -MM foo.c</tt>. Furthermore, <tt>foo.c</tt> is a dependency, so the
scanner should be recomputed whenever the <tt>foo.c</tt> file changes.
<p>
<pre>
    .SCANNER: %.o: %.c
        gcc -MM $&lt;
</pre>
<p>
Let's suppose that the command <tt>gcc -MM foo.c</tt> prints the following line.
<p>
<pre>
    foo.o: foo.h /usr/include/stdio.h
</pre>
<p>
The result is that the files <tt>foo.h</tt> and <tt>/usr/include/stdio.h</tt> are considered to be
dependencies of <tt>foo.o</tt>---that is, <tt>foo.o</tt> should be rebuilt if either of these files
changes.
<p>
This works, to an extent. One nice feature is that the scanner will be re-run whenever the
<tt>foo.c</tt> file changes. However, one problem is that dependencies in C are <em>recursive</em>.
That is, if the file <tt>foo.h</tt> is modified, it might include other files, establishing further
dependencies. What we need is to re-run the scanner if <tt>foo.h</tt> changes too.
<p>
We can do this with a <em>value</em>
dependency. The variable <tt>$&amp;</tt> is defined as the dependency
results from any previous scan. We can add these as dependencies using the <tt>digest</tt> function,
which computes an MD5 digest of the files.
<p>
<pre>
    .SCANNER: %.o: %.c :value: $(digest $&amp;)
        gcc -MM $&lt;
</pre>
<p>
Now, when the file <tt>foo.h</tt> changes, its digest will also change, and the scanner will be re-run
because of the value dependency (since <tt>$&amp;</tt> will include <tt>foo.h</tt>).
<p>
This still is not quite right. The problem is that the C compiler uses a <em>search-path</em>
for
include files. There may be several versions of the file <tt>foo.h</tt>, and the one that is chosen
depends on the include path. What we need is to base the dependencies on the search path.
<p>
The <tt>$(digest-in-path-optional ...)</tt> function computes the digest based on a search path,
giving us a solution that works.
<p>
<pre>
    .SCANNER: %.o: %.c :value: $(digest-in-path-optional $(INCLUDES), $&amp;)
       gcc -MM $(addprefix -I, $(INCLUDES)) $&lt;
</pre>
<p>
<h4><a name="section_48">Named scanners, and the :scanner: target</a></h4>

<p>
Sometimes it may be useful to specify explicitly which scanner should be used in a rule. For
example, we might compile <tt>.c</tt> files with different options, or (heaven help us) we may be
using both <tt>gcc</tt> and the Microsoft Visual C++ compiler <tt>cl</tt>. In general, the target of a
<tt>.SCANNER</tt> is not tied to a particular target, and we may name it as we like.
<p>
<pre>
    .SCANNER: scan-gcc-%.c: %.c :value: $(digest-in-path-optional $(INCLUDES), $&amp;)
        gcc -MM $(addprefix -I, $(INCLUDES)) $&lt;

    .SCANNER: scan-cl-%.c: %.c :value: $(digest-in-path-optional $(INCLUDES), $&amp;)
        cl --scan-dependencies-or-something $(addprefix /I, $(INCLUDES)) $&lt;
</pre>
<p>
The next step is to define explicit scanner dependencies. The <tt>:scanner:</tt> dependency is used
for this. In this case, the scanner dependencies are specified explicitly.
<p>
<pre>
    $(GCC_FILES): %.o: %.c :scanner: scan-gcc-%c
        gcc ...

    $(CL_FILES): %.obj: %.c :scanner: scan-cl-%c
        cl ...
</pre>
<p>
Explicit <tt>:scanner:</tt> scanner specification may also be used to state that a single
<tt>.SCANNER</tt> rule should be used to generate dependencies for more than one target. For example,
<p>
<pre>
    .SCANNER: scan-all-c: $(GCC_FILES) :value: $(digest-in-path-optional $(INCLUDES), $&amp;)
        gcc -MM $(addprefix -I, $(INCLUDES)) $(GCC_FILES)

    $(GCC_FILES): %.o: %.c :scanner: scan-all-c
        ...
</pre>
<p>
The above has the advantage of only running <tt>gcc</tt>
once and a disadvantage that when a single
source file changes, all the files will end up being re-scanned.
<p>
<h4><a name="section_49">Notes</a></h4>

<p>
In most cases, you won't need to define scanners of your own. The standard installation includes
default scanners (both explicitly and implicitly named ones) for C, OCaml, and LaTeX files.
<p>
The <tt>SCANNER_MODE</tt> variable controls the usage of implicit scanner dependencies. See
<a href="omake-root.html#SCANNERMODE">the documentation</a>
for the <tt>SCANNER_MODE</tt> variable in
<em>omake-root</em>(1)
for detail.
<p>
The explicit <tt>:scanner:</tt> dependencies reduce the chances of scanner mis-specifications. In
large complicated projects it might be a good idea to set <tt>SCANNER_MODE</tt> to <tt>error</tt> and
use only the named <tt>.SCANNER</tt> rules and explicit <tt>:scanner:</tt> specifications.
<p>
<h2><a name="section_50">Other special targets</a></h2>

<p>
There are several other special targets that define special actions to be take by <tt>omake</tt>.
<p>
<h4><a name="section_51">.DEFAULT</a></h4>

<p>
The <tt>.DEFAULT</tt> target specifies a target to be built by default
if <tt>omake</tt>
is run without explicit targets. The following rule
instructs <tt>omake</tt>
to build the program <tt>hello</tt> by default
<p>
<pre>
   .DEFAULT: hello
</pre>
<p>
<h4><a name="section_52">.SUBDIRS</a></h4>

<p>
The <tt>.SUBDIRS</tt> target is used to specify a set of subdirectories
that are part of the project. Each subdirectory should have its own
<tt>OMakefile</tt>,
which is evaluated in the context of the current
environment.
<p>
<pre>
   .SUBDIRS: src doc tests
</pre>
<p>
This rule specifies that the <tt>OMakefile</tt>s in each of the <tt>src</tt>, <tt>doc</tt>, and
<tt>tests</tt> directories should be read.
<p>
In some cases, especially when the <tt>OMakefile</tt>s are very similar in a large number of
subdirectories, it is inconvenient to have a separate <tt>OMakefile</tt> for each directory. If the
<tt>.SUBDIRS</tt> rule has a body, the body is used instead of the <tt>OMakefile</tt>.
<p>
<pre>
   .SUBDIRS: src1 src2 src3
      println(Subdirectory $(CWD))
      .DEFAULT: lib.a
</pre>
<p>
In this case, the <tt>src1</tt>, <tt>src2</tt>, and <tt>src3</tt> files do not need <tt>OMakefile</tt>s.
Furthermore, if one exists, it is ignored. The following includes the file if it exists.
<p>
<pre>
   .SUBDIRS: src1 src2 src3
       if $(file-exists OMakefile)
          include OMakefile
       .DEFAULT: lib.a
</pre>
<p>
<h4><a name="section_53">.INCLUDE</a></h4>

<p>
The <tt>.INCLUDE</tt> target is like the <tt>include</tt> directive, but it specifies a rule to build
the file if it does not exist.
<p>
<pre>
   .INCLUDE: config
       echo "CONFIG_READ = true" &gt; config

    echo CONFIG_READ is $(CONFIG_READ)
</pre>
<p>
<h4><a name="section_54">.PHONY</a></h4>

<p>
A &ldquo;phony&rdquo; target is a target that is not a real file, but exists to collect a set of dependencies.
Phony targets are specified with the <tt>.PHONY</tt> rule. In the following example, the
<tt>install</tt> target does not correspond to a file, but it corresponds to some commands that should
be run whenever the <tt>install</tt> target is built (for example, by running <tt>omake install</tt>).
<p>
<pre>
   .PHONY: install

   install: myprogram.exe
      cp myprogram.exe /usr/bin
</pre>
<p>
<h2><a name="section_55">Rule scoping</a></h2>

<p>
As we have mentioned before, <tt>omake</tt>
is a <em>scoped</em>
language. This provides great
flexibility---different parts of the project can define different configurations without interfering
with one another (for example, one part of the project might be compiled with <tt>CFLAGS=-O3</tt> and
another with <tt>CFLAGS=-g</tt>).
<p>
But how is the scope for a target file selected? Suppose we are building a file <tt>dir/foo.o</tt>.
<tt>omake</tt>
uses the following rules to determine the scope.
<p>
<ul compact>
<li>First, if there is an <em>explicit</em> rule for building
<tt>dir/foo.o</tt> (a rule with no
wildcards), the context for that rule determines the scope for building the target.
</li>
<li>Otherwise, the directory <tt>dir/</tt> must be part of the project. This normally means that a
configuration file <tt>dir/OMakefile</tt> exists (although, see the <tt>.SUBDIRS</tt> section for
another way to specify the <tt>OMakefile</tt>). In this case, the scope of the target is the scope at
the end of the <tt>dir/OMakefile</tt>.
</li>
</ul>
<p>
To illustrate rule scoping, let's go back to the example of a &ldquo;Hello world&rdquo; program with two
files. Here is an example <tt>OMakefile</tt> (the two definitions of <tt>CFLAGS</tt> are for
illustration).
<p>
<pre>
    # The executable is compiled with debugging
    CFLAGS = -g
    hello: hello_code.o hello_lib.o
       $(CC) $(CFLAGS) -o $@ $+

    # Redefine CFLAGS
    CFLAGS += -O3
</pre>
<p>
In this project, the target <tt>hello</tt> is <em>explicit</em>.
The scope of the <tt>hello</tt> target
is the line beginning with <tt>hello:</tt>, where the value of <tt>CFLAGS</tt> is <tt>-g</tt>. The other
two targets, <tt>hello_code.o</tt> and <tt>hello_lib.o</tt> do not appear as explicit targets, so their
scope is at the end of the <tt>OMakefile</tt>, where the <tt>CFLAGS</tt> variable is defined to be
<tt>-g -O3</tt>. That is, <tt>hello</tt> will be linked with <tt>CFLAGS=-g</tt> and the <tt>.o</tt> files
will be compiled with <tt>CFLAGS=-g -O3</tt>.
<p>
We can change this behavior for any of the targets by specifying them as explicit targets. For
example, suppose we wish to compile <tt>hello_lib.o</tt> with a preprocessor variable <tt>LIBRARY</tt>.
<p>
<pre>
    # The executable is compiled with debugging
    CFLAGS = -g
    hello: hello_code.o hello_lib.o
       $(CC) $(CFLAGS) -o $@ $+

    # Compile hello_lib.o with CFLAGS = -g -DLIBRARY
    section
        CFLAGS += -DLIBRARY
        hello_lib.o:

    # Redefine CFLAGS
    CFLAGS += -O3
</pre>
<p>
In this case, <tt>hello_lib.o</tt> is also mentioned as an explicit target, in a scope where
<tt>CFLAGS=-g -DLIBRARY</tt>. Since no rule body is specified, it is compiled using the usual
implicit rule for building <tt>.o</tt> files (in a context where <tt>CFLAGS=-g -DLIBRARY</tt>).
<p>
<h4><a name="section_56">Scoping of implicit rules</a></h4>

<p>
Implicit rules (rules containing wildcard patterns) are <em>not</em>
global, they follow the normal
scoping convention. This allows different parts of a project to have different sets of implicit
rules. If we like, we can modify the example above to provide a new implicit rule for building
<tt>hello_lib.o</tt>.
<p>
<pre>
    # The executable is compiled with debugging
    CFLAGS = -g
    hello: hello_code.o hello_lib.o
       $(CC) $(CFLAGS) -o $@ $+

    # Compile hello_lib.o with CFLAGS = -g -DLIBRARY
    section
        %.o: %.c
            $(CC) $(CFLAGS) -DLIBRARY -c $&lt;
        hello_lib.o:

    # Redefine CFLAGS
    CFLAGS += -O3
</pre>
<p>
In this case, the target <tt>hello_lib.o</tt> is built in a scope with a new implicit rule for
building <tt>%.o</tt> files. The implicit rule adds the <tt>-DLIBRARY</tt> option. This implicit rule
is defined only for the target <tt>hello_lib.o</tt>; the target <tt>hello_code.o</tt> is built as
normal.
<p>
<h4><a name="section_57">Scoping of .SCANNER rules</a></h4>

<p>
Scanner rules are scoped the same way as normal rules. If the <tt>.SCANNER</tt> rule is explicit
(containing no wildcard patterns), then the scope of the scan target is the same as the the rule.
If the <tt>.SCANNER</tt> rule is implicit, then the environment is taken from the <tt>:scanner:</tt>
dependency.
<p>
<pre>
    # The executable is compiled with debugging
    CFLAGS = -g
    hello: hello_code.o hello_lib.o
       $(CC) $(CFLAGS) -o $@ $+

    # scanner for .c files
    .SCANNER: scan-c-%.c: %.c
       $(CC) $(CFLAGS) -MM $&lt;

    # Compile hello_lib.o with CFLAGS = -g -DLIBRARY
    section
        CFLAGS += -DLIBRARY
        hello_lib.o: hello_lib.c :scanner: scan-c-hello_lib.c
           $(CC) $(CFLAGS) -c $&lt;

    # Compile hello_code.c with CFLAGS = -g -O3
    section
        CFLAGS += -O3
        hello_code.o: hello_code.c :scanner: scan-c-hello_code.c
           $(CC) $(CFLAGS) -c $&lt;
</pre>
<p>
Again, this is for illustration---it is unlikely you would need to write a complicated configuration
like this! In this case, the <tt>.SCANNER</tt> rule specifies that the C-compiler should be called
with the <tt>-MM</tt> flag to compute dependencies. For the target <tt>hello_lib.o</tt>, the scanner
is called with <tt>CFLAGS=-g -DLIBRARY</tt>, and for <tt>hello_code.o</tt> it is called with
<tt>CFLAGS=-g -O3</tt>.
<p>
<h4><a name="section_58">Scoping for .PHONY targets</a></h4>

<p>
Phony targets (targets that do not correspond to files) are defined with a <tt>.PHONY:</tt> rule.
Phony targets are scoped as usual. The following illustrates a common mistake, where the
<tt>.PHONY</tt> target is declared <em>after</em>
it is used.
<p>
<pre>
    # This example is broken!
    all: hello

    hello: hello_code.o hello_lib.o
        $(CC) $(CFLAGS) -o $@ $+

    .PHONY: all
</pre>
<p>
This doesn't work as expected because the <tt>.PHONY</tt> declaration occurs too late. The proper way
to write this example is to place the <tt>.PHONY</tt> declaration first.
<p>
<pre>
    # Phony targets must be declared before being used
    .PHONY: all

    all: hello

    hello: hello_code.o hello_lib.o
        $(CC) $(CFLAGS) -o $@ $+
</pre>
<p>
Phony targets are passed to subdirectories. As a practical matter, it is wise to declare all
<tt>.PHONY</tt> targets in your root <tt>OMakefile</tt>, before any <tt>.SUBDIRS</tt>. This will ensure
that 1) they are considered as phony targets in each of the sbdirectories, and 2) you can build them
from the project root.
<p>
<pre>
    .PHONY: all install clean

    .SUBDIRS: src lib clib
</pre>
<p>
<h2><a name="section_59">The OSH shell</a></h2>

<p>
OMake also includes a standalone command-line interpreter <tt>osh</tt>
that can be used as an
interactive shell. The shell uses the same syntax, and provides the same features on all platforms
<tt>omake</tt>
supports, including Win32.
<p>
<h4><a name="section_60">Startup</a></h4>

<p>
On startup, <tt>osh</tt>
reads the file <tt>~/.oshrc</tt> if it exists. The syntax of this file is the
same as an <tt>OMakefile</tt>.
The following additional variables are significant.
<p>
<dl compact>
<dt>prompt</dt>
<dd> The <tt>prompt</tt> variable specifies the command-line prompt.
It can be a simple string.
<p>
<pre>
    prompt = osh&gt;
</pre>
<p>
Or you may choose to define it as a function of no arguments.
<p>
<pre>
    prompt() =
        return $"&lt;$(USER):$(HOST) $(homename $(CWD))&gt;"
</pre>
<p>
An example of the latter prompt is as follows.
<p>
<pre>
    &lt;jyh:kenai.yapper.org ~&gt;cd links/omake
    &lt;jyh:kenai.yapper.org ~/links/omake&gt;
</pre>
<p>
</dd>
<dt>ignoreeof</dt>
<dd>
If the <tt>ignoreeof</tt> is <tt>true</tt>, then <tt>osh</tt> will not exit on
a terminal end-of-file (usually <tt>^D</tt> on Unix systems).
</dd>
</dl>
<p>
<h4><a name="section_61">Aliases</a></h4>

<p>
Command aliases are defined by adding functions to the <tt>Shell.</tt> object. The following alias
adds the <tt>-AF</tt> option to the <tt>ls</tt> command.
<p>
<pre>
    Shell. +=
       ls(argv) =
          "ls" -AF $(argv)
</pre>
<p>
Quoted commands do not undergo alias expansion. The quotation <tt>"ls"</tt> prevents the alias from
being recursive.
<p>
<h4><a name="section_62">Interactive syntax</a></h4>

<p>
The interactive syntax in <tt>osh</tt> is the same as the syntax of an <tt>OMakefile</tt>, with one
exception in regard to indentation. The line before an indented block must have a colon at the end
of the line. A block is terminated with a <tt>.</tt> on a line by itself, or <tt>^D</tt>. In the
following example, the first line <tt>if true</tt> has no body, because there is no colon.
<p>
<pre>
   # The following if has no body
   osh&gt;if true
   # The following if has a body
   osh&gt;if true:
   if&gt;       if true:
   if&gt;          println(Hello world)
   if&gt;          .
   Hello world
</pre>
<p>
Note that <tt>osh</tt> makes some effort to modify the prompt while in an indented body, and it
auto-indents the text.
<p>
The colon signifier is also allowed in files, although it is not required.
<p>
<h4><a name="section_63">See also</a></h4>

<p>
See Section <a href="omake-shell.html">omake-shell</a>
for more information on the shell language,
and Section <a href="omake-system.html">omake-system</a>
for more information on job control.
<p>
<h2><a name="section_64">Builtin variables</a></h2>

<p>
<h4><a name="section_65">OSTYPE</a></h4>

Set to the machine architecture <tt>omake</tt>
is running on. Possible values are
<tt>Unix</tt> (for all Unix versions, including Linux and Mac OS X), <tt>Win32</tt>
(for MS-Windows, OMake compiled with MSVC++ or Mingw), and <tt>Cygwin</tt> (for
MS-Windows, OMake compiled with Cygwin).
<h4><a name="section_66">SYSNAME</a></h4>

The name of the operating system for the current machine.
<h4><a name="section_67">NODENAME</a></h4>

The hostname of the current machine.
<h4><a name="section_68">OS_VERSION</a></h4>

The operating system release.
<h4><a name="section_69">MACHINE</a></h4>

The machine architecture, e.g.  <tt>i386</tt>, <tt>sparc</tt>, etc.
<h4><a name="section_70">HOST</a></h4>

Same as <tt>NODENAME</tt>.
<h4><a name="section_71">OMAKE_VERSION</a></h4>

Version of OMake.
<h4><a name="section_72">USER</a></h4>

The login name of the user executing the process.
<h4><a name="section_73">HOME</a></h4>

The home directory of the user executing the process.
<h4><a name="section_74">PID</a></h4>

The OMake process id.
<h2><a name="section_75">Boolean functions and control flow</a></h2>

<p>
<h4><a name="section_76">not</a></h4>

<p>
<pre>
   $(not e) : String
      e : String
</pre>
<p>
Boolean values in omake are represented by case-insensitive strings. The
<em>false</em>
value can be represented by the strings <tt>false</tt>, <tt>no</tt>,
<tt>nil</tt>, <tt>undefined</tt> or <tt>0</tt>, and everything else is true. The
<tt>not</tt> function negates a Boolean value.
<p>
For example, <tt>$(not false)</tt> expands to the string <tt>true</tt>, and <tt>$(not hello world)</tt> expands to <tt>false</tt>.
<h4><a name="section_77">equal</a></h4>

<p>
<pre>
   $(equal e1, e2) : String
      e1 : String
      e2 : String
</pre>
<p>
The <tt>equal</tt> function tests for equality of two values.
<p>
For example <tt>$(equal a, b)</tt> expands to <tt>false</tt>, and <tt>$(equal hello world, hello world)</tt> expands to <tt>true</tt>.
<h4><a name="section_78">and</a></h4>

<p>
<pre>
    $(and e1, ..., en) : String
       e1, ..., en: Sequence
</pre>
<p>
The <tt>and</tt> function evaluates to the conjunction of its arguments.
<p>
For example, in the following code, <tt>X</tt> is true, and <tt>Y</tt> is false.
<p>
<pre>
    A = a
    B = b
    X = $(and $(equal $(A), a) true $(equal $(B), b))
    Y = $(and $(equal $(A), a) true $(equal $(A), $(B)))
</pre>
<h4><a name="section_79">or</a></h4>

<p>
<pre>
   $(or e1, ..., en) : String
      e1, ..., en: String Sequence
</pre>
<p>
The <tt>or</tt> function evaluates to the disjunction of its arguments.
<p>
For example, in the following code, <tt>X</tt> is true, and <tt>Y</tt> is false.
<p>
<pre>
    A = a
    B = b
    X = $(or $(equal $(A), a) false $(equal $(A), $(B)))
    Y = $(or $(equal $(A), $(B)) $(equal $(A), b))
</pre>
<h4><a name="section_80">if</a></h4>

<p>
<pre>
    $(if e1, e2[, e3]) : value
       e1 : String
       e2, e3 : value
</pre>
<p>
The <tt>if</tt> function represents a conditional based on a Boolean value.
For example <tt>$(if $(equal a, b), c, d)</tt> evaluates to <tt>d</tt>.
<p>
Conditionals may also be declared with an alternate syntax.
<p>
<pre>
   if e1
      body1
   elseif e2
      body2
   ...
   else
      bodyn
</pre>
<p>
If the expression <tt>e1</tt> is not false, then the expressions in <tt>body1</tt>
are evaluated and the result is returned as the value of the conditional. Otherwise,
if <tt>e1</tt> evaluates to false, the evaluation continues with the <tt>e2</tt>
expression. If none of the conditional expressions is true, then the expressions
in <tt>bodyn</tt> are evaluated and the result is returned as the value
of the conditional.
<p>
There can be any number of <tt>elseif</tt> clauses; the <tt>else</tt> clause is
optional.
<p>
Note that each branch of the conditional defines its own scope, so variables
defined in the branches are normally not visible outside the conditional.
The <tt>export</tt> command may be used to export the variables defined in
a scope. For example, the following expression represents a common idiom
for defining the C compiler configuration.
<p>
<pre>
   if $(equal $(OSTYPE), Win32)
      CC = cl
      CFLAGS += /DWIN32
      export
   else
      CC = gcc
      CFLAGS += -g -O2
      export
</pre>
<h4><a name="section_81">switch, match</a></h4>

<p>
The <tt>switch</tt> and <tt>match</tt> functions perform pattern matching.
<p>
<tt>$(switch &lt;arg&gt;, &lt;pattern_1&gt;, &lt;value_1&gt;, ..., &lt;pattern_n&gt;, &lt;value_n&gt;)</tt>
<tt>$(match &lt;arg&gt;, &lt;pattern_1&gt;, &lt;value_1&gt;, ..., &lt;pattern_n&gt;, &lt;value_n&gt;)</tt>
<p>
The number of <tt>&lt;pattern&gt;/&lt;value&gt;</tt> pairs is arbitrary. They strictly
alternate; the total number of arguments to <tt>&lt;match&gt;</tt> must be odd.
<p>
The <tt>&lt;arg&gt;</tt> is evaluated to a string, and compared with <tt>&lt;pattern_1&gt;</tt>.
If it matches, the result of the expression is <tt>&lt;value_1&gt;</tt>. Otherwise
evaluation continues with the remaining patterns until a match is found.
If no pattern matches, the value is the empty string.
<p>
The <tt>switch</tt> function uses string comparison to compare
the argument with the patterns. For example, the following
expression defines the <tt>FILE</tt> variable to be either
<tt>foo</tt>, <tt>bar</tt>, or the empty string, depending
on the value of the <tt>OSTYPE</tt> variable.
<p>
<pre>
    FILE = $(switch $(OSTYPE), Win32, foo, Unix, bar)
</pre>
<p>
The <tt>match</tt> function uses regular expression patterns (see the
<tt>grep</tt> function). If a match is found, the variables
<tt>$1, $2, ...</tt> are bound to the substrings matched between
<tt>\(</tt> and <tt>\)</tt> delimiters.
The <tt>$0</tt> variable contains the entire match, and <tt>$*</tt>
is an array of the matched substrings.
to the matched substrings.
<p>
<pre>
    FILE = $(match foo_xyz/bar.a, foo_\\\(.*\\\)/\\\(.*\\\)\.a, foo_$2/$1.o)
</pre>
<p>
The <tt>switch</tt> and <tt>match</tt> functions also have an alternate (more usable)
form.
<p>
<pre>
   match e
   case pattern1
      body1
   case pattern2
      body2
   ...
   default
      bodyd
</pre>
<p>
If the value of expression <tt>e</tt> matches <tt>pattern_i</tt> and no previous pattern,
then <tt>body_i</tt> is evaluated and returned as the result of the <tt>match</tt>.
The <tt>switch</tt> function uses string comparison; the <tt>match</tt> function
uses regular expression matching.
<p>
<pre>
   match $(FILE)
   case $".*\(\.[^\/.]*\)"
      println(The string $(FILE) has suffix $1)
   default
      println(The string $(FILE) has no suffix)
</pre>
<h4><a name="section_82">try</a></h4>

<p>
<pre>
   try
      try-body
   catch class1(v1)
      catch-body
   when expr
      when-body
   ...
   finally
      finally-body
</pre>
<p>
The <tt>try</tt> form is used for exception handling.
First, the expressions in the <tt>try-body</tt> are evaluated.
<p>
If evaluation results in a value <tt>v</tt> without raising an
exception, then the expressions in the <tt>finally-body</tt>
are evaluated and the value <tt>v</tt> is returned as the result.
<p>
If evaluation of the <tt>try-body</tt> results in a exception object <tt>obj</tt>,
the <tt>catch</tt> clauses are examined in order. When examining <tt>catch</tt>
clause <tt>catch class(v)</tt>, if the exception object <tt>obj</tt>
is an instance of the class name <tt>class</tt>, the variable <tt>v</tt> is bound
to the exception object, and the expressions in the <tt>catch-body</tt>
are evaluated.
<p>
If a <tt>when</tt> clause is encountered while a <tt>catch</tt> body is being evaluated,
the predicate <tt>expr</tt> is evaluated. If the result is true, evaluation continues
with the expressions in the <tt>when-body</tt>. Otherwise, the next <tt>catch</tt>
clause is considered for evaluation.
<p>
If evaluation of a <tt>catch-body</tt> or <tt>when-body</tt> completes successfully,
returning a value <tt>v</tt>, without encountering another <tt>when</tt> clause,
then the expressions in the <tt>finally-body</tt>
are evaluated and the value <tt>v</tt> is returned as the result.
<p>
There can be any number of <tt>catch</tt> clauses; the <tt>finally</tt> clause
is optional.
<h4><a name="section_83">raise</a></h4>

<p>
<pre>
   raise exn
      exn : Exception
</pre>
<p>
The <tt>raise</tt> function raises an exception.
The <tt>exn</tt> object can be any object. However,
the normal convention is to raise an <tt>Exception</tt>
object.
<h4><a name="section_84">exit</a></h4>

<p>
<pre>
   exit(code)
      code : Int
</pre>
<p>
The <tt>exit</tt> function terminates <tt>omake</tt>
abnormally.
<p>
<tt>$(exit &lt;code&gt;)</tt>
<p>
The <tt>exit</tt> function takes one integer argument, which is exit code.
Non-zero values indicate abnormal termination.
<h4><a name="section_85">defined</a></h4>

<p>
<pre>
   $(defined sequence) : String
      sequence : Sequence
</pre>
<p>
The <tt>defined</tt> function test whether all the variables in the sequence are
currently defined. For example, the following code defines the <tt>X</tt> variable
if it is not already defined.
<p>
<pre>
    if $(not $(defined X))
       X = a b c
       export
</pre>
<h4><a name="section_86">defined-env</a></h4>

<p>
<pre>
   $(defined-env sequence) : String
      sequence : String
</pre>
<p>
The <tt>defined-env</tt> function tests whether a variable is defined
as part of the process environment.
<p>
For example, the following code adds the <tt>-g</tt> compile
option if the environment variable <tt>DEBUG</tt> is defined.
<p>
<pre>
if $(defined-env DEBUG)
    CFLAGS += -g
    export
</pre>
<h4><a name="section_87">getenv</a></h4>

<p>
<pre>
   $(getenv name) : String
   $(getenv name, default) : String
</pre>
<p>
The <tt>getenv</tt> function gets the value of a variable from
the process environment. The function takes one or two arguments.
<p>
In the single argument form, an exception is raised if the variable
variable is not defined in the environment. In the two-argument form,
the second argument is returned as the result if the value is not
defined.
<p>
For example, the following code defines the variable <tt>X</tt>
to be a space-separated list of elements of the <tt>PATH</tt>
environment variable if it is defined, and to <tt>/bin /usr/bin</tt>
otherwise.
<p>
<pre>
    X = $(split $(PATHSEP), $(getenv PATH, /bin:/usr/bin))
</pre>
<p>
You may also use the alternate form.
<pre>
     getenv(NAME)
         default
</pre>
<h4><a name="section_88">setenv</a></h4>

<p>
<pre>
   setenv(name, value)
      name : String
      value : String
</pre>
<p>
The <tt>setenv</tt> function sets the value of a variable in
the process environment. Environment variables are scoped
like normal variables.
<p>
<h4><a name="section_89">get-registry</a></h4>

<p>
<pre>
   get-registry(hkey, key, field) : String
   get-registry(hkey, key, field, default) : String
       hkey : String
       key : String
       field : String
</pre>
<p>
The <tt>get-registry</tt> function retrieves a string value from the
system registry on Win32. On other architectures, there is no
registry.
<p>
The <tt>hive</tt> (I think that is the right word), indicates which part
of the registry to use. It should be one of the following values.
<p>
<ul compact>
<li><tt>HKEY_CLASSES_ROOT</tt>
</li>
<li><tt>HKEY_CURRENT_CONFIG</tt>
</li>
<li><tt>HKEY_CURRENT_USER</tt>
</li>
<li><tt>HKEY_LOCAL_MACHINE</tt>
</li>
<li><tt>HKEY_USERS</tt>
</li>
</ul>
Refer to the Microsoft documentation if you want to know what these mean.
<p>
The <tt>key</tt> is the field you want to get from the registry.
It should have a form like <tt>A\B\C</tt> (if you use forward slashes, they will
be converted to backslashes). The field is the sub-field of the key.
<p>
In the 4-argument form, the <tt>default</tt> is returned on failure.
You may also use the alternate form.
<p>
<pre>
    get-registry(hkey, key, field)
       default
</pre>
<p>
<h4><a name="section_90">getvar</a></h4>

<p>
<pre>
   $(getvar name) : String
</pre>
<p>
The <tt>getvar</tt> function gets the value of a variable.
<p>
An exception is raised if the variable
variable is not defined.
<p>
For example, the following code defines X to be the string abc.
<p>
<pre>
    NAME = foo
    foo_1 = abc
    X = $(getvar $(NAME)_1)
</pre>
<h4><a name="section_91">setvar</a></h4>

<p>
<pre>
   setvar(name, value)
      name : String
      value : String
</pre>
<p>
The <tt>setvar</tt> function defines a new variable. For example, the
following code defines the variable <tt>X</tt> to be the string <tt>abc</tt>.
<p>
<pre>
   NAME = X
   setvar($(NAME), abc)
</pre>
<h2><a name="section_92">Arrays and sequences</a></h2>

<p>
<h4><a name="section_93">array</a></h4>

<p>
<pre>
    $(array elements) : Array
       elements : Sequence
</pre>
<p>
The <tt>array</tt> function creates an array from a sequence.
If the <tt>&lt;arg&gt;</tt> is a string, the elements of the array
are the whitespace-separated elements of the string, respecting
quotes.
<p>
In addition, array variables can be declared as follows.
<p>
<pre>
    A[] =
       &lt;val1&gt;
       ...
       &lt;valn&gt;
</pre>
<p>
In this case, the elements of the array are exactly
<tt>&lt;val1&gt;</tt>, ..., <tt>&lt;valn&gt;</tt>, and whitespace is
preserved literally.
<h4><a name="section_94">split</a></h4>

<p>
<pre>
   $(split sep, elements) : Array
      sep : String
      elements : Sequence
</pre>
<p>
The <tt>split</tt> function takes two arguments, a string of separators, and
a string argument. The result is an array of elements determined by
splitting the elements by all occurrence of the separator in the
<tt>elements</tt> sequence.
<p>
For example, in the following code, the <tt>X</tt> variable is
defined to be the array <tt>/bin /usr/bin /usr/local/bin</tt>.
<p>
<pre>
    PATH = /bin:/usr/bin:/usr/local/bin
    X = $(split :, $(PATH))
</pre>
<p>
The <tt>sep</tt> argument may be omitted. In this case <tt>split</tt> breaks its
arguments along the white space. Quotations are not split.
<h4><a name="section_95">concat</a></h4>

<p>
<pre>
   $(concat sep, elements) : String
      sep : String
      elements : Sequence
</pre>
<p>
The <tt>concat</tt> function takes two arguments, a separator string, and
a sequence of elements. The result is a string formed by concatenating
the elements, placing the separator between adjacent elements.
<p>
For example, in the following code, the <tt>X</tt> variable is
defined to be the string <tt>foo_x_bar_x_baz</tt>.
<p>
<pre>
    X = foo  bar     baz
    Y = $(concat _x_, $(X))
</pre>
<h4><a name="section_96">length</a></h4>

<p>
<pre>
   $(length sequence) : Int
      sequence : Sequence
</pre>
<p>
The <tt>length</tt> function returns the number of elements in its argument.
<p>
For example, the expression <tt>$(length a b "c d")</tt> evaluates to 3.
<h4><a name="section_97">nth</a></h4>

<p>
<pre>
   $(nth i, sequence) : value
      i : Int
      sequence : Sequence
   raises RuntimeException
</pre>
<p>
The <tt>nth</tt> function returns the nth element of its argument, treated as
a list. Counting starts at 0. An exception is raised if the index is not in bounds.
<p>
For example, the expression <tt>$(nth 1, a "b c" d)</tt> evaluates to <tt>"b c"</tt>.
<h4><a name="section_98">nth-hd</a></h4>

<p>
<pre>
   $(nth-hd i, sequence) : value
      i : Int
      sequence : Sequence
   raises RuntimeException
</pre>
<p>
The <tt>nth-hd</tt> function returns the first <tt>i</tt> elements of
the sequence. An exception is raised if the sequence is not
at least <tt>i</tt> elements long.
<p>
For example, the expression <tt>$(nth-hd 2, a "b c" d)</tt> evaluates to <tt>a "b c"</tt>.
<p>
<h4><a name="section_99">nth-tl</a></h4>

<p>
<pre>
   $(nth-tl i, sequence) : value
      i : Int
      sequence : Sequence
   raises RuntimeException
</pre>
<p>
The <tt>nth-tl</tt> function skips <tt>i</tt> elements of the sequence
and returns the rest. An exception is raised if the sequence is not
at least <tt>i</tt> elements long.
<p>
For example, the expression <tt>$(nth-tl 1, a "b c" d)</tt> evaluates to <tt>"b c" d</tt>.
<p>
<h4><a name="section_100">sub</a></h4>

<p>
<pre>
   $(sub off, len, sequent) : value
      off : Int
      len : Int
      sequence : Sequence
   raises RuntimeException
</pre>
<p>
The <tt>sub</tt> function returns a subrange of the sequence.
Counting starts at 0. An exception is raised if the specified
range is not in bounds.
<p>
For example, the expression <tt>$(sub 1, 2, a "b c" d e)</tt> evaluates to <tt>"b c" d</tt>.
<h4><a name="section_101">rev</a></h4>

<p>
<pre>
    $(rev sequence) : Sequence
       sequence : Sequence
</pre>
<p>
The <tt>rev</tt> function returns the elements of a sequence in reverse order.
For example, the expression <tt>$(rev a "b c" d)</tt> evaluates to <tt>d "b c" a</tt>.
<h4><a name="section_102">string</a></h4>

<p>
<pre>
   $(string sequence) : String
      sequence : Sequence
</pre>
<p>
The <tt>string</tt> function flattens a sequence into a single string.
This is similar to the <tt>concat</tt> function, but the elements are
separated by whitespace. The result is treated as a unit; whitespace
is significant.
<h4><a name="section_103">quote</a></h4>

<p>
<pre>
   $(quote sequence) : String
      sequence : Sequence
</pre>
<p>
The <tt>quote</tt> function flattens a sequence into a single string
and adds quotes around the string. Inner quotation symbols are
escaped.
<p>
For example, the expression <tt>$(quote a "b c" d)</tt> evaluates
to <tt>"a \"b c\" d"</tt>, and <tt>$(quote abc)</tt> evaluates to
<tt>"abc"</tt>.
<h4><a name="section_104">quote-argv</a></h4>

<p>
<pre>
   $(quote-argv sequence) : String
      sequence : Sequence
</pre>
<p>
The <tt>quote-argv</tt> function flattens a sequence into a single string,
and adds quotes around the string. The quotation is formed so that
a command-line parse can separate the string back into its components.
<h4><a name="section_105">html-string</a></h4>

<p>
<pre>
   $(html-string sequence) : String
      sequence : Sequence
</pre>
<p>
The <tt>html-string</tt> function flattens a sequence into a single string,
and escaped special HTML characters.
This is similar to the <tt>concat</tt> function, but the elements are
separated by whitespace. The result is treated as a unit; whitespace
is significant.
<h4><a name="section_106">addsuffix</a></h4>

<p>
<pre>
   $(addsuffix suffix, sequence) : Array
      suffix : String
      sequence : Sequence
</pre>
<p>
The <tt>addsuffix</tt> function adds a suffix to each component of sequence.
The number of elements in the array is exactly the same as the number of
elements in the sequence.
<p>
For example, <tt>$(addsuffix .c, a b "c d")</tt> evaluates to <tt>a.c b.c "c d".c</tt>.
<h4><a name="section_107">mapsuffix</a></h4>

<p>
<pre>
   $(mapsuffix suffix, sequence) : Array
      suffix : value
      sequence : Sequence
</pre>
<p>
The <tt>mapsuffix</tt> function adds a suffix to each component of sequence.
It is similar to <tt>addsuffix</tt>, but uses array concatenation instead
of string concatenation. The number of elements in the array is
twice the number of elements in the sequence.
<p>
For example, <tt>$(mapsuffix .c, a b "c d")</tt> evaluates to <tt>a .c b .c "c d" .c</tt>.
<h4><a name="section_108">addsuffixes</a></h4>

<p>
<pre>
   $(addsuffixes suffixes, sequence) : Array
      suffixes : Sequence
      sequence : Sequence
</pre>
<p>
The <tt>addsuffixes</tt> function adds all suffixes in its first argument
to each component of a sequence. If <tt>suffixes</tt> has <tt>n</tt> elements,
and <tt>sequence</tt> has <tt>m</tt> elements, the the result has <tt>n * m</tt> elements.
<p>
For example, the <tt>$(addsuffixes .c .o, a b c)</tt> expressions evaluates to
<tt>a.c a.o b.c b.o c.o c.a</tt>.
<h4><a name="section_109">removeprefix</a></h4>

<p>
<pre>
   $(removeprefix prefix, sequence) : Array
      prefix : String
      sequence : Array
</pre>
<p>
The <tt>removeprefix</tt> function removes a prefix from each component
of a sequence.
<h4><a name="section_110">removesuffix</a></h4>

<p>
<pre>
   $(removesuffix sequence) : Array
      sequence : String
</pre>
<p>
The <tt>removesuffix</tt> function removes the suffixes from each component
of a sequence.
<p>
For example, <tt>$(removesuffix a.c b.foo "c d")</tt> expands to <tt>a b "c d"</tt>.
<h4><a name="section_111">replacesuffixes</a></h4>

<p>
<pre>
   $(replacesuffixes old-suffixes, new-suffixes, sequence) : Array
      old-suffixes : Sequence
      new-suffixes : Sequence
      sequence : Sequence
</pre>
<p>
The <tt>replacesuffixes</tt> function modifies the suffix of each component
in sequence. The <tt>old-suffixes</tt> and <tt>new-suffixes</tt> sequences
should have the same length.
<p>
For example, <tt>$(replacesuffixes, .h .c, .o .o, a.c b.h c.z)</tt> expands to <tt>a.o b.o c.z</tt>.
<h4><a name="section_112">addprefix</a></h4>

<p>
<pre>
   $(addprefix prefix, sequence) : Array
      prefix : String
      sequence : Sequence
</pre>
<p>
The <tt>addprefix</tt> function adds a prefix to each component of a sequence.
The number of element in the result array is exactly the same as the number
of elements in the argument sequence.
<p>
For example, <tt>$(addprefix foo/, a b "c d")</tt> evaluates to <tt>foo/a foo/b foo/"c d"</tt>.
<h4><a name="section_113">mapprefix</a></h4>

<p>
<pre>
   $(mapprefix prefix, sequence) : Array
      prefix : String
      sequence : Sequence
</pre>
<p>
The <tt>mapprefix</tt> function adds a prefix to each component of a sequence.
It is similar to <tt>addprefix</tt>, but array concatenation is used instead of
string concatenation. The result array contains twice as many elements
as the argument sequence.
<p>
For example, <tt>$(mapprefix foo, a b "c d")</tt> expands to <tt>foo a foo b foo "c d"</tt>.
<h4><a name="section_114">add-wrapper</a></h4>

<p>
<pre>
   $(add-wrapper prefix, suffix, sequence) : Array
      prefix : String
      suffix : String
      sequence : Sequence
</pre>
<p>
The <tt>add-wrapper</tt> functions adds both a prefix and a suffix to each component of a sequence.
For example, the expression <tt>$(add-wrapper dir/, .c, a b)</tt> evaluates to
<tt>dir/a.c dir/b.c</tt>. String concatenation is used. The array result
has the same number of elements as the argument sequence.
<h4><a name="section_115">set</a></h4>

<p>
<pre>
   $(set sequence) : Array
      sequence : Sequence
</pre>
<p>
The <tt>set</tt> function sorts a set of string components, eliminating duplicates.
<p>
For example, <tt>$(set z y z "m n" w a)</tt> expands to <tt>"m n" a w y z</tt>.
<h4><a name="section_116">mem</a></h4>

<p>
<pre>
   $(mem elem, sequence) : Boolean
      elem : String
      sequence : Sequence
</pre>
<p>
The <tt>mem</tt> function tests for membership in a sequence.
<p>
For example, <tt>$(mem "m n", y z "m n" w a)</tt> evaluates to <tt>true</tt>,
while <tt>$(mem m n, y z "m n" w a)</tt> evaluates to <tt>false</tt>.
<h4><a name="section_117">intersection</a></h4>

<p>
<pre>
   $(intersection sequence1, sequence2) : Array
      sequence1 : Sequence
      sequence2 : Sequence
</pre>
<p>
The <tt>intersection</tt> function takes two arguments, treats them
as sets of strings, and computes their intersection. The order of the result
is undefined, and it may contain duplicates. Use the <tt>set</tt>
function to sort the result and eliminate duplicates in the result
if desired.
<p>
For example, the expression <tt>$(intersection c a b a, b a)</tt> evaluates to
<tt>a b a</tt>.
<h4><a name="section_118">intersects</a></h4>

<p>
<pre>
   $(intersects sequence1, sequence2) : Boolean
      sequence1 : Sequence
      sequence2 : Sequence
</pre>
<p>
The <tt>intersects</tt> function tests whether two sets have a non-empty intersection.
This is slightly more efficient than computing the intersection and testing whether
it is empty.
<p>
For example, the expression <tt>$(intersects a b c, d c e)</tt> evaluates to <tt>true</tt>,
and <tt>$(intersects a b c a, d e f)</tt> evaluates to <tt>false</tt>.
<h4><a name="section_119">set-diff</a></h4>

<p>
<pre>
   $(set-diff sequence1, sequence2) : Array
      sequence1 : Sequence
      sequence2 : Sequence
</pre>
<p>
The <tt>set-diff</tt> function takes two arguments, treats them
as sets of strings, and computes their difference (all the elements of the
first set that are not present in the second one). The order of the result
is undefined and it may contain duplicates. Use the <tt>set</tt>
function to sort the result and eliminate duplicates in the result
if desired.
<p>
For example, the expression <tt>$(set-diff c a b a e, b a)</tt> evaluates to
<tt>c e</tt>.
<h4><a name="section_120">filter</a></h4>

<p>
<pre>
   $(filter patterns, sequence) : Array
      patterns : Sequence
      sequence : Sequence
</pre>
<p>
The <tt>filter</tt> function picks elements from a sequence.
The patterns is a non-empty sequence of patterns, each may contain one occurrence of the wildcard
<tt>%</tt> character.
<p>
For example <tt>$(filter %.h %.o, a.c x.o b.h y.o "hello world".c)</tt> evaluates to <tt>x.o b.h y.o</tt>.
<h4><a name="section_121">filter-out</a></h4>

<p>
<pre>
   $(filter-out patterns, sequence) : Array
      patterns : Sequence
      sequence : Sequence
</pre>
<p>
The <tt>filter-out</tt> function removes elements from a sequence.
The patterns is a non-empty sequence of patterns, each may contain one occurrence of the wildcard
<tt>%</tt> character.
<p>
For example <tt>$(filter-out %.c %.h, a.c x.o b.h y.o "hello world".c)</tt> evaluates to <tt>x.o y.o</tt>.
<h4><a name="section_122">capitalize</a></h4>

<p>
<pre>
   $(capitalize sequence) : Array
      sequence : Sequence
</pre>
<p>
The <tt>capitalize</tt> function capitalizes each word in a sequence.
For example, <tt>$(capitalize through the looking Glass)</tt> evaluates to
<tt>Through The Looking Glass</tt>.
<h4><a name="section_123">uncapitalize</a></h4>

<p>
<pre>
   $(uncapitalize sequence) : Array
      sequence : Sequence
</pre>
<p>
The <tt>uncapitalize</tt> function uncapitalizes each word in its argument.
<p>
For example, <tt>$(uncapitalize through the looking Glass)</tt> evaluates to
<tt>through the looking glass</tt>.
<h4><a name="section_124">uppercase</a></h4>

<p>
<pre>
   $(uppercase sequence) : Array
      sequence : Sequence
</pre>
<p>
The <tt>uppercase</tt> function converts each word in a sequence to uppercase.
For example, <tt>$(uppercase through the looking Glass)</tt> evaluates to
<tt>THROUGH THE LOOKING GLASS</tt>.
<h4><a name="section_125">lowercase</a></h4>

<p>
<pre>
   $(lowercase sequence) : Array
      sequence : Sequence
</pre>
<p>
The <tt>lowercase</tt> function reduces each word in its argument to lowercase.
<p>
For example, <tt>$(lowercase through tHe looking Glass)</tt> evaluates to
<tt>through the looking glass</tt>.
<h4><a name="section_126">system</a></h4>

<p>
<pre>
   system(s)
      s : Sequence
</pre>
<p>
The <tt>system</tt> function is used to evaluate a shell expression.
This function is used internally by <tt>omake</tt>
to evaluate
shell commands.
<p>
For example, the following program is equivalent to the
expression <tt>system(ls foo)</tt>.
<p>
<pre>
   ls foo
</pre>
<h4><a name="section_127">shell</a></h4>

<p>
<pre>
   $(shell command) : Array
   $(shella command) : Array
   $(shell-code command) : Int
      command : Sequence
</pre>
<p>
The <tt>shell</tt> function evaluates a command using the command shell,
and returns the whitespace-separated words of the standard output as the result.
<p>
The <tt>shella</tt> function acts similarly, but it returns the lines
as separate items in the array.
<p>
The <tt>shell-code</tt> function returns the exit code. The output is not
diverted.
<p>
For example, if the current directory contains the files <tt>OMakeroot</tt>,
<tt>OMakefile</tt>, and <tt>hello.c</tt>, then <tt>$(shell ls)</tt> evaluates to
<tt>hello.c OMakefile OMakeroot</tt> (on a Unix system).
<h2><a name="section_128">Arithmetic</a></h2>

<h4><a name="section_129">int</a></h4>

<p>
The <tt>int</tt> function can be used to create integers.
It returns an <tt>Int</tt> object.
<p>
<tt>$(int 17)</tt>.
<p>
<h4><a name="section_130">float</a></h4>

The <tt>float</tt> function can be used to create floating-point numbers.
It returns a <tt>Float</tt> object.
<p>
<tt>$(float 3.1415926)</tt>.
<h4><a name="section_131">Basic arithmetic</a></h4>

<p>
The following functions can be used to perform basic arithmetic.
<p>
<ul compact>
<li><tt>$(neg &lt;numbers&gt;)</tt>: arithmetic inverse
</li>
<li><tt>$(add &lt;numbers&gt;)</tt>: addition.
</li>
<li><tt>$(sub &lt;numbers&gt;)</tt>: subtraction.
</li>
<li><tt>$(mul &lt;numbers&gt;)</tt>: multiplication.
</li>
<li><tt>$(div &lt;numbers&gt;)</tt>: division.
</li>
<li><tt>$(mod &lt;numbers&gt;)</tt>: remainder.
</li>
<li><tt>$(lnot &lt;numbers&gt;)</tt>: bitwise inverse.
</li>
<li><tt>$(land &lt;numbers&gt;)</tt>: bitwise and.
</li>
<li><tt>$(lor &lt;numbers&gt;)</tt>: bitwise or.
</li>
<li><tt>$(lxor &lt;numbers&gt;)</tt>: bitwise exclusive-or.
</li>
<li><tt>$(lsl &lt;numbers&gt;)</tt>: logical shift left.
</li>
<li><tt>$(lsr &lt;numbers&gt;)</tt>: logical shift right.
</li>
<li><tt>$(asr &lt;numbers&gt;)</tt>: arithmetic shift right.
</li>
</ul>
<h4><a name="section_132">Comparisons</a></h4>

<p>
The following functions can be used to perform numerical comparisons.
<p>
<ul compact>
<li><tt>$(lt &lt;numbers&gt;)</tt>: less then.
</li>
<li><tt>$(le &lt;numbers&gt;)</tt>: no more than.
</li>
<li><tt>$(eq &lt;numbers&gt;)</tt>: equal.
</li>
<li><tt>$(ge &lt;numbers&gt;)</tt>: no less than.
</li>
<li><tt>$(gt &lt;numbers&gt;)</tt>: greater than.
</li>
<li><tt>$(ult &lt;numbers&gt;)</tt>: unsigned less than.
</li>
<li><tt>$(ule &lt;numbers&gt;)</tt>: unsigned greater than.
</li>
<li><tt>$(uge &lt;numbers&gt;)</tt>: unsigned greater than or equal.
</li>
<li><tt>$(ugt &lt;numbers&gt;)</tt>: unsigned greater than.
</li>
</ul>
<h2><a name="section_133">First-class functions</a></h2>

<h4><a name="section_134">fun</a></h4>

<p>
The <tt>fun</tt> form introduces anonymous functions.
<p>
<tt>$(fun &lt;v1&gt;, ..., &lt;vn&gt;, &lt;body&gt;)</tt>
<p>
The last argument is the body of the function.
The other arguments are the parameter names.
<p>
The three following definitions are equivalent.
<p>
<pre>
    F(X, Y) =
       return($(addsuffix $(Y), $(X)))

    F = $(fun X, Y, $(addsuffix $(Y), $(X)))

    F =
       fun(X, Y)
          value $(addsuffix $(Y), $(X))
</pre>
<h4><a name="section_135">apply</a></h4>

<p>
The <tt>apply</tt> operator is used to apply a function.
<p>
<tt>$(apply &lt;fun&gt;, &lt;args&gt;)</tt>
<p>
Suppose we have the following function definition.
<p>
<pre>
    F(X, Y) =
       return($(addsuffix $(Y), $(X)))
</pre>
<p>
The the two expressions below are equivalent.
<p>
<pre>
    X = F(a b c, .c)
    X = $(apply $(F), a b c, .c)
</pre>
<h4><a name="section_136">applya</a></h4>

<p>
The <tt>applya</tt> operator is used to apply a function to
an array of arguments.
<p>
<tt>$(applya &lt;fun&gt;, &lt;args&gt;)</tt>
<p>
For example, in the following program, the value
of <tt>Z</tt> is <tt>file.c</tt>.
<p>
<pre>
    F(X, Y) =
       return($(addsuffix $(Y), $(X)))
    args[] =
       file
       .c
    Z = $(applya $(F), $(args))
</pre>
<h2><a name="section_137">Iteration and mapping</a></h2>

<p>
<h4><a name="section_138">foreach</a></h4>

<p>
The <tt>foreach</tt> function maps a function over a sequence.
<p>
<pre>
    $(foreach &lt;fun&gt;, &lt;args&gt;)

    foreach(&lt;var&gt;, &lt;args&gt;)
       &lt;body&gt;
</pre>
<p>
For example, the following program defines the variable <tt>X</tt>
as an array <tt>a.c b.c c.c</tt>.
<p>
<pre>
    X =
       foreach(x, a b c)
          value $(x).c

    # Equivalent expression
    X = $(foreach $(fun x, $(x).c), abc)
</pre>
<p>
There is also an abbreviated syntax.
<p>
The <tt>export</tt> form can also be used in a <tt>foreach</tt>
body. The final value of <tt>X</tt> is <tt>a.c b.c c.c</tt>.
<p>
<pre>
    X =
    foreach(x, a b c)
       X += $(x).c
       export
</pre>
<h2><a name="section_139">File operations</a></h2>

<h4><a name="section_140">file, dir</a></h4>

<p>
<pre>
   $(file sequence) : File Sequence
      sequence : Sequence
   $(dir sequence) : Dir Sequence
      sequence : Sequence
</pre>
<p>
The <tt>file</tt> and <tt>dir</tt> functions define location-independent references to files and directories.
In <tt>omake</tt>,
the commands to build a target are executed in the target's directory. Since there may be
many directories in an <tt>omake</tt>
project, the build system provides a way to construct a reference to a file
in one directory, and use it in another without explicitly modifying the file name. The functions have the following
syntax, where the name should refer to a file or directory.
<p>
For example, we can construct a reference to a file <tt>foo</tt> in the current directory.
<p>
<pre>
   FOO = $(file foo)
   .SUBDIRS: bar
</pre>
<p>
If the <tt>FOO</tt> variable is expanded in the <tt>bar</tt> subdirectory, it will expand to <tt>../foo</tt>.
<p>
These commands are often used in the top-level OMakefile to provide location-independent references to
top-level directories, so that build commands may refer to these directories as if they were absolute.
<p>
<pre>
   ROOT = $(dir .)
   LIB  = $(dir lib)
   BIN  = $(dir bin)
</pre>
<p>
Once these variables are defined, they can be used in build commands in subdirectories as follows, where
<tt>$(BIN)</tt> will expand to the location of the <tt>bin</tt> directory relative to the command being executed.
<p>
<pre>
   install: hello
	cp hello $(BIN)
</pre>
<h4><a name="section_141">tmpfile</a></h4>

<p>
<pre>
    $(tmpfile prefix) : File
    $(tmpfile prefix, suffix) : File
        prefix : String
        suffix : String
</pre>
<p>
The <tt>tmpfile</tt> function returns the name of a fresh temporary file in
the temporary directory.
<h4><a name="section_142">in</a></h4>

<p>
<pre>
   $(in dir, exp) : String Array
      dir : Dir
      exp : expression
</pre>
<p>
The <tt>in</tt> function is closely related to the <tt>dir</tt> and
<tt>file</tt> functions. It takes a directory and an expression, and
evaluates the expression in that effective directory.
For example, one common way to install a file is to define a symbol link, where the
value of the link is relative to the directory where the link is created.
<p>
The following commands create links in the <tt>$(LIB)</tt> directory.
<p>
<pre>
    FOO = $(file foo)
    install:
       ln -s $(in $(LIB), $(FOO)) $(LIB)/foo
</pre>
<p>
Note that the <tt>in</tt> function only affects the expansion of <tt>Node</tt>
(<tt>File</tt> and <tt>Dir</tt>) values.
<h4><a name="section_143">which</a></h4>

<p>
<pre>
   $(which files) : File Sequence
      files : String Sequence
</pre>
<p>
The <tt>which</tt> function searches for executables in the
current command search path, and returns <tt>file</tt> values
for each of the commands. It is an error if a command is
not found.
<h4><a name="section_144">where</a></h4>

<p>
The <tt>where</tt> function is similar to which, except it returns the list of
all the locations of the given executable (in the order in which the
corresponding directories appear in <tt>$PATH</tt>). In case a command is handled
internally by the <tt>Shell</tt> object, the first string in the output will
describe the command as a built-in function.
<p>
<pre>
    % where echo
    echo is a Shell object method (a built-in function)
    /bin/echo
</pre>
<h4><a name="section_145">exists-in-path</a></h4>

<p>
<pre>
   $(exists-in-path files) : String
      files : String Sequence
</pre>
<p>
The <tt>exists-in-path</tt> function tests whether all executables
are present in the current search path.
<h4><a name="section_146">basename</a></h4>

<p>
<pre>
   $(basename files) : String Sequence
      files : String Sequence
</pre>
<p>
The <tt>basename</tt> function returns the base names for a list of files.
The basename is the filename with any leading directory components removed.
<p>
For example, the expression <tt>$(basename dir1/dir2/a.out /etc/modules.conf /foo.ml)</tt> evaluates to
<tt>a.out modules.conf foo.ml</tt>.
<h4><a name="section_147">rootname</a></h4>

<p>
<pre>
   $(rootname files) : String Sequence
      files : String Sequence
</pre>
<p>
The <tt>rootname</tt> function returns the root name for a list of files.
The rootname is the filename with the final suffix removed.
<p>
For example, the expression <tt>$(rootname dir1/dir2/a.out /etc/a.b.c /foo.ml)</tt> evaluates to
<tt>dir1/dir2/a /etc/a.b /foo</tt>.
<h4><a name="section_148">dirof</a></h4>

<p>
<pre>
   $(dirof files) : Dir Sequence
      files : File Sequence
</pre>
<p>
The <tt>dirof</tt> function returns the directory for each of the listed files.
<p>
For example, the expression <tt>$(dirof dir/dir2/a.out /etc/modules.conf /foo.ml)</tt> evaluates
to the directories <tt>dir1/dir2 /etc /</tt>.
<h4><a name="section_149">fullname</a></h4>

<p>
<pre>
   $(fullname files) : String Sequence
      files : File Sequence
</pre>
<p>
The <tt>fullname</tt> function returns the pathname relative to the project root
for each of the files or directories.
<h4><a name="section_150">absname</a></h4>

<p>
<pre>
   $(absname files) : String Sequence
      files : File Sequence
</pre>
<p>
The <tt>absname</tt> function returns the absolute pathname for each of the files
or directories.
<h4><a name="section_151">homename</a></h4>

<p>
<pre>
   $(homename files) : String Sequence
      files : File Sequence
</pre>
<p>
The <tt>homename</tt> function returns the name of a file in
tilde form, if possible. The unexpanded forms are computed
lazily: the <tt>homename</tt> function will usually evaluate to an absolute
pathname until the first tilde-expansion for the same directory.
<h4><a name="section_152">suffix</a></h4>

<p>
<pre>
   $(suffix files) : String Sequence
      files : StringSequence
</pre>
<p>
The <tt>suffix</tt> function returns the suffixes for a list of files.
If a file has no suffix, the function returns the empty string.
<p>
For example, the expression <tt>$(suffix dir1/dir2/a.out /etc/a /foo.ml)</tt> evaluates
to <tt>.out .ml</tt>.
<h4><a name="section_153">file-exists, target-exists, target-is-proper</a></h4>

<p>
<pre>
   $(file-exists files) : String
   $(target-exists files) : String
   $(target-is-proper files) : String
       files : File Sequence
</pre>
<p>
The <tt>file-exists</tt> function checks whether the files listed exist.
The <tt>target-exists</tt> function is similar to the <tt>file-exists</tt> function.
However, it returns true if the file exists <em>or</em>
if it can be built
by the current project. The <tt>target-is-proper</tt> returns true only
if the file can be generated in the current project.
<h4><a name="section_154">filter-exists, filter-targets, filter-proper-targets</a></h4>

<p>
<pre>
   $(filter-exists files) : File Sequence
   $(filter-targets files) : File Sequence
   $(filter-proper-targets) : File Sequence
      files : File Sequence
</pre>
<p>
The <tt>filter-exists</tt>, <tt>filter-targets</tt>, and <tt>filter-proper-targets</tt>
functions remove files from a list of files.
<ul compact>
<li><tt>filter-exists</tt>: the result is the list of files that exist.
</li>
<li><tt>filter-targets</tt>: the result is the list of files either exist, or
can be built by the current project.
</li>
<li><tt>filter-proper-targets</tt>: the result is the list of files that can
be built in the current project.
</li>
</ul>
<p>
One way to create a simple &ldquo;clean&rdquo; rule that removes generated files from
the project is by removing all files that can be built in the current
project. CAUTION: you should be careful before you do this. The rule
removes <em>any</em>
file that can <em>potentially</em>
be reconstructed.
There is no check to make sure that the commands to rebuild the file
would actually succeed. Also, note that no file outside the
current project will be deleted.
<p>
<pre>
    .PHONY: clean

    clean:
        rm $(filter-proper-targets $(ls R, .))
</pre>
<p>
See the <tt>dependencies-proper</tt> function to see an alternate method
for removing intermediate files.
<p>
If you use CVS, you may wish to use the <tt>cvs_realclean</tt> program that
is distributed with <tt>omake</tt>.
<p>
<h4><a name="section_155">file-sort</a></h4>

<p>
<pre>
   $(file-sort order, files) : File Sequence
      order : String
      files : File Sequence
</pre>
<p>
The <tt>file-sort</tt> function sorts a list of filenames by
build order augmented by a set of sort rules. Sort
rules are declared using the <tt>.ORDER</tt> target.
The <tt>.BUILDORDER</tt> defines the default order.
<p>
<tt>$(file-sort &lt;order&gt;, &lt;files&gt;)</tt>
<p>
For example, suppose we have the following set of rules.
<p>
<pre>
   a: b c
   b: d
   c: d

   .DEFAULT: a b c d
      echo $(file-sort .BUILDORDER, a b c d)
</pre>
<p>
In the case, the sorter produces the result <tt>d b c a</tt>.
That is, a target is sorted <em>after</em>
its dependencies.
The sorter is frequently used to sort files that are to be linked
by their dependencies (for languages where this matters).
<p>
There are three important restrictions to the sorter:
<ul compact>
<li>The sorter can be used only within a rule body.
The reason for this is that <em>all</em>
dependencies
must be known before the sort is performed.
</li>
<li>The sorter can only sort files that are buildable
in the current project.
</li>
<li>The sorter will fail if the dependencies are cyclic.
</li>
</ul>
<p>
<h4><a name="section_156">sort rule</a></h4>

<p>
It is possible to further constrain the sorter through the use of
sort rules. A sort rule is declared in two steps. The
target must be listed as an <tt>.ORDER</tt> target; and then
a set of sort rules must be given. A sort rule defines
a pattern constraint.
<p>
<pre>
   .ORDER: .MYORDER

   .MYORDER: %.foo: %.bar
   .MYORDER: %.bar: %.baz

   .DEFAULT: a.foo b.bar c.baz d.baz
      echo $(sort .MYORDER, a.foo b.bar c.baz d.baz)
</pre>
<p>
In this example, the <tt>.MYORDER</tt> sort rule specifies that any
file with a suffix <tt>.foo</tt> should be placed after any file with
suffix <tt>.bar</tt>, and any file with suffix <tt>.bar</tt> should be
placed after a file with suffix <tt>.baz</tt>.
<p>
In this example, the result of the sort is <tt>d.baz c.baz b.bar a.foo</tt>.
<h4><a name="section_157">file-check-sort</a></h4>

<p>
<pre>
   file-check-sort(files)
      files : File Sequence
   raises RuntimeException
</pre>
<p>
The <tt>file-check-sort</tt> function checks whether a list of files
is in sort order. If so, the list is returned unchanged.
If not, the function raises an exception.
<p>
<tt>$(file-check-sort &lt;order&gt;, &lt;files&gt;)</tt>
<h4><a name="section_158">glob</a></h4>

<p>
<pre>
   $(glob strings) : Node Array
      strings : String Sequence
   $(glob options, strings) : Node Array
      options : String
      strings : String Sequence
</pre>
<p>
The <tt>glob</tt> function performs glob-expansion.
<p>
The . and .. entries are always ignored.
<p>
The options are:
<dl compact>
<dt>b</dt>
<dd> Do not perform <em>csh</em>(1)-style
brace expansion.
</dd>
<dt>e</dt>
<dd> The <tt>\</tt> character does not escape special characters.
</dd>
<dt>n</dt>
<dd> If an expansion fails, return the expansion literally instead of aborting.
</dd>
<dt>i</dt>
<dd> If an expansion fails, it expands to nothing.
</dd>
<dt>.</dt>
<dd> Allow wildcard patterns to match files beginning with a .
</dd>
<dt>A</dt>
<dd> Return all files, including files that begin with a .
</dd>
<dt>D</dt>
<dd> Match only directory files.
</dd>
<dt>C</dt>
<dd> Ignore files according to <em>cvs</em>(1)
rules.
</dd>
<dt>P</dt>
<dd> Include only proper subdirectories.
</dd>
</dl>
<p>
In addition, the following variables may be defined that affect the
behavior of <tt>glob</tt>.
<p>
<dl compact>
<dt>GLOB_OPTIONS</dt>
<dd> A string containing default options.
</dd>
<dt>GLOB_IGNORE</dt>
<dd> A list of shell patterns for filenames that <tt>glob</tt> should ignore.
</dd>
<dt>GLOB_ALLOW</dt>
<dd> A list of shell patterns. If a file does not match a pattern in
<tt>GLOB_ALLOW</tt>, it is ignored.
</dd>
</dl>
<p>
The returned files are sorted by name.
<h4><a name="section_159">ls</a></h4>

<p>
<pre>
   $(ls files) : Node Array
      files : String Sequence
   $(ls options, files) : Node Array
      files : String Sequence
</pre>
<p>
The <tt>ls</tt> function returns the filenames in a directory.
<p>
The . and .. entries are always ignored.
The patterns are shell-style patterns, and are glob-expanded.
<p>
The options include all of the options to the <tt>glob</tt> function,
plus the following.
<p>
<dl compact>
<dt>R</dt>
<dd> Perform a recursive listing.
</dd>
</dl>
<p>
The <tt>GLOB_ALLOW</tt> and <tt>GLOB_IGNORE</tt> variables can be defined
to control the globbing behavior.
The returned files are sorted by name.
<h4><a name="section_160">subdirs</a></h4>

<p>
<pre>
   $(subdirs dirs) : Dir Array
      dirs : String Sequence
   $(subdirs options, dirs) : Dir Array
      options : String
      dirs : String Sequence
</pre>
<p>
The <tt>subdirs</tt> function returns all the subdirectories
of a list of directories, recursively.
<p>
The possible options are the following:
<dl compact>
<dt>A</dt>
<dd> Return directories that begin with a .
</dd>
<dt>C</dt>
<dd> Ignore files according to <tt>.cvsignore</tt>
rules.
</dd>
<dt>P</dt>
<dd> Include only proper subdirectories.
</dd>
</dl>
<h4><a name="section_161">mkdir</a></h4>

<p>
<pre>
   mkdir(mode, node...)
      mode : Int
      node : Node
   raises RuntimeException

   mkdir(node...)
      node : Node
   raises RuntimeException
</pre>
<p>
The <tt>mkdir</tt> function creates a directory, or a set of directories.
The following options are supported.
<ul compact>
<dt>-m mode</dt>
<dd> Specify the permissions of the created directory.
</dd>
<dt>-p</dt>
<dd> Create parent directories if they do not exist.
</dd>
<dt>--</dt>
<dd> Interpret the remaining names literally.
</li>
</ul>
<h4><a name="section_162">Stat</a></h4>

<p>
The <tt>Stat</tt> object represents the result returned by the <tt>stat</tt>
and <tt>lstat</tt> functions. It contains the following fields.
<p>
A <tt>stat</tt> object has the following fields. Not all of the fields
will have meaning on all architectures.
<p>
<dl compact>
<dt>dev</dt>
<dd>: the device number.
</dd>
<dt>ino</dt>
<dd>: the inode number.
</dd>
<dt>kind</dt>
<dd>: the kind of the file, one of the following:
<tt>REG</tt> (regular file),
<tt>DIR</tt> (directory),
<tt>CHR</tt> (character device),
<tt>BLK</tt> (block device),
<tt>LNK</tt> (symbolic link),
<tt>FIFO</tt> (named pipe),
<tt>SOCK</tt> (socket).
</dd>
<dt>perm</dt>
<dd>: access rights, represented as an integer.
</dd>
<dt>nlink</dt>
<dd>: number of links.
</dd>
<dt>uid</dt>
<dd>: user id of the owner.
</dd>
<dt>gid</dt>
<dd>: group id of the file's group.
</dd>
<dt>rdev</dt>
<dd>: device minor number.
</dd>
<dt>size</dt>
<dd>: size in bytes.
</dd>
<dt>atime</dt>
<dd>: last access time, as a floating point number.
</dd>
<dt>mtime</dt>
<dd>: last modification time, as a floating point number.
</dd>
<dt>ctime</dt>
<dd>: last status change time, as a floating point number.
</dd>
</dl>
<p>
<h4><a name="section_163">stat</a></h4>

<p>
<pre>
    $(stat node...) : Stat
       node : Node or Channel
    $(lstat node...) : Stat
       node : Node or Channel
    raises RuntimeException
</pre>
<p>
The <tt>stat</tt> functions return file information.
If the file is a symbolic link, the <tt>stat</tt> function refers to the
destination of the link; the <tt>lstat</tt> function refers to the link
itself.
<h4><a name="section_164">unlink</a></h4>

<p>
<pre>
   $(unlink file...)
      file : File
   #(rm file...)
      file : File
   $(rmdir dir...)
      dir : Dir
   raises RuntimeException
</pre>
<p>
The <tt>unlink</tt> and <tt>rm</tt> functions remove a file.
The <tt>rmdir</tt> function removes a directory.
<p>
The following options are supported for <tt>rm</tt> and <tt>rmdir</tt>.
<ul compact>
<dt>-f</dt>
<dd> ignore nonexistent files, never prompt.
</dd>
<dt>-i</dt>
<dd> prompt before removal.
</dd>
<dt>-r</dt>
<dd> remove the contents of directories recursively.
</dd>
<dt>-v</dt>
<dd> explain what is going on.
</dd>
<dt>--</dt>
<dd> the rest of the values are interpreted literally.
</li>
</ul>
<h4><a name="section_165">rename</a></h4>

<p>
<pre>
    rename(old, new)
       old : Node
       new : Node
    mv(nodes... dir)
       nodes : Node Sequence
       dir   : Dir
    cp(nodes... dir)
       nodes : Node Sequence
       dir   : Dir
    raises RuntimeException
</pre>
<p>
The <tt>rename</tt> function changes the name of a file or directory named <tt>old</tt>
to <tt>new</tt>.
<p>
The <tt>mv</tt> function is similar, but if <tt>new</tt> is a directory, and it exists,
then the files specified by the sequence are moved into the directory. If not,
the behavior of <tt>mv</tt> is identical to <tt>rename</tt>. The <tt>cp</tt> function
is similar, but the original file is not removed.
<p>
The <tt>mv</tt> and <tt>cp</tt> functions take the following options.
<ul compact>
<dt>-f</dt>
<dd> Do not prompt before overwriting.
</dd>
<dt>-i</dt>
<dd> Prompt before overwriting.
</dd>
<dt>-v</dt>
<dd> Explain what it happening.
</dd>
<dt>-r</dt>
<dd> Copy the contents of directories recursively.
</dd>
<dt>--</dt>
<dd> Interpret the remaining arguments literally.
</li>
</ul>
<h4><a name="section_166">link</a></h4>

<p>
<pre>
   link(src, dst)
      src : Node
      dst : Node
   raises RuntimeException
</pre>
<p>
The <tt>link</tt> function creates a hard link named <tt>dst</tt> to the file
or directory <tt>src</tt>.
<p>
Hard links are not supported in Win32.
<p>
Normally, only the superuser can create hard links to directories.
<h4><a name="section_167">symlink</a></h4>

<p>
<pre>
   symlink(src, dst)
      src : Node
      dst : Node
   raises RuntimeException
</pre>
<p>
The <tt>symlink</tt> function creates a symbolic link <tt>dst</tt> that
points to the <tt>src</tt> file.
<p>
The link name is computed relative to
the target directory. For example, the expression
<tt>$(symlink a/b, c/d)</tt> creates a link named
<tt>c/d -&gt; ../a/b</tt>.
<p>
Symbolic links are not supported in Win32.
<h4><a name="section_168">readlink</a></h4>

<p>
<pre>
   $(readlink node...) : Node
      node : Node
</pre>
<p>
The <tt>readlink</tt> function reads the value of a symbolic link.
<h4><a name="section_169">chmod</a></h4>

<p>
<pre>
   chmod(mode, dst...)
      mode : Int
      dst : Node or Channel
   chmod(mode dst...)
      mode : String
      dst : Node Sequence
   raises RuntimeException
</pre>
<p>
The <tt>chmod</tt> function changes the permissions of the targets.
The <tt>chmod</tt> function does nothing on Win32 platforms.
<p>
Options:
<ul compact>
<dt>-v</dt>
<dd> Explain what is happening.
</dd>
<dt>-r</dt>
<dd> Change files and directories recursively.
</dd>
<dt>-f</dt>
<dd> Continue on errors.
</dd>
<dt>--</dt>
<dd> Interpret the remaining argument literally.
</li>
</ul>
<h4><a name="section_170">chown</a></h4>

<p>
<pre>
   chown(uid, gid, node...)
      uid : Int
      gid : Int
      node : Node or Channel
   chown(uid, node...)
      uid : Int
      node : Node or Channel
   raises RuntimeException
</pre>
<p>
The <tt>chown</tt> function changes the user and group id of the file.
If the <tt>gid</tt> is not specified, it is not changed. If either
id is -1, that id is not changed.
<h4><a name="section_171">umask</a></h4>

<p>
<pre>
    $(umask mode) : Int
       mode : Int
    raises RuntimeException
</pre>
<p>
Sets the file mode creation mask.
The previous mask is returned.
This value is not scoped, changes have global effect.
<h4><a name="section_172">digest</a></h4>

<p>
<pre>
     $(digest files) : String Array
        file : File Array
     raises RuntimeException

     $(digest-optional files) : String Array
        file : File Array
</pre>
<p>
The <tt>digest</tt> and <tt>digest-optional</tt> functions compute MD5 digests
of files. The <tt>digest</tt> function raises an exception if a file
does no exist. The <tt>digest-optional</tt> returns <tt>false</tt> if a
file does no exist. MD5 digests are cached.
<h4><a name="section_173">find-in-path</a></h4>

<p>
<pre>
    $(find-in-path path, files) : File Array
       path : Dir Array
       files : String Array
    raises RuntimeException

    $(find-in-path-optional path, files) : File Array
</pre>
<p>
The <tt>find-in-path</tt> function searches for the files in a search
path. Only the tail of the filename is significant. The <tt>find-in-path</tt>
function raises an exception if the file can't be found.
The <tt>find-in-path-optional</tt> function silently removes
files that can't be found.
<h4><a name="section_174">digest-path</a></h4>

<p>
<pre>
    $(digest-in-path path, files) : String/File Array
       path : Dir Array
       files : String Array
    raises RuntimeException

    $(digest-in-path-optional path, files) : String/File Array
</pre>
<p>
The <tt>digest-in-path</tt> function searches for the files in a search
path and returns the file and digest for each file. Only the tail of the
filename is significant. The <tt>digest-in-path</tt> function raises an exception
if the file can't be found. The <tt>digest-in-path-optional</tt>
function silently removes elements that can't be found.
<h4><a name="section_175">rehash</a></h4>

<p>
<pre>
    rehash()
</pre>
<p>
The <tt>rehash</tt> function resets all search paths.
<h4><a name="section_176">vmount</a></h4>

<p>
<pre>
    vmount(src, dst)
       src, dst : Dir
    vmount(flags, src, dst)
       flags : String
       src, dst : Dir
</pre>
<p>
&ldquo;Mount&rdquo; the <tt>src</tt> directory on the <tt>dst</tt> directory. This is
a virtual mount, changing the behavior of the <tt>$(file ...)</tt> function.
When the <tt>$(file str)</tt> function is used, the resulting file is taken
relative to the <tt>src</tt> directory if the file exists. Otherwise, the
file is relative to the current directory.
<p>
The main purpose of the <tt>vmount</tt> function is to support multiple
builds with separate configurations or architectures.
<p>
The options are as follows.
<dl compact>
<dt>l</dt>
<dd> Create symbolic links to files in the <tt>src</tt> directory.
</dd>
<dt>c</dt>
<dd> Copy files from the <tt>src</tt> directory.
</dd>
</dl>
<p>
Mount operations are scoped.
<h4><a name="section_177">add-project-directories</a></h4>

<p>
<pre>
    add-project-directories(dirs)
       dirs : Dir Array
</pre>
<p>
Add the directories to the set of directories that omake considers to be part
of the project. This is mainly used to avoid omake complaining that the
current directory is not part of the project.
<h4><a name="section_178">remove-project-directories</a></h4>

<p>
<pre>
    remove-project-directories(dirs)
       dirs : Dir Array
</pre>
<p>
Removed the directories from the set of directories that omake considers to be part
of the project. This is mainly used to cancel a <tt>.SUBDIRS</tt> from including
a directory if it is determined that the directory does not need to be compiled.
<h4><a name="section_179">test</a></h4>

<p>
<pre>
   test(exp) : Bool
      exp : String Sequence
</pre>
<p>
The <em>expression</em>
grammar is as follows:
<p>
<ul compact>
<li><tt>!</tt> <em>expression</em> : <em>expression</em> is not true
</li>
<li><em>expression1</em>
<tt>-a</tt> <em>expression2</em> : both expressions are true
</li>
<li><em>expression1</em>
<tt>-o</tt> <em>expression2</em> : at least one expression is true
</li>
<li><tt>(</tt> <em>expression</em>
<tt>)</tt> : <em>expression</em> is true
</li>
</ul>
<p>
The base expressions are:
<p>
<ul compact>
<li><tt>-n</tt> <em>string</em> : The <em>string</em> has nonzero length
</li>
<li><tt>-z</tt> <em>string</em> : The <em>string</em> has zero length
</li>
<li><em>string</em>
<tt>=</tt> <em>string</em> : The strings are equal
</li>
<li><em>string</em>
<tt>!=</tt> <em>string</em> : The strings are not equal
<p>
</li>
<li><em>int1</em>
<tt>-eq</tt> <em>int2</em> : The integers are equal
</li>
<li><em>int1</em>
<tt>-ne</tt> <em>int2</em> : The integers are not equal
</li>
<li><em>int1</em>
<tt>-gt</tt> <em>int2</em> : <em>int1</em> is larger than <em>int2</em>
</li>
<li><em>int1</em>
<tt>-ge</tt> <em>int2</em> : <em>int2</em> is not larger than <em>int1</em>
</li>
<li><em>int1</em>
<tt>-lt</tt> <em>int2</em> : <em>int1</em> is smaller than <em>int2</em>
</li>
<li><em>int1</em>
<tt>-le</tt> <em>int2</em> : <em>int1</em> is not larger than <em>int2</em>
<p>
</li>
<li><em>file1</em>
<tt>-ef</tt> <em>file2</em> : On Unix, <em>file1</em> and <em>file2</em> have the
same device and inode number.
On Win32, <em>file1</em>
and <em>file2</em>
have the
same name.
</li>
<li><em>file1</em>
<tt>-nt</tt> <em>file2</em> : <em>file1</em> is newer than <em>file2</em>
</li>
<li><em>file1</em>
<tt>-ot</tt> <em>file2</em> : <em>file1</em> is older than <em>file2</em>
<p>
</li>
<li><tt>-b</tt> <em>file</em> : The file is a block special file
</li>
<li><tt>-c</tt> <em>file</em> : The file is a character special file
</li>
<li><tt>-d</tt> <em>file</em> : The file is a directory
</li>
<li><tt>-e</tt> <em>file</em> : The file exists
</li>
<li><tt>-f</tt> <em>file</em> : The file is a normal file
</li>
<li><tt>-g</tt> <em>file</em> : The set
<tt>-group</tt><tt>-id</tt> bit is set on the file
</li>
<li><tt>-G</tt> <em>file</em> : The file's group is the current effective group
</li>
<li><tt>-h</tt> <em>file</em> : The file is a symbolic link (also
<tt>-L</tt>)
</li>
<li><tt>-k</tt> <em>file</em> : The file's sticky bit is set
</li>
<li><tt>-L</tt> <em>file</em> : The file is a symbolic link (also
<tt>-h</tt>)
</li>
<li><tt>-O</tt> <em>file</em> : The file's owner is the current effective user
</li>
<li><tt>-p</tt> <em>file</em> : The file is a named pipe
</li>
<li><tt>-r</tt> <em>file</em> : The file is readable
</li>
<li><tt>-s</tt> <em>file</em> : The file is empty
</li>
<li><tt>-S</tt> <em>file</em> : The file is a socket
</li>
<li><tt>-u</tt> <em>file</em> : The set
<tt>-user</tt><tt>-id</tt> bit is set on the file
</li>
<li><tt>-w</tt> <em>file</em> : The file is writable
</li>
<li><tt>-x</tt> <em>file</em> : The file is executable
</li>
</ul>
<p>
A <em>string</em>
is any sequence of characters; leading <tt>-</tt> characters are allowed.
<p>
An <em>int</em>
is a <em>string</em>
that can be interpreted as an integer. Unlike traditional
versions of the test program, the leading characters may specify an arity. The
prefix <tt>0b</tt> means the numbers is in binary; the prefix <tt>0o</tt> means
the number is in octal; the prefix <tt>0x</tt> means the number is in hexadecimal.
An <em>int</em>
can also be specified as <tt>-l</tt> <em>string</em>,
which evaluates to the length of
the <em>string</em>.
<p>
A <em>file</em>
is a <em>string</em>
that represents the name of a file.
<h4><a name="section_180">find</a></h4>

<p>
<pre>
   find(exp) : Node Array
      exp : String Sequence
</pre>
<p>
The <tt>find</tt> function searches a directory recursively, returning the
files for which the expression evaluates to true.
<p>
The expression argument uses the same syntax as the <tt>test</tt> function,
with the following exceptions.
<p>
<ol compact>
<li value =1>The expression may begin with a directory. If not specified, the current
directory is searched.
</li>
<li value =2>The <tt>{}</tt> string expands to the current file being examined.
</li>
</ol>
<p>
The syntax of the expression is the same as <tt>test</tt>, with the following
additions.
<p>
<ul compact>
<li><tt>-name</tt> <em>string</em> : The current file matches the regular expression.
</li>
</ul>
<h2><a name="section_181">IO functions</a></h2>

<h4><a name="section_182">Standard channels</a></h4>

<p>
The following variables define the standard channels.
<p>
<dl compact>
<dt>stdin</dt>
<dd>
<p>
<pre>
stdin : InChannel
</pre>
<p>
The standard input channel, open for reading.
<p>
</dd>
<dt>stdout</dt>
<dd>
<pre>
stdout : OutChannel
</pre>
<p>
The standard output channel, open for writing.
<p>
</dd>
<dt>stderr</dt>
<dd>
<pre>
stderr : OutChannel
</pre>
<p>
The standard error channel, open for writing.
</dd>
</dl>
<h4><a name="section_183">fopen</a></h4>

<p>
The <tt>fopen</tt> function opens a file for reading or writing.
<p>
<pre>
   $(fopen file, mode) : Channel
      file : File
      mode : String
</pre>
<p>
The <tt>file</tt> is the name of the file to be opened.
The <tt>mode</tt> is a combination of the following characters.
<dl compact>
<dt>r</dt>
<dd> Open the file for reading; it is an error if the file does not exist.
</dd>
<dt>w</dt>
<dd> Open the file for writing; the file is created if it does not exist.
</dd>
<dt>a</dt>
<dd> Open the file in append mode; the file is created if it does not exist.
</dd>
<dt>+</dt>
<dd> Open the file for both reading an writing.
</dd>
<dt>t</dt>
<dd> Open the file in text mode (default).
</dd>
<dt>b</dt>
<dd> Open the file in binary mode.
</dd>
<dt>n</dt>
<dd> Open the file in nonblocking mode.
</dd>
<dt>x</dt>
<dd> Fail if the file already exists.
</dd>
</dl>
<p>
Binary mode is not significant on Unix systems, where
text and binary modes are equivalent.
<h4><a name="section_184">close</a></h4>

<p>
<pre>
    $(close channel...)
       channel : Channel
</pre>
<p>
The <tt>close</tt> function closes a file that was previously opened
with <tt>fopen</tt>.
<h4><a name="section_185">read</a></h4>

<p>
<pre>
   $(read channel, amount) : String
      channel : InChannel
      amount  : Int
   raises RuntimeException
</pre>
<p>
The <tt>read</tt> function reads up to <tt>amount</tt>
bytes from an input channel, and returns
the data that was read. If an end-of-file condition is reached,
the function raises a <tt>RuntimeException</tt> exception.
<h4><a name="section_186">write</a></h4>

<p>
<pre>
   $(write channel, buffer, offset, amount) : String
      channel : OutChannel
      buffer  : String
      offset  : Int
      amount  : Int
   $(write channel, buffer) : String
      channel : OutChannel
      buffer  : String
   raises RuntimeException
</pre>
<p>
In the 4-argument form, the <tt>write</tt> function writes
bytes to the output channel <tt>channel</tt> from the <tt>buffer</tt>,
starting at position <tt>offset</tt>. Up to <tt>amount</tt> bytes
are written. The function returns the number of bytes that were
written.
<p>
The 3-argument form is similar, but the <tt>offset</tt> is 0.
<p>
In the 2-argument form, the <tt>offset</tt> is 0, and the <tt>amount</tt>
if the length of the <tt>buffer</tt>.
<p>
If an end-of-file condition is reached,
the function raises a <tt>RuntimeException</tt> exception.
<h4><a name="section_187">lseek</a></h4>

<p>
<pre>
    $(lseek channel, offset, whence) : Int
       channel : Channel
       offset  : Int
       whence  : String
    raises RuntimeException
</pre>
<p>
The <tt>lseek</tt> function repositions the offset of the
channel <tt>channel</tt> according to the <tt>whence</tt> directive, as
follows:
<p>
<dl compact>
<dt>SEEK_SET</dt>
<dd> The offset is set to <tt>offset</tt>.
</dd>
<dt>SEEK_CUR</dt>
<dd> The offset is set to its current position plus <tt>offset</tt> bytes.
</dd>
<dt>SEEK_END</dt>
<dd> The offset is set to the size of the file plus <tt>offset</tt> bytes.
</dd>
</dl>
<p>
The <tt>lseek</tt> function returns the new position in the file.
<h4><a name="section_188">rewind</a></h4>

<p>
<pre>
   rewind(channel...)
      channel : Channel
</pre>
<p>
The <tt>rewind</tt> function set the current file position to the
beginning of the file.
<h4><a name="section_189">tell</a></h4>

<p>
<pre>
    $(tell channel...) : Int...
       channel : Channel
    raises RuntimeException
</pre>
<p>
The <tt>tell</tt> function returns the current position of the <tt>channel</tt>.
<h4><a name="section_190">flush</a></h4>

<p>
<pre>
   $(flush channel...)
      channel : OutChannel
</pre>
<p>
The <tt>flush</tt> function can be used only on files that are open for writing.
It flushes all pending data to the file.
<h4><a name="section_191">dup</a></h4>

<p>
<pre>
    $(dup channel) : Channel
       channel : Channel
    raises RuntimeException
</pre>
<p>
The <tt>dup</tt> function returns a new channel referencing the
same file as the argument.
<h4><a name="section_192">dup2</a></h4>

<p>
<pre>
   dup2(channel1, channel2)
      channel1 : Channel
      channel2 : Channel
   raises RuntimeException
</pre>
<p>
The <tt>dup2</tt> function causes <tt>channel2</tt> to refer to the same
file as <tt>channel1</tt>.
<h4><a name="section_193">set-nonblock</a></h4>

<p>
<pre>
   set-nonblock-mode(mode, channel...)
      channel : Channel
      mode : String
</pre>
<p>
The <tt>set-nonblock-mode</tt> function sets the nonblocking flag on the
given channel. When IO is performed on the channel, and the operation
cannot be completed immediately, the operations raises a <tt>RuntimeException</tt>.
<h4><a name="section_194">set-close-on-exec-mode</a></h4>

<p>
<pre>
   set-close-on-exec-mode(mode, channel...)
      channel : Channel
      mode : String
   raises RuntimeException
</pre>
<p>
The <tt>set-close-on-exec-mode</tt> function sets the close-on-exec
flags for the given channels. If the close-on-exec flag is set, the channel
is not inherited by child processes. Otherwise it is.
<h4><a name="section_195">pipe</a></h4>

<p>
<pre>
   $(pipe) : Pipe
   raises RuntimeException
</pre>
<p>
The <tt>pipe</tt> function creates a <tt>Pipe</tt> object, which has two
fields. The <tt>read</tt> field is a channel that is opened for
reading, and the <tt>write</tt> field is a channel that is opened
for writing.
<h4><a name="section_196">mkfifo</a></h4>

<p>
<pre>
   mkfifo(mode, node...)
      mode : Int
      node : Node
</pre>
<p>
The <tt>mkfifo</tt> function creates a named pipe.
<h4><a name="section_197">select</a></h4>

<p>
<pre>
   $(select rfd..., wfd..., wfd..., timeout) : Select
      rfd : InChannel
      wfd : OutChannel
      efd : Channel
      timeout : float
   raises RuntimeException
</pre>
<p>
The <tt>select</tt> function polls for possible IO on a set of channels.
The <tt>rfd</tt> are a sequence of channels for reading, <tt>wfd</tt> are a
sequence of channels for writing, and <tt>efd</tt> are a sequence of
channels to poll for error conditions. The <tt>timeout</tt> specifies
the maximum amount of time to wait for events.
<p>
On successful return, <tt>select</tt> returns a <tt>Select</tt> object,
which has the following fields:
<dl compact>
<dt>read</dt>
<dd> An array of channels available for reading.
</dd>
<dt>write</dt>
<dd> An array of channels available for writing.
</dd>
<dt>error</dt>
<dd> An array of channels on which an error has occurred.
</dd>
</dl>
<h4><a name="section_198">lockf</a></h4>

<p>
<pre>
    lockf(channel, command, len)
       channel : Channel
       command : String
       len : Int
    raises RuntimeException
</pre>
<p>
The <tt>lockf</tt> function places a lock on a region of the channel.
The region starts at the current position and extends for <tt>len</tt>
bytes.
<p>
The possible values for <tt>command</tt> are the following.
<dl compact>
<dt>F_ULOCK</dt>
<dd> Unlock a region.
</dd>
<dt>F_LOCK</dt>
<dd> Lock a region for writing; block if already locked.
</dd>
<dt>F_TLOCK</dt>
<dd> Lock a region for writing; fail if already locked.
</dd>
<dt>F_TEST</dt>
<dd> Test a region for other locks.
</dd>
<dt>F_RLOCK</dt>
<dd> Lock a region for reading; block if already locked.
</dd>
<dt>F_TRLOCK</dt>
<dd> Lock a region for reading; fail is already locked.
</dd>
</dl>
<h4><a name="section_199">InetAddr</a></h4>

<p>
The <tt>InetAddr</tt> object describes an Internet address.
It contains the following fields.
<p>
<dl compact>
<dt>addr</dt>
<dd> <tt>String</tt>: the Internet address.
</dd>
<dt>port</dt>
<dd> <tt>Int</tt>: the port number.
</dd>
</dl>
<p>
<h4><a name="section_200">Host</a></h4>

<p>
A <tt>Host</tt> object contains the following fields.
<p>
<dl compact>
<dt>name</dt>
<dd> <tt>String</tt>: the name of the host.
</dd>
<dt>aliases</dt>
<dd> <tt>String Array</tt>: other names by which the host is known.
</dd>
<dt>addrtype</dt>
<dd> <tt>String</tt>: the preferred socket domain.
</dd>
<dt>addrs</dt>
<dd> <tt>InetAddr Array</tt>: an array of Internet addresses belonging to the host.
</dd>
</dl>
<p>
<h4><a name="section_201">gethostbyname</a></h4>

<p>
<pre>
   $(gethostbyname host...) : Host...
      host : String
   raises RuntimeException
</pre>
<p>
The <tt>gethostbyname</tt> function returns a <tt>Host</tt> object
for the specified host. The <tt>host</tt> may specify a domain name
or an Internet address.
<p>
<h4><a name="section_202">Protocol</a></h4>

<p>
The <tt>Protocol</tt> object represents a protocol entry.
It has the following fields.
<p>
<dl compact>
<dt>name</dt>
<dd> <tt>String</tt>: the canonical name of the protocol.
</dd>
<dt>aliases</dt>
<dd> <tt>String Array</tt>: aliases for the protocol.
</dd>
<dt>proto</dt>
<dd> <tt>Int</tt>: the protocol number.
</dd>
</dl>
<p>
<h4><a name="section_203">getprotobyname</a></h4>

<p>
<pre>
   $(getprotobyname name...) : Protocol...
      name : Int or String
   raises RuntimeException
</pre>
<p>
The <tt>getprotobyname</tt> function returns a <tt>Protocol</tt> object for the
specified protocol. The <tt>name</tt> may be a protocol name, or a
protocol number.
<h4><a name="section_204">Service</a></h4>

<p>
The <tt>Service</tt> object represents a network service.
It has the following fields.
<p>
<dl compact>
<dt>name</dt>
<dd> <tt>String</tt>: the name of the service.
</dd>
<dt>aliases</dt>
<dd> <tt>String Array</tt>: aliases for the service.
</dd>
<dt>port</dt>
<dd> <tt>Int</tt>: the port number of the service.
</dd>
<dt>proto</dt>
<dd> <tt>Protocol</tt>: the protocol for the service.
</dd>
</dl>
<p>
<h4><a name="section_205">getservbyname</a></h4>

<p>
<pre>
   $(getservbyname service...) : Service...
      service : String or Int
   raises RuntimeException
</pre>
<p>
The <tt>getservbyname</tt> function gets the information for a network service.
The <tt>service</tt> may be specified as a service name or number.
<h4><a name="section_206">socket</a></h4>

<p>
<pre>
   $(socket domain, type, protocol) : Channel
      domain : String
      type : String
      protocol : String
   raises RuntimeException
</pre>
<p>
The <tt>socket</tt> function creates an unbound socket.
<p>
The possible values for the arguments are as follows.
<p>
The <tt>domain</tt> may have the following values.
<dl compact>
<dt>PF_UNIX or unix</dt>
<dd> Unix domain, available only on Unix systems.
</dd>
<dt>PF_INET or inet</dt>
<dd> Internet domain, IPv4.
</dd>
<dt>PF_INET6 or inet6</dt>
<dd> Internet domain, IPv6.
</dd>
</dl>
<p>
The <tt>type</tt> may have the following values.
<dl compact>
<dt>SOCK_STREAM or stream</dt>
<dd> Stream socket.
</dd>
<dt>SOCK_DGRAM or dgram</dt>
<dd> Datagram socket.
</dd>
<dt>SOCK_RAW or raw</dt>
<dd> Raw socket.
</dd>
<dt>SOCK_SEQPACKET or seqpacket</dt>
<dd> Sequenced packets socket
</dd>
</dl>
<p>
The <tt>protocol</tt> is an <tt>Int</tt> or <tt>String</tt> that specifies
a protocol in the protocols database.
<h4><a name="section_207">bind</a></h4>

<p>
<pre>
   bind(socket, host, port)
      socket : InOutChannel
      host : String
      port : Int
   bind(socket, file)
      socket : InOutChannel
      file : File
   raise RuntimeException
</pre>
<p>
The <tt>bind</tt> function binds a socket to an address.
<p>
The 3-argument form specifies an Internet connection, the <tt>host</tt> specifies a host name
or IP address, and the <tt>port</tt> is a port number.
<p>
The 2-argument form is for <tt>Unix</tt> sockets. The <tt>file</tt> specifies the filename
for the address.
<h4><a name="section_208">listen</a></h4>

<p>
<pre>
   listen(socket, requests)
      socket : InOutChannel
      requests : Int
   raises RuntimeException
</pre>
<p>
The <tt>listen</tt> function sets up the socket for receiving up to <tt>requests</tt> number
of pending connection requests.
<h4><a name="section_209">accept</a></h4>

<p>
<pre>
   $(accept socket) : InOutChannel
      socket : InOutChannel
   raises RuntimeException
</pre>
<p>
The <tt>accept</tt> function accepts a connection on a socket.
<h4><a name="section_210">connect</a></h4>

<p>
<pre>
    connect(socket, addr, port)
       socket : InOutChannel
       addr : String
       port : int
    connect(socket, name)
       socket : InOutChannel
       name : File
    raise RuntimeException
</pre>
<p>
The <tt>connect</tt> function connects a socket to a remote address.
<p>
The 3-argument form specifies an Internet connection.
The <tt>addr</tt> argument is the Internet address of the remote host,
specified as a domain name or IP address. The <tt>port</tt> argument
is the port number.
<p>
The 2-argument form is for Unix sockets. The <tt>name</tt> argument
is the filename of the socket.
<h4><a name="section_211">getchar</a></h4>

<p>
<pre>
    $(getc) : String
    $(getc file) : String
       file : InChannel or File
    raises RuntimeException
</pre>
<p>
The <tt>getc</tt> function returns the next character of a file.
If the argument is not specified, <tt>stdin</tt> is used as input.
If the end of file has been reached, the function returns <tt>false</tt>.
<h4><a name="section_212">gets</a></h4>

<p>
<pre>
   $(gets) : String
   $(gets channel) : String
      channel : InChannel or File
   raises RuntimeException
</pre>
<p>
The <tt>gets</tt> function returns the next line from a file.
The function returns the empty string if the end of file has been reached.
The line terminator is removed.
<h4><a name="section_213">fgets</a></h4>

<p>
<pre>
   $(fgets) : String
   $(fgets channel) : String
      channel : InChannel or File
   raises RuntimeException
</pre>
<p>
The <tt>fgets</tt> function returns the next line from a file that has been
opened for reading with <tt>fopen</tt>. The function returns the empty string
if the end of file has been reached. The returned string is returned as
literal data. The line terminator is not removed.
<h4><a name="section_214">Printing functions</a></h4>

<p>
Output is printed with the <tt>print</tt> and <tt>println</tt> functions.
The <tt>println</tt> function adds a terminating newline to the value being
printed, the <tt>print</tt> function does not.
<p>
<pre>
    fprint(&lt;file&gt;, &lt;string&gt;)
    print(&lt;string&gt;)
    eprint(&lt;string&gt;)
    fprintln(&lt;file&gt;, &lt;string&gt;)
    println(&lt;string&gt;)
    eprintln(&lt;string&gt;)
</pre>
<p>
The <tt>fprint</tt> functions print to a file that has been previously opened with
<tt>fopen</tt>. The <tt>print</tt> functions print to the standard output channel, and
the <tt>eprint</tt> functions print to the standard error channel.
<h4><a name="section_215">Value printing functions</a></h4>

<p>
Values can be printed with the <tt>printv</tt> and <tt>printvln</tt> functions.
The <tt>printvln</tt> function adds a terminating newline to the value being
printed, the <tt>printv</tt> function does not.
<p>
<pre>
    fprintv(&lt;file&gt;, &lt;string&gt;)
    printv(&lt;string&gt;)
    eprintv(&lt;string&gt;)
    fprintvln(&lt;file&gt;, &lt;string&gt;)
    printvln(&lt;string&gt;)
    eprintvln(&lt;string&gt;)
</pre>
<p>
The <tt>fprintv</tt> functions print to a file that has been previously opened with
<tt>fopen</tt>. The <tt>printv</tt> functions print to the standard output channel, and
the <tt>eprintv</tt> functions print to the standard error channel.
<h2><a name="section_216">Higher-level IO functions</a></h2>

<p>
<h4><a name="section_217">Regular expressions</a></h4>

<p>
Many of the higher-level functions use regular expressions.
Regular expressions are defined by strings with syntax nearly identical
to <em>awk</em>(1).
<p>
Strings may contain the following character constants.
<p>
<ul compact>
<li><tt>\\</tt> : a literal backslash.
</li>
<li><tt>\a</tt> : the alert character <tt>^G</tt>.
</li>
<li><tt>\b</tt> : the backspace character <tt>^H</tt>.
</li>
<li><tt>\f</tt> : the formfeed character <tt>^L</tt>.
</li>
<li><tt>
</tt>: the newline character <tt>^J</tt>.
</li>
<li><tt>\r</tt> : the carriage return character <tt>^M</tt>.
</li>
<li><tt>\t</tt> : the tab character <tt>^I</tt>.
</li>
<li><tt>\v</tt> : the vertical tab character.
</li>
<li><tt>\xhh...</tt> : the character represented by the string
of hexadecimal digits <tt>h</tt>. All valid hexadecimal digits
following the sequence are considered to be part of the sequence.
</li>
<li><tt>\ddd</tt> : the character represented by 1, 2, or 3 octal
digits.
</li>
</ul>
<p>
Regular expressions are defined using the special characters <tt>.\^$[(){}*?</tt>+.
<p>
<ul compact>
<li><tt>c</tt> : matches the literal character <tt>c</tt> if <tt>c</tt> is not
a special character.
</li>
<li><tt>\c</tt> : matches the literal character <tt>c</tt>, even if <tt>c</tt>
is a special character.
</li>
<li><tt>.</tt> : matches any character, including newline.
</li>
<li><tt>^</tt> : matches the beginning of a line.
</li>
<li><tt>$</tt> : matches the end of line.
</li>
<li><tt>[abc...]</tt> : matches any of the characters <tt>abc...</tt>
</li>
<li><tt>[^abc...]</tt> : matches any character except <tt>abc...</tt>
</li>
<li><tt>r1|r2</tt> : matches either <tt>r1</tt> or <tt>r2</tt>.
</li>
<li><tt>r1r2</tt> : matches <tt>r1</tt> and then <tt>r2</tt>.
</li>
<li><tt>r</tt>+ : matches one or more occurrences of <tt>r</tt>.
</li>
<li><tt>r*</tt> : matches zero or more occurrences of <tt>r</tt>.
</li>
<li><tt>r?</tt> : matches zero or one occurrence of <tt>r</tt>.
</li>
<li><tt>(r)</tt> : parentheses are used for grouping; matches <tt>r</tt>.
</li>
<li><tt>\(r\)</tt> : also defines grouping, but the expression matched
within the parentheses is available to the output processor
through one of the variables <tt>$1</tt>, <tt>$2</tt>, ...
</li>
<li><tt>r{n}</tt> : matches exactly <tt>n</tt> occurrences of <tt>r</tt>.
</li>
<li><tt>r{n,}</tt> : matches <tt>n</tt> or more occurrences of <tt>r</tt>.
</li>
<li><tt>r{n,m}</tt> : matches at least <tt>n</tt> occurrences of <tt>r</tt>,
and no more than <tt>m</tt> occurrences.
</li>
<li><tt>\y</tt>: matches the empty string at either the beginning or
end of a word.
</li>
<li><tt>\B</tt>: matches the empty string within a word.
</li>
<li><tt>\&lt;</tt>: matches the empty string at the beginning of a word.
</li>
<li><tt>\&gt;</tt>: matches the empty string at the end of a word.
</li>
<li><tt>\w</tt>: matches any character in a word.
</li>
<li><tt>\W</tt>: matches any character that does not occur within a word.
</li>
<li><tt>\`</tt>: matches the empty string at the beginning of a file.
</li>
<li><tt>\'</tt>: matches the empty string at the end of a file.
</li>
</ul>
<p>
Character classes can be used to specify character sequences
abstractly. Some of these sequences can change depending on your LOCALE.
<p>
<ul compact>
<li><tt>[:alnum:]</tt> Alphanumeric characters.
</li>
<li><tt>[:alpha:]</tt> Alphabetic characters.
</li>
<li><tt>[:lower:]</tt> Lowercase alphabetic characters.
</li>
<li><tt>[:upper:]</tt> Uppercase alphabetic characters.
</li>
<li><tt>[:cntrl:]</tt> Control characters.
</li>
<li><tt>[:digit:]</tt> Numeric characters.
</li>
<li><tt>[:xdigit:]</tt> Numeric and hexadecimal characters.
</li>
<li><tt>[:graph:]</tt> Characters that are printable and visible.
</li>
<li><tt>[:print:]</tt> Characters that are printable, whether they are visible or not.
</li>
<li><tt>[:punct:]</tt> Punctuation characters.
</li>
<li><tt>[:blank:]</tt> Space or tab characters.
</li>
<li><tt>[:space:]</tt> Whitespace characters.
</li>
</ul>
<h4><a name="section_218">cat</a></h4>

<p>
<pre>
    cat(files) : Sequence
       files : File or InChannel Sequence
</pre>
<p>
The <tt>cat</tt> function concatenates the output from multiple files
and returns it as a string.
<h4><a name="section_219">grep</a></h4>

<p>
<pre>
   grep(pattern) : String  # input from stdin, default options
      pattern : String
   grep(pattern, files) : String  # default options
      pattern : String
      files   : File Sequence
   grep(options, pattern, files) : String
     options : String
     pattern : String
     files   : File Sequence
</pre>
<p>
The <tt>grep</tt> function searches for occurrences of a regular
expression <tt>pattern</tt> in a set of files, and prints lines that match.
This is like a highly-simplified version of <em>grep</em>(1).
<p>
The options are:
<dl compact>
<dt>q</dt>
<dd> If specified, the output from <tt>grep</tt> is not displayed.
</dd>
<dt>n</dt>
<dd> If specified, output lines include the filename.
</dd>
</dl>
<p>
The <tt>pattern</tt> is a regular expression.
<p>
If successful (<tt>grep</tt> found a match), the function returns <tt>true</tt>.
Otherwise, it returns <tt>false</tt>.
<h4><a name="section_220">awk</a></h4>

<p>
<pre>
   awk(input-files)
   case pattern1:
      body1
   case pattern2:
      body2
   ...
   default:
      bodyd
</pre>
<p>
The <tt>awk</tt> function provides input processing similar to <em>awk</em>(1),
but more limited. The function takes filename arguments. If called with no
arguments, the input is taken from <tt>stdin</tt>. If arguments are provided,
each specifies an <tt>InChannel</tt>, or the name of a file for input.
Output is always to <tt>stdout</tt>.
<p>
The variables <tt>RS</tt> and <tt>FS</tt> define record and field separators
as regular expressions.
The default value of <tt>RS</tt> is the regular expression <tt>\r|
|\r
</tt>.
The default value of <tt>FS</tt> is the regular expression <tt>[ \t]</tt>+.
<p>
The <tt>awk</tt> function operates by reading the input one record at a time,
and processing it according to the following algorithm.
<p>
For each line,
the record is first split into fields using the field separator <tt>FS</tt>, and
the fields are bound to the variables <tt>$1, $2, ...</tt>. The variable
<tt>$0</tt> is defined to be the entire line, and <tt>$*</tt> is an array
of all the field values. The <tt>$(NF)</tt> variable is defined to be the number
of fields.
<p>
Next, the cases are evaluated in order.
For each case, if the regular expression <tt>pattern_i</tt> matches the record <tt>$0</tt>,
then <tt>body_i</tt> is evaluated. If the body ends in an <tt>export</tt>, the state
is passed to the next clause. Otherwise the value is discarded. If the regular
expression contains <tt>\(r\)</tt> expression, those expression override the
fields <tt>$1, $2, ...</tt>.
<p>
For example, here is an <tt>awk</tt> function to print the text between two
delimiters <tt>\begin{&lt;name&gt;}</tt> and <tt>\end{&lt;name&gt;}</tt>, where the <tt>&lt;name&gt;</tt>
must belong to a set passed as an argument to the <tt>filter</tt> function.
<p>
<pre>
    filter(names) =
       print = false

       awk(Awk.in)
       case $"^\\end\{\([:alpha:]+\)\}"
          if $(mem $1, $(names))
             print = false
             export
          export
       default
          if $(print)
             println($0)
       case $"^\\begin\{\([:alpha:]+\)\}"
          print = $(mem $1, $(names))
          export
</pre>
<p>
Note, if you want to redirect the output to a file, the easiest way is to
redefine the <tt>stdout</tt> variable. The <tt>stdout</tt> variable is scoped the
same way as other variables, so this definition does not affect the meaning of
<tt>stdout</tt> outside the <tt>filter</tt> function.
<p>
<pre>
    filter(names) =
        stdout = $(fopen file.out, w)
        awk(Awk.in)
           ...
        close(stdout)
</pre>
<h4><a name="section_221">fsubst</a></h4>

<p>
<pre>
   fsubst(files)
   case pattern1 [options]
      body1
   case pattern2 [options]
      body2
   ...
   default
      bodyd
</pre>
<p>
The <tt>fsubst</tt> function provides a <em>sed</em>(1)-like
substitution
function. Similar to <tt>awk</tt>, if <tt>fsubst</tt> is called with no
arguments, the input is taken from <tt>stdin</tt>. If arguments are provided,
each specifies an <tt>InChannel</tt>, or the name of a file for input.
<p>
The <tt>RS</tt> variable defines a regular expression that determines a record separator,
The default value of <tt>RS</tt> is the regular expression <tt>\r|
|\r
</tt>.
<p>
The <tt>fsubst</tt> function reads the file one record at a time.
<p>
For each record, the cases are evaluated in order. Each case defines
a substitution from a substring matching the <tt>pattern</tt> to
replacement text defined by the body.
<p>
Currently, there is only one option: <tt>g</tt>.
If specified, each clause specifies a global replacement,
and all instances of the pattern define a substitution.
Otherwise, the substitution is applied only once.
<p>
Output can be redirected by redefining the <tt>stdout</tt> variable.
<p>
For example, the following program replaces all occurrences of
an expression <tt>word.</tt> with its capitalized form.
<p>
<pre>
    section
       stdout = $(fopen Subst.out, w)
       fsubst(Subst.in)
       case $"\&lt;\([[:alnum:]]+\)\." g
          value $(capitalize $1).
       close(stdout)
</pre>
<h4><a name="section_222">Lexer</a></h4>

<p>
The <tt>Lexer</tt> object defines a facility for lexical analysis, similar to the
<em>lex</em>(1)
and <em>flex</em>(1)
programs.
<p>
In <tt>omake</tt>,
lexical analyzers can be constructed dynamically by extending
the <tt>Lexer</tt> class. A lexer definition consists of a set of directives specified
with method calls, and set of clauses specified as rules.
<p>
For example, consider the following lexer definition, which is intended
for lexical analysis of simple arithmetic expressions for a desktop
calculator.
<p>
<pre>
   lexer1. =
      extends $(Lexer)

      other: .
         eprintln(Illegal character: $* )
         lex()

      white: $"[[:space:]]+"
         lex()

      op: $"[-+*/()]"
         switch $*
         case +
            Token.unit($(loc), plus)
         case -
            Token.unit($(loc), minus)
         case *
            Token.unit($(loc), mul)
         case /
            Token.unit($(loc), div)
         case $"("
            Token.unit($(loc), lparen)
         case $")"
            Token.unit($(loc), rparen)

      number: $"[[:digit:]]+"
         Token.pair($(loc), exp, $(int $* ))

      eof: $"\'"
         Token.unit($(loc), eof)
</pre>
<p>
This program defines an object <tt>lexer1</tt> the extends the <tt>Lexer</tt>
object, which defines lexing environment.
<p>
The remainder of the definition consists of a set of clauses,
each with a method name before the colon; a regular expression
after the colon; and in this case, a body. The body is optional,
if it is not specified, the method with the given name should
already exist in the lexer definition.
<p>
<em>NB</em>
The clause that matches the <em>longest</em>
prefix of the input
is selected. If two clauses match the same input prefix, then the <em>last</em>
one is selected. This is unlike most standard lexers, but makes more sense
for extensible grammars.
<p>
The first clause matches any input that is not matched by the other clauses.
In this case, an error message is printed for any unknown character, and
the input is skipped. Note that this clause is selected only if no other
clause matches.
<p>
The second clause is responsible for ignoring white space.
If whitespace is found, it is ignored, and the lexer is called
recursively.
<p>
The third clause is responsible for the arithmetic operators.
It makes use of the <tt>Token</tt> object, which defines three
fields: a <tt>loc</tt> field that represents the source location;
a <tt>name</tt>; and a <tt>value</tt>.
<p>
The lexer defines the <tt>loc</tt> variable to be the location
of the current lexeme in each of the method bodies, so we can use
that value to create the tokens.
<p>
The <tt>Token.unit($(loc), name)</tt>
method constructs a new <tt>Token</tt> object with the given name,
and a default value.
<p>
The <tt>number</tt> clause matches nonnegative integer constants.
The <tt>Token.pair($(loc), name, value)</tt> constructs a token with the
given name and value.
<p>
Lexer object operate on <tt>InChannel</tt> objects.
The method <tt>lexer1.lex-channel(channel)</tt> reads the next
token from the channel argument.
<p>
<h4><a name="section_223">Lexer matching</a></h4>

<p>
During lexical analysis, clauses are selected by longest match.
That is, the clause that matches the longest sequence of input
characters is chosen for evaluation. If no clause matches, the
lexer raises a <tt>RuntimeException</tt>. If more than one clause
matches the same amount of input, the first one is chosen
for evaluation.
<p>
<h4><a name="section_224">Extending lexer definitions</a></h4>

<p>
Suppose we wish to augment the lexer example so that it ignores
comments. We will define comments as any text that begins with
the string <tt>(*</tt>, ends with <tt>*)</tt>, and comments may
be nested.
<p>
One convenient way to do this is to define a separate lexer
just to skip comments.
<p>
<pre>
   lex-comment. =
      extends $(Lexer)

      level = 0

      other: .
         lex()

      term: $"[*][)]"
         if $(not $(eq $(level), 0))
            level = $(sub $(level), 1)
            lex()

      next: $"[(][*]"
         level = $(add $(level), 1)
         lex()

      eof: $"\'"
         eprintln(Unterminated comment)
</pre>
<p>
This lexer contains a field <tt>level</tt> that keeps track of the nesting
level. On encountering a <tt>(*</tt> string, it increments the level,
and for <tt>*)</tt>, it decrements the level if nonzero, and continues.
<p>
Next, we need to modify our previous lexer to skip comments.
We can do this by extending the lexer object <tt>lexer1</tt>
that we just created.
<p>
<pre>
   lexer1. +=
      comment: $"[(][*]"
         lex-comment.lex-channel($(channel))
         lex()
</pre>
<p>
The body for the comment clause calls the <tt>lex-comment</tt> lexer when
a comment is encountered, and continues lexing when that lexer returns.
<p>
<h4><a name="section_225">Threading the lexer object</a></h4>

<p>
Clause bodies may also end with an <tt>export</tt> directive. In this case
the lexer object itself is used as the returned token. If used with
the <tt>Parser</tt> object below, the lexer should define the <tt>loc</tt>, <tt>name</tt>
and <tt>value</tt> fields in each <tt>export</tt> clause. Each time
the <tt>Parser</tt> calls the lexer, it calls it with the lexer returned
from the previous lex invocation.
<h4><a name="section_226">Parser</a></h4>

<p>
The <tt>Parser</tt> object provides a facility for syntactic analysis based
on context-free grammars.
<p>
<tt>Parser</tt> objects are specified as a sequence of directives,
specified with method calls; and productions, specified as rules.
<p>
For example, let's finish building the desktop calculator started
in the <tt>Lexer</tt> example.
<p>
<pre>
   parser1. =
      extends $(Parser)

      #
      # Use the main lexer
      #
      lexer = $(lexer1)

      #
      # Precedences, in ascending order
      #
      left(plus minus)
      left(mul div)
      right(uminus)

      #
      # A program
      #
      start(prog)

      prog: exp eof
         return $1

      #
      # Simple arithmetic expressions
      #
      exp: minus exp :prec: uminus
         neg($2)

      exp: exp plus exp
         add($1, $3)

      exp: exp minus exp
         sub($1, $3)

      exp: exp mul exp
         mul($1, $3)

      exp: exp div exp
         div($1, $3)

      exp: lparen exp rparen
         return $2
</pre>
<p>
Parsers are defined as extensions of the <tt>Parser</tt> class.
A <tt>Parser</tt> object must have a <tt>lexer</tt> field. The <tt>lexer</tt>
is not required to be a <tt>Lexer</tt> object, but it must provide
a <tt>lexer.lex()</tt> method that returns a token object with
<tt>name</tt> and <tt>value</tt> fields. For this example, we use the
<tt>lexer1</tt> object that we defined previously.
<p>
The next step is to define precedences for the terminal symbols.
The precedences are defined with the <tt>left</tt>, <tt>right</tt>,
and <tt>nonassoc</tt> methods in order of increasing precedence.
<p>
The grammar must have at least one start symbol, declared with
the <tt>start</tt> method.
<p>
Next, the productions in the grammar are listed as rules.
The name of the production is listed before the colon, and
a sequence of variables is listed to the right of the colon.
The body is a semantic action to be evaluated when the production
is recognized as part of the input.
<p>
In this example, these are the productions for the arithmetic
expressions recognized by the desktop calculator. The semantic
action performs the calculation. The variables <tt>$1, $2, ...</tt>
correspond to the values associated with each of the variables
on the right-hand-side of the production.
<p>
<h4><a name="section_227">Calling the parser</a></h4>

<p>
The parser is called with the <tt>$(parser1.parse-channel start, channel)</tt>
or <tt>$(parser1.parse-file start, file)</tt> functions. The <tt>start</tt>
argument is the start symbol, and the <tt>channel</tt> or <tt>file</tt>
is the input to the parser.
<p>
<h4><a name="section_228">Parsing control</a></h4>

<p>
The parser generator generates a pushdown automation based on LALR(1)
tables. As usual, if the grammar is ambiguous, this may generate shift/reduce
or reduce/reduce conflicts. These conflicts are printed to standard
output when the automaton is generated.
<p>
By default, the automaton is not constructed until the parser is
first used.
<p>
The <tt>build(debug)</tt> method forces the construction of the automaton.
While not required, it is wise to finish each complete parser with
a call to the <tt>build(debug)</tt> method. If the <tt>debug</tt> variable
is set, this also prints with parser table together with any conflicts.
<p>
The <tt>loc</tt> variable is defined within action bodies, and represents
the input range for all tokens on the right-hand-side of the production.
<p>
<h4><a name="section_229">Extending parsers</a></h4>

<p>
Parsers may also be extended by inheritance.
For example, let's extend the grammar so that it also recognizes
the <tt>&lt;&lt;</tt> and <tt>&gt;&gt;</tt> shift operations.
<p>
First, we extend the lexer so that it recognizes these tokens.
This time, we choose to leave <tt>lexer1</tt> intact, instead of
using the += operator.
<p>
<pre>
   lexer2. =
      extends $(lexer1)

      lsl: $"&lt;&lt;"
         Token.unit($(loc), lsl)

      asr: $"&gt;&gt;"
         Token.unit($(loc), asr)
</pre>
<p>
Next, we extend the parser to handle these new operators.
We intend that the bitwise operators have lower precedence
than the other arithmetic operators. The two-argument form
of the <tt>left</tt> method accomplishes this.
<p>
<pre>
   parser2. =
      extends $(parser1)

      left(plus, lsl lsr asr)

      lexer = $(lexer2)

      exp: exp lsl exp
         lsl($1, $3)

      exp: exp asr exp
         asr($1, $3)
</pre>
<p>
In this case, we use the new lexer <tt>lexer2</tt>, and we add productions
for the new shift operations.
<h4><a name="section_230">gettimeofday</a></h4>

<p>
<pre>
   $(gettimeofday) : Float
</pre>
<p>
The <tt>gettimeofday</tt> function returns the time of day in seconds
since January 1, 1970.
<h2><a name="section_231">Shell functions</a></h2>

<h4><a name="section_232">echo</a></h4>

<p>
The <tt>echo</tt> function prints a string.
<p>
<tt>$(echo &lt;args&gt;)</tt>
<tt>echo &lt;args&gt;</tt>
<h4><a name="section_233">jobs</a></h4>

<p>
The <tt>jobs</tt> function prints a list of jobs.
<p>
<tt>jobs</tt>
<h4><a name="section_234">cd</a></h4>

<p>
The <tt>cd</tt> function changes the current directory.
<p>
<pre>
    cd(dir)
       dir : Dir
</pre>
<p>
The <tt>cd</tt> function also supports a 2-argument form:
<p>
<pre>
    $(cd dir, e)
       dir : Dir
       e : expression
</pre>
<p>
In the two-argument form, expression <tt>e</tt> is evaluated
in the directory <tt>dir</tt>. The current directory is not
changed otherwise.
<p>
The behavior of the <tt>cd</tt> function can be changed with the
<tt>CDPATH</tt> variable, which specifies a search path for
directories. This is normally useful only in the <tt>osh</tt>
command interpreter.
<p>
<pre>
    CDPATH : Dir Sequence
</pre>
<p>
For example, the following will change directory to the first
directory <tt>./foo</tt>, <tt>~/dir1/foo</tt>, <tt>~/dir2/foo</tt>.
<p>
<pre>
    CDPATH[] =
       .
       $(HOME)/dir1
       $(HOME)/dir2
    cd foo
</pre>
<p>
<h4><a name="section_235">bg</a></h4>

<p>
The <tt>bg</tt> function places a job in the background.
<p>
<tt>bg &lt;pid...&gt;</tt>
<h4><a name="section_236">fg</a></h4>

<p>
The <tt>fg</tt> function brings a job to the foreground.
<p>
<tt>fg &lt;pid...&gt;</tt>
<h4><a name="section_237">stop</a></h4>

<p>
The <tt>stop</tt> function suspends a job.
<p>
<tt>stop &lt;pid...&gt;</tt>
<h4><a name="section_238">wait</a></h4>

<p>
The <tt>wait</tt> function waits for a job to finish.
If no process identifiers are given, the shell waits for
all jobs to complete.
<p>
<tt>wait &lt;pid...&gt;</tt>
<h4><a name="section_239">kill</a></h4>

<p>
The <tt>kill</tt> function signals a job.
<p>
<tt>kill [signal] &lt;pid...&gt;</tt>
<h4><a name="section_240">history</a></h4>

<p>
<pre>
    $(history-index) : Int
    $(history) : String Sequence
    history-file : File
    history-length : Int
</pre>
<p>
The history variables manage the command-line history in <tt>osh</tt>.
They have no effect
in <tt>omake</tt>.
<p>
The <tt>history-index</tt> variable is the current index into the command-line history.
The <tt>history</tt> variable is the current command-line history.
<p>
The <tt>history-file</tt> variable can be redefined if you want the command-line history
to be saved. The default value is <tt>~/.omake/osh_history</tt>.
<p>
The <tt>history-length</tt> variable can be redefined to specify the maximum number of
lines in the history that you want saved. The default value is <tt>100</tt>.
<p>
<h2><a name="section_241">Pervasives</a></h2>

<p>
<tt>Pervasives</tt> defines the objects that are defined in all
programs. The following objects are defined.
<p>
<h4><a name="section_242">Object</a></h4>

<p>
Parent objects: none.
<p>
The <tt>Object</tt> object is the root object.
Every class is a subclass of <tt>Object</tt>.
<p>
It provides the following fields:
<p>
<ul compact>
<li><tt>$(o.object-length)</tt>: the number of fields and methods in the object.
</li>
<li><tt>$(o.object-mem &lt;var&gt;)</tt>: returns <tt>true</tt> iff the <tt>&lt;var&gt;</tt> is a field
or method of the object.
</li>
<li><tt>$(o.object-add &lt;var&gt;, &lt;value&gt;)</tt>: adds the field to the object,
returning a new object.
</li>
<li><tt>$(o.object-find &lt;var&gt;)</tt>: fetches the field or method from the object;
it is equivalent to <tt>$(o.&lt;var&gt;)</tt>, but the variable can be non-constant.
</li>
<li><tt>$(o.object-map &lt;fun&gt;)</tt>: maps a function over the object. The function
should take two arguments; the first is a field name, the second is the
value of that field. The result is a new object constructed from the
values returned by the function.
</li>
<li><tt>o.object-foreach</tt>: the <tt>foreach</tt> form is equivalent to <tt>map</tt>,
but with altered syntax.
<p>
<pre>
   o.foreach(&lt;var1&gt;, &lt;var2&gt;)
      &lt;body&gt;
</pre>
<p>
For example, the following function prints all the fields of an
object <tt>o</tt>.
<p>
<pre>
   PrintObject(o) =
      o.foreach(v, x)
         println($(v) = $(x))
</pre>
<p>
The <tt>export</tt> form is valid in a <tt>foreach</tt> body. The following
function collects just the field names of an object.
<p>
<pre>
   FieldNames(o) =
      names =
      o.foreach(v, x)
         names += $(v)
         export
      return $(names)
</pre>
</li>
</ul>
<p>
<h4><a name="section_243">Map</a></h4>

<p>
Parent objects: <tt>Object</tt>.
<p>
A <tt>Map</tt> object is a dictionary from values to values. The <tt>&lt;key&gt;</tt>
values are restricted to simple values: integers, floating-point numbers,
strings, files, directories, and arrays of simple values.
<p>
The Map object provides the following methods.
<p>
<ul compact>
<li><tt>$(o.mem &lt;key&gt;)</tt>: returns <tt>true</tt> iff the <tt>&lt;key&gt;</tt> is defined
in the map.
</li>
<li><tt>$(o.add &lt;key&gt;, &lt;value&gt;)</tt>: adds the field to the map,
returning a new map.
</li>
<li><tt>$(o.find &lt;key&gt;)</tt>: fetches the field from the map.
</li>
<li><tt>$(o.map &lt;fun&gt;)</tt>: maps a function over the map. The function
should take two arguments; the first is a field name, the second is the
value of that field. The result is a new object constructed from the
values returned by the function.
</li>
<li><tt>o.foreach</tt>: the <tt>foreach</tt> form is equivalent to <tt>map</tt>,
but with altered syntax.
<p>
<pre>
   o.foreach(&lt;var1&gt;, &lt;var2&gt;)
      &lt;body&gt;
</pre>
<p>
For example, the following function prints all the fields of an
object <tt>o</tt>.
<p>
<pre>
   PrintObject(o) =
      o.foreach(v, x)
         println($(v) = $(x))
</pre>
<p>
The <tt>export</tt> form is valid in a <tt>foreach</tt> body. The following
function collects just the field names of the map.
<p>
<pre>
   FieldNames(o) =
      names =
      o.foreach(v, x)
         names += $(v)
         export
      return $(names)
</pre>
</li>
</ul>
<p>
There is also simpler syntax when the key is a string. The table can be
defined using definitions with the form <tt>$|key|</tt>
(the number of pipe symbols <tt>|</tt> is allowed to vary).
<p>
<pre>
    $|key 1| = value1
    $||key1|key2|| = value2    # The key is key1|key2
    X = $|key 1|               # Define X to be the value of field $|key 1|
</pre>
<p>
The usual modifiers are also allowed. The expression <tt>$`|key|</tt> represents
lazy evaluation of the key, and <tt>$,|key|</tt> is normal evaluation.
<p>
<h4><a name="section_244">Number</a></h4>

<p>
Parent objects: <tt>Object</tt>.
<p>
The <tt>Number</tt> object is the parent object for integers
and floating-point numbers.
<h4><a name="section_245">Int</a></h4>

<p>
Parent objects: <tt>Number</tt>.
<p>
The <tt>Int</tt> object represents integer values.
<h4><a name="section_246">Float</a></h4>

<p>
Parent objects: <tt>Number</tt>.
<p>
The <tt>Float</tt> object represents floating-point numbers.
<h4><a name="section_247">Sequence</a></h4>

<p>
Parent objects: <tt>Object</tt>.
<p>
The <tt>Sequence</tt> object represents a generic object containing
sequential elements. It provides the following methods.
<p>
<ul compact>
<li><tt>$(s.length)</tt>: the number of elements in the sequence.
</li>
<li><tt>$(s.map &lt;fun&gt;)</tt>: maps a function over the fields in the sequence.
The function should take one argument. The result is a new sequence
constructed from the values returned by the function.
</li>
<li><tt>s.foreach</tt>: the <tt>foreach</tt> form is equivalent to <tt>map</tt>,
but with altered syntax.
<p>
<pre>
   s.foreach(&lt;var&gt;)
      &lt;body&gt;
</pre>
<p>
For example, the following function prints all the elements of the sequence.
<p>
<pre>
   PrintSequence(s) =
      s.foreach(x)
         println(Elem = $(x))
</pre>
<p>
The <tt>export</tt> form is valid in a <tt>foreach</tt> body. The following
function counts the number of zeros in the sequence.
<p>
<pre>
   Zeros(s) =
      count = $(int 0)
      s.foreach(v)
         if $(equal $(v), 0)
            count = $(add $(count), 1)
            export
         export
      return $(count)
</pre>
</li>
</ul>
<h4><a name="section_248">Array</a></h4>

<p>
Parent objects: <tt>Sequence</tt>.
<p>
The <tt>Array</tt> is a random-access sequence.
It provides the following additional methods.
<p>
<ul compact>
<li><tt>$(s.nth &lt;i&gt;)</tt>: returns element <tt>i</tt> of the sequence.
</li>
<li><tt>$(s.rev &lt;i&gt;)</tt>: returns the reversed sequence.
</li>
</ul>
<p>
<h4><a name="section_249">String</a></h4>

<p>
Parent objects: <tt>Array</tt>.
<h4><a name="section_250">Fun</a></h4>

<p>
Parent objects: <tt>Object</tt>.
<p>
The <tt>Fun</tt> object provides the following methods.
<ul compact>
<li><tt>$(f.arity)</tt>: the arity if the function.
</li>
</ul>
<h4><a name="section_251">Rule</a></h4>

<p>
Parent objects: <tt>Object</tt>.
<p>
The <tt>Rule</tt> object represents a build rule.
It does not currently have any methods.
<h4><a name="section_252">Target</a></h4>

<p>
Parent object: <tt>Object</tt>.
<p>
The <tt>Target</tt> object contains information collected for
a specific target file.
<p>
<ul compact>
<li><tt>target</tt>: the target file.
</li>
<li><tt>effects</tt>: the files that may be modified by a
side-effect when this target is built.
</li>
<li><tt>scanner_deps</tt>: static dependencies that must be built
before this target can be scanned.
</li>
<li><tt>static-deps</tt>: statically-defined build dependencies
of this target.
</li>
<li><tt>build-deps</tt>: all the build dependencies for the target,
including static and scanned dependencies.
</li>
<li><tt>build-values</tt>: all the value dependencies associated
with the build.
</li>
<li><tt>build-commands</tt>: the commands to build the target.
</li>
</ul>
<p>
The object supports the following methods.
<p>
<ul compact>
<li><tt>find(file)</tt>: returns a Target object for the given file.
Raises a <tt>RuntimeException</tt> if the specified target is
not part of the project.
</li>
<li><tt>find-optional(file)</tt>: returns a <tt>Target</tt> object
for the given file, or <tt>false</tt> if the file is not
part of the project.
</li>
</ul>
<p>
NOTE: the information for a target is constructed dynamically,
so it is possible that the <tt>Target</tt> object for a node will
contain different values in different contexts. The easiest way
to make sure that the <tt>Target</tt> information is complete is
to compute it within a rule body, where the rule depends on
the target file, or the dependencies of the target file.
<h4><a name="section_253">Node</a></h4>

<p>
Parent objects: <tt>Object</tt>.
<p>
The <tt>Node</tt> object is the parent object for files and directories.
It supports the following operations.
<ul compact>
<li><tt>$(node.stat)</tt>: returns a <tt>stat</tt> object for the file. If the
file is a symbolic link, the <tt>stat</tt> information is for the destination of
the link, not the link itself.
<p>
</li>
<li><tt>$(node.lstat)</tt>: returns a <tt>stat</tt> object for the file or symbolic link.
</li>
<li><tt>$(node.unlink)</tt>: removes the file.
</li>
<li><tt>$(node.rename &lt;file&gt;)</tt>: renames the file.
</li>
<li><tt>$(node.link &lt;file&gt;)</tt>: creates a hard link <tt>&lt;dst&gt;</tt> to this file.
</li>
<li><tt>$(node.symlink &lt;file&gt;)</tt>: create a symbolic link <tt>&lt;dst&gt;</tt> to this file.
</li>
<li><tt>$(node.chmod &lt;perm&gt;)</tt>: change the permission of this file.
</li>
<li><tt>$(node.chown &lt;uid&gt;, &lt;gid&gt;)</tt>: change the owner and group id of this file.
</li>
</ul>
<h4><a name="section_254">File</a></h4>

<p>
Parent objects: <tt>Node</tt>.
<p>
The file object represents the name of a file.
<h4><a name="section_255">Dir</a></h4>

<p>
Parent objects: <tt>Node</tt>.
<p>
The <tt>Dir</tt> object represents the name of a directory.
<h4><a name="section_256">Channel</a></h4>

<p>
Parent objects: <tt>Object</tt>.
<p>
A <tt>Channel</tt> is a generic IO channel.
It provides the following methods.
<ul compact>
<li><tt>$(o.close)</tt>: close the channel.
</li>
</ul>
<h4><a name="section_257">InChannel</a></h4>

<p>
Parent objects: <tt>Channel</tt>.
<p>
A <tt>InChannel</tt> is an input channel. The variable <tt>stdin</tt> is the
standard input channel.
<p>
It provides the following methods.
<ul compact>
<li><tt>$(InChannel.fopen &lt;file&gt;)</tt>: open a new input channel.
</li>
</ul>
<h4><a name="section_258">OutChannel</a></h4>

<p>
Parent object: <tt>Channel</tt>.
<p>
A <tt>OutChannel</tt> is an output channel. The variables <tt>stdout</tt>
and <tt>stderr</tt> are the standard output and error channels.
<p>
It provides the following methods.
<ul compact>
<li><tt>$(OutChannel.fopen &lt;file&gt;)</tt>: open a new output channel.
</li>
<li><tt>$(OutChannel.append &lt;file&gt;)</tt>: opens a new output channel,
appending to the file.
</li>
<li><tt>$(c.flush)</tt>: flush the output channel.
</li>
<li><tt>$(c.print &lt;string&gt;)</tt>: print a string to the channel.
</li>
<li><tt>$(c.println &lt;string&gt;)</tt>: print a string to the channel,
followed by a line terminator.
</li>
</ul>
<h4><a name="section_259">Location</a></h4>

<p>
Parent objects: <tt>Location</tt>.
<p>
The <tt>Location</tt> object represents a location in a file.
<h4><a name="section_260">Position</a></h4>

<p>
Parent objects: <tt>Position</tt>.
<p>
The <tt>Position</tt> object represents a stack trace.
<h4><a name="section_261">Exception</a></h4>

<p>
Parent objects: <tt>Object</tt>.
<p>
The <tt>Exception</tt> object is used as the base object for exceptions.
It has no fields.
<h4><a name="section_262">RuntimeException</a></h4>

<p>
Parent objects: <tt>Exception</tt>.
<p>
The <tt>RuntimeException</tt> object represents an exception from the
runtime system. It has the following fields.
<p>
<ul compact>
<li><tt>position</tt>: a string representing the location where the
exception was raised.
</li>
<li><tt>message</tt>: a string containing the exception message.
</li>
</ul>
<h4><a name="section_263">Shell</a></h4>

<p>
Parent objects: <tt>Object</tt>.
<p>
The <tt>Shell</tt> object contains the collection of builtin functions
available as shell commands.
<p>
You can define aliases by extending this object with additional methods.
All methods in this class are called with one argument: a single array
containing an argument list.
<p>
<ul compact>
<li><tt>echo</tt>
<p>
The <tt>echo</tt> function prints its arguments to the standard output channel.
</li>
<li><tt>jobs</tt>
<p>
The <tt>jobs</tt> method prints the status of currently running commands.
</li>
<li><tt>cd</tt>
<p>
The <tt>cd</tt> function changes the current directory.
Note that the current directory follows the usual scoping
rules. For example, the following program lists the
files in the <tt>foo</tt> directory, but the current
directory is not changed.
<p>
<pre>
   section
      echo Listing files in the foo directory...
      cd foo
      ls

   echo Listing files in the current directory...
   ls
</pre>
</li>
<li><tt>bg</tt>
<p>
The <tt>bg</tt> method places a job in the background.
The job is resumed if it has been suspended.
</li>
<li><tt>fg</tt>
<p>
The <tt>fg</tt> method brings a job to the foreground.
The job is resumed if it has been suspended.
</li>
<li><tt>stop</tt>
<p>
The <tt>stop</tt> method suspends a running job.
</li>
<li><tt>wait</tt>
<p>
The <tt>wait</tt> function waits for a running job to terminate.
It is not possible to wait for a suspended job.
<p>
The job is not brought to the foreground. If the <tt>wait</tt>
is interrupted, the job continues to run in the background.
</li>
<li><tt>kill</tt>
<p>
The <tt>kill</tt> function signal a job.
<p>
<tt>kill [signal] &lt;pid...&gt;</tt>.
<p>
The signals are either numeric, or symbolic.
The symbolic signals are named as follows.
<p>
ABRT, ALRM, HUP, ILL, KILL, QUIT, SEGV, TERM, USR1,
USR2, CHLD, STOP, TSTP, TTIN, TTOU, VTALRM, PROF.
</li>
<li><tt>exit</tt>
<p>
The <tt>exit</tt> function terminates the current session.
</li>
<li><tt>which</tt>, <tt>where</tt>
<p>
See the documentation for the corresponding functions.
</li>
<li><tt>rehash</tt>
<p>
Reset the search path.
</li>
<li><tt>history</tt>
<p>
Print the current command-line history.
</li>
<li>Win32 functions.
<p>
Win32 doesn't provide very many programs for scripting, except
for the functions that are builtin to the DOS <tt>cmd.exe</tt>.
The following functions are defined on Win32 and only on Win32.
On other systems, it is expected that these programs already
exist.
<p>
<ul compact>
<li><tt>grep</tt>
<p>
<pre>
   grep [-q] [-n] pattern files...
</pre>
<p>
The <tt>grep</tt> function calls the <tt>omake</tt>
<tt>grep</tt> function.
</li>
</ul>
By default, <tt>omake</tt>
uses internal versions of the following commands:
<tt>cp</tt>, <tt>mv</tt>, <tt>cat</tt>, <tt>rm</tt>, <tt>mkdir</tt>, <tt>chmod</tt>,
<tt>test</tt>, <tt>find</tt>.
If you really want to use the standard system versions of these
commands, set the <tt>USE_SYSTEM_COMMANDS</tt> as one of the first
definitions in your <tt>OMakeroot</tt> file.
<p>
<ul compact>
<li><tt>mkdir</tt>
<p>
<pre>
    mkdir [-m &lt;mode&gt;] [-p] files
</pre>
<p>
The <tt>mkdir</tt> function is used to create directories.
The -verb+-m+ option can be used to specify the permission
mode of the created directory. If the <tt>-p</tt> option
is specified, the full path is created.
</li>
<li><tt>cp</tt>
</li>
<li><tt>mv</tt>
<p>
<pre>
    cp [-f] [-i] [-v] src dst
    cp [-f] [-i] [-v] files dst
    mv [-f] [-i] [-v] src dst
    mv [-f] [-i] [-v] files dst
</pre>
<p>
The <tt>cp</tt> function copies a <tt>src</tt> file to
a <tt>dst</tt> file, overwriting it if it already exists.
If more than one source file is specified, the final file
must be a directory, and the source files are copied
into the directory.
<p>
<ul compact>
<dt>-f</dt>
<dd> Copy files forcibly, do not prompt.
</dd>
<dt>-i</dt>
<dd> Prompt before removing destination files.
</dd>
<dt>-v</dt>
<dd> Explain what is happening.
</li>
</ul>
</li>
<li><tt>rm</tt>
<p>
<pre>
   rm [-f] [-i] [-v] [-r] files
   rmdir [-f] [-i] [-v] [-r] dirs
</pre>
<p>
The <tt>rm</tt> function removes a set of files.
No warnings are issued if the files do not exist, or if
they cannot be removed.
<p>
Options:
<ul compact>
<dt>-f</dt>
<dd> Forcibly remove files, do not prompt.
</dd>
<dt>-i</dt>
<dd> Prompt before removal.
</dd>
<dt>-v</dt>
<dd> Explain what is happening.
</dd>
<dt>-r</dt>
<dd> Remove contents of directories recursively.
</li>
</ul>
</li>
<li><tt>chmod</tt>
<p>
<pre>
    chmod [-r] [-v] [-f] mode files
</pre>
<p>
The <tt>chmod</tt> function changes the permissions on a set of
files or directories. This function does nothing on Win32.
The <tt>mode</tt> may be specified as an octal number,
or in symbolic form <tt>[ugoa]*[</tt>-=][rwxXstugo]+.
See the man page for <tt>chmod</tt> for details.
<p>
Options:
<ul compact>
<dt>-r</dt>
<dd> Change permissions of all files in a directory recursively.
</dd>
<dt>-v</dt>
<dd> Explain what is happening.
</dd>
<dt>-f</dt>
<dd> Continue on errors.
</li>
</ul>
</li>
<li><tt>cat</tt>
<p>
<pre>
   cat files...
</pre>
<p>
The <tt>cat</tt> function prints the contents of the files to stdout
</li>
<li><tt>test</tt>
<p>
<pre>
   test \emph{expression}
   \verb+[+ \emph{expression} +]+
   \verb+[ --help+
   \verb+[ --version+
</pre>
<p>
See the documentation for the <tt>test</tt> function.
<p>
</li>
<li><tt>find</tt>
<p>
<pre>
   find \emph{expression}
</pre>
<p>
See the documentation for the <tt>find</tt> function.
<p>
</li>
</ul>
</li>
</ul>
<h2><a name="section_264">Build functions</a></h2>

<p>
<h4><a name="section_265">OMakeFlags</a></h4>

<p>
<pre>
   OMakeFlags(options)
      options : String
</pre>
<p>
The <tt>OMakeFlags</tt> function is used to set <tt>omake</tt> options from
within <tt>OMakefile</tt>s.
The options have exactly the same format as
options on the command line.
<p>
For example, the following code displays the progress bar unless
the <tt>VERBOSE</tt> environment variable is defined.
<p>
<pre>
    if $(not $(defined-env VERBOSE))
        OMakeFlags(-S --progress)
        export
</pre>
<h4><a name="section_266">OMakeVersion</a></h4>

<p>
<pre>
   OMakeVersion(version1)
   OMakeVersion(version1, version2)
      version1, version2 : String
</pre>
<p>
The <tt>OMakeVersion</tt> function is used for version checking
in <tt>OMakefile</tt>s.
It takes one or two arguments.
<p>
In the one argument form, if the <tt>omake</tt>
version number
is less than <tt>&lt;version1&gt;</tt>,
then an exception is raised. In the two argument form,
the version must lie between <tt>version1</tt> and <tt>version2</tt>.
<p>
<h4><a name="section_267">cmp-versions</a></h4>

<pre>
   $(cmp-versions version1, version2)
      version1, version2 : String
</pre>
<p>
The <tt>cmp-versions\</tt> functions can be used to compare arbitrary version strings.
It returns 0 when the two version strings are equal, a negative number when the first
string represents an earlier version, and a positive number otherwise.
<h4><a name="section_268">DefineCommandVars</a></h4>

<p>
<pre>
   DefineCommandVars()
</pre>
<p>
The <tt>DefineCommandVars</tt> function redefines the variables passed on
the commandline. Variables definitions are passed on the command line
in the form <tt>name=value</tt>. This function is primarily for internal
use by <tt>omake</tt>
to define these variables for the first time.
<h2><a name="section_269">The OMakeroot file</a></h2>

<p>
The standard <tt>OMakeroot</tt>
file defines the functions are rules
for building standard projects.
<p>
<h4><a name="section_270">Variables</a></h4>

<dl compact>
<dt>ROOT</dt>
<dd> The root directory of the current project.
</dd>
<dt>CWD</dt>
<dd> The current working directory (the directory is set for each <tt>OMakefile</tt>
in the project).
</dd>
<dt>EMPTY</dt>
<dd> The empty string.
</dd>
<dt>STDROOT</dt>
<dd> The name of the standard installed <tt>OMakeroot</tt>
file.
</dd>
<dt>VERBOSE</dt>
<dd> Whether certain commands should be verbose (<tt>false</tt> by default).
</dd>
</dl>
<dl compact>
<dt>ABORT_ON_COMMAND_ERROR</dt>
<dd> If set to true, the construction of a target should
be aborted whenever one of the commands to build it fail. This defaults to true,
and should normally be left that way.
<p>
</dd>
<dt><a name="SCANNERMODE">SCANNER_MODE</a>
</dt>
<dd> This variable should be defined as one of four values
(defaults to <tt>enabled</tt>).
<dl compact>
<dt>enabled</dt>
<dd> Allow the use of default <tt>.SCANNER</tt> rules. Whenever a rule does
not specify a <tt>:scanner:</tt> dependency explicitly, try to find a
<tt>.SCANNER</tt> with the same target name.
</dd>
<dt>disabled</dt>
<dd> Never use default <tt>.SCANNER</tt> rules.
</dd>
<dt>warning</dt>
<dd> Allow the use of default <tt>.SCANNER</tt> rules, but print a warning
whenever one is selected.
</dd>
<dt>error</dt>
<dd> Do not allow the use of default <tt>.SCANNER</tt> rules. If a rule
does not specify a <tt>:scanner:</tt> dependency, and there is a default
<tt>.SCANNER</tt> rule, the build will terminate abnormally.
</dd>
</dl>
</dd>
</dl>
<h4><a name="section_271">System variables</a></h4>

<p>
<dl compact>
<dt>INSTALL</dt>
<dd> The command to install a program (<tt>install</tt> on <tt>Unix</tt>, <tt>cp</tt> on <tt>Win32</tt>).
</dd>
<dt>PATHSEP</dt>
<dd> The normal path separator (<tt>:</tt> on <tt>Unix</tt>, <tt>;</tt> on <tt>Win32</tt>).
</dd>
<dt>DIRSEP</dt>
<dd> The normal directory separator (<tt>/</tt> on <tt>Unix</tt>, <tt>\</tt> on <tt>Win32</tt>).
</dd>
<dt>EXT_LIB</dt>
<dd> File suffix for a static library (default is <tt>.a</tt> on <tt>Unix</tt>, and <tt>.lib</tt> on <tt>Win32</tt>).
</dd>
<dt>EXT_OBJ</dt>
<dd> File suffix for an object file (default is <tt>.o</tt> on <tt>Unix</tt>, and <tt>.obj</tt> on <tt>Win32</tt>).
</dd>
<dt>EXT_ASM</dt>
<dd> File suffix for an assembly file (default is <tt>.s</tt> on <tt>Unix</tt>, and <tt>.asm</tt> on <tt>Win32</tt>).
</dd>
<dt>EXE</dt>
<dd> File suffix for executables (default is empty for <tt>Unix</tt>, and <tt>.exe</tt> on <tt>Win32</tt> and <tt>Cygwin</tt>).
</dd>
</dl>
<h2><a name="section_272">Building C programs</a></h2>

<p>
<tt>omake</tt>
provides extensive support for building C programs.
<p>
<h4><a name="section_273">C configuration variables</a></h4>

<p>
The following variables can be redefined in your project.
<p>
<dl compact>
<dt>CC</dt>
<dd> The name of the C compiler (on <tt>Unix</tt> it defaults to <tt>gcc</tt> when <tt>gcc</tt> is present and
to <tt>cc</tt> otherwise; on <tt>Win32</tt> defaults to <tt>cl /nologo</tt>).
</dd>
<dt>CXX</dt>
<dd> The name of the C++ compiler (on <tt>Unix</tt> it defaults to <tt>gcc</tt> when <tt>gcc</tt> is present
and to <tt>c</tt>++ otherwise; on <tt>Win32</tt> defaults to <tt>cl /nologo</tt>).
</dd>
<dt>CPP</dt>
<dd> The name of the C preprocessor (defaults to <tt>cpp</tt> on <tt>Unix</tt>, and <tt>cl /E</tt> on <tt>Win32</tt>).
</dd>
<dt>CFLAGS</dt>
<dd> Compilation flags to pass to the C compiler (default empty on <tt>Unix</tt>, and <tt>/DWIN32</tt>
on <tt>Win32</tt>).
</dd>
<dt>CXXFLAGS</dt>
<dd> Compilation flags to pass to the C++ compiler (default empty on <tt>Unix</tt>, and <tt>/DWIN32</tt>
on <tt>Win32</tt>).
</dd>
<dt>INCLUDES</dt>
<dd> Additional directories that specify the search path to the C and C++ compilers (default is <tt>.</tt>).
The directories are passed to the C and C++ compilers with the <tt>-I</tt> option.
The include path with <tt>-I</tt> prefixes is defined in the <tt>PREFIXED_INCLUDES</tt> variable.
</dd>
<dt>LIBS</dt>
<dd> Additional libraries needed when building a program (default is empty).
</dd>
<dt>AS</dt>
<dd> The name of the assembler (defaults to <tt>as</tt> on <tt>Unix</tt>, and <tt>ml</tt> on <tt>Win32</tt>).
</dd>
<dt>ASFLAGS</dt>
<dd> Flags to pass to the assembler (default is empty on <tt>Unix</tt>, and <tt>/c /coff</tt> on <tt>Win32</tt>).
</dd>
<dt>AR</dt>
<dd> The name of the program to create static libraries (defaults to <tt>ar cq</tt> on <tt>Unix</tt>,
and <tt>lib</tt> on <tt>Win32</tt>).
</dd>
<dt>AROUT</dt>
<dd> The option string that specifies the output file for <tt>AR</tt>.
</dd>
<dt>LD</dt>
<dd> The name of the linker (defaults to <tt>ld</tt> on <tt>Unix</tt>, and <tt>cl</tt> on <tt>Win32</tt>).
</dd>
<dt>LDFLAGS</dt>
<dd> Options to pass to the linker (default is empty).
</dd>
<dt>YACC</dt>
<dd> The name of the <tt>yacc</tt> parser generator (default is <tt>yacc</tt> on <tt>Unix</tt>, empty on <tt>Win32</tt>).
</dd>
<dt>LEX</dt>
<dd> The name of the <tt>lex</tt> lexer generator (default is <tt>lex</tt> on <tt>Unix</tt>, empty on <tt>Win32</tt>).
</dd>
</dl>
<h4><a name="section_274">CGeneratedFiles, LocalCGeneratedFiles</a></h4>

<pre>
CGeneratedFiles(files)
LocalCGeneratedFiles(files)
</pre>
<p>
The <tt>CGeneratedFiles</tt> and <tt>LocalCGeneratedFiles</tt> functions specify files
that need to be generated before any C files are scanned for dependencies. For example,
if <tt>config.h</tt> and <tt>inputs.h</tt> are both generated files, specify:
<pre>
CGeneratedFiles(config.h inputs.h)
</pre>
<p>
The <tt>CGeneratedFiles</tt> function is <em>global</em>
--- its arguments will be generated
before any C files anywhere in the project are scanned for dependencies. The
<tt>LocalCGeneratedFiles</tt> function follows the normal scoping rules of OMake.
<p>
<h4><a name="section_275">StaticCLibrary</a></h4>

<p>
The <tt>StaticCLibrary</tt> builds a static library.
<p>
<tt>StaticCLibrary(&lt;target&gt;, &lt;files&gt;)</tt>
<p>
The <tt>&lt;target&gt;</tt> does <em>not</em>
include the library suffix, and
The <tt>&lt;files&gt;</tt> list does not include the object suffix. These
are obtained from the <tt>EXT_LIB</tt> and <tt>EXT_OBJ</tt> variables.
<p>
This function returns the library filename.
<p>
The following command builds the library <tt>libfoo.a</tt> from the
files <tt>a.o b.o c.o</tt> on <tt>Unix</tt>, or the library
<tt>libfoo.lib</tt> from the files <tt>a.obj b.obj c.obj</tt>
on <tt>Win32</tt>.
<p>
<pre>
StaticCLibrary(libfoo, a b c)
.DEFAULT: $(StaticCLibrary libbar, a b c d)
</pre>
<h4><a name="section_276">StaticCLibraryCopy</a></h4>

<p>
The <tt>StaticCLibraryCopy</tt> function copies the static library
to an install location.
<p>
<tt>StaticCLibraryCopy(&lt;tag&gt;, &lt;dir&gt;, &lt;lib&gt;)</tt>
<p>
The <tt>&lt;tag&gt;</tt> is the name of a target (typically a <tt>.PHONY</tt> target);
the <tt>&lt;dir&gt;</tt> is the installation directory, and <tt>&lt;lib&gt;</tt> is
the library to be copied (without the library suffix).
<p>
This function returns the filename of the library in the target directory.
<p>
For example, the following code copies the library
<tt>libfoo.a</tt> to the <tt>/usr/lib</tt> directory.
<p>
<pre>
.PHONY: install

StaticCLibraryCopy(install, /usr/lib, libfoo)
</pre>
<h4><a name="section_277">StaticCLibraryInstall</a></h4>

<p>
The <tt>StaticCLibraryInstall</tt> function builds a library, and
sets the install location in one step. It returns the filename of the library
in the target directory.
<p>
<tt>StaticCLibraryInstall(&lt;tag&gt;, &lt;dir&gt;, &lt;libname&gt;, &lt;files&gt;)</tt>
<p>
<pre>
StaticCLibraryInstall(install, /usr/lib, libfoo, a b c)
</pre>
<h4><a name="section_278">StaticCObject, StaticCObjectCopy, StaticCObjectInstall</a></h4>

<p>
These functions mirror the <tt>StaticCLibrary</tt>, <tt>StaticCLibraryCopy</tt>,
and <tt>StaticCLibraryInstall</tt> functions, but they build an <em>object</em>
file (a <tt>.o</tt> file on <tt>Unix</tt>, and a <tt>.obj</tt> file on <tt>Win32</tt>).
<h4><a name="section_279">CProgram</a></h4>

<p>
The <tt>CProgram</tt> function builds a C program from a set
of object files and libraries.
<p>
<tt>CProgram(&lt;name&gt;, &lt;files&gt;)</tt>
<p>
The <tt>&lt;name&gt;</tt> argument specifies the name of the program to be built;
the <tt>&lt;files&gt;</tt> argument specifies the files to be linked. The function
returns the filename of the executable.
<p>
Additional options can be passed through the following variables.
<dl compact>
<dt>CFLAGS</dt>
<dd> Flags used by the C compiler during the link step.
</dd>
<dt>LDFLAGS</dt>
<dd> Flags to pass to the loader.
</dd>
<dt>LIBS</dt>
<dd> Additional libraries to be linked.
</dd>
</dl>
<p>
For example, the following code specifies that the program
<tt>foo</tt> is to be produced by linking the files <tt>bar.o</tt>
and <tt>baz.o</tt> and libraries <tt>libfoo.a</tt>.
<p>
<pre>
section
   LIBS = libfoo$(EXT_LIB)
   CProgram(foo, bar baz)
</pre>
<h4><a name="section_280">CProgramCopy</a></h4>

<p>
The <tt>CProgramCopy</tt> function copies a file to an install location.
<p>
<tt>CProgramCopy(&lt;tag&gt;, &lt;dir&gt;, &lt;program&gt;)</tt>
<p>
<pre>
CProgramCopy(install, /usr/bin, foo)
</pre>
<h4><a name="section_281">CProgramInstall</a></h4>

<p>
The <tt>CProgramInstall</tt> function specifies a program to build,
and a location to install, simultaneously.
<p>
<tt>CProgramInstall(&lt;tag&gt;, &lt;dir&gt;, &lt;name&gt;, &lt;files&gt;)</tt>
<p>
<pre>
section
   LIBS = libfoo$(EXT_LIB)
   CProgramInstall(install, /usr/bin, foo, bar baz)
</pre>
<h4><a name="section_282">CXXProgram, CXXProgramInstall</a></h4>

<p>
The <tt>CXXProgram</tt> and <tt>CXXProgramInstall</tt> functions are
equivalent to their C counterparts, except that would use <tt>$(CXX)</tt> and <tt>$(CXXFLAGS)</tt>
for linking instead of <tt>$(CC)</tt> and <tt>$(CFLAGS)</tt>.
<h2><a name="section_283">Building OCaml programs</a></h2>

<p>
<h4><a name="section_284">Variables for OCaml programs</a></h4>

<p>
The following variables can be redefined in your project.
<dl compact>
<dt>USE_OCAMLFIND</dt>
<dd> Whether to use the <tt>ocamlfind</tt> utility (default <tt>false\</tt>)
</dd>
<dt>OCAMLC</dt>
<dd> The OCaml bytecode compiler (default <tt>ocamlc.opt</tt> if it exists
and <tt>USE_OCAMLFIND</tt> is not set, otherwise <tt>ocamlc</tt>).
</dd>
<dt>OCAMLOPT</dt>
<dd> The OCaml native-code compiler (default <tt>ocamlopt.opt</tt> if it
exists and <tt>USE_OCAMLFIND</tt> is not set, otherwise <tt>ocamlopt</tt>).
</dd>
<dt>CAMLP4</dt>
<dd> The <tt>camlp4</tt> preprocessor (default <tt>camlp4</tt>).
</dd>
<dt>OCAMLLEX</dt>
<dd> The OCaml lexer generator (default <tt>ocamllex</tt>).
</dd>
<dt>OCAMLLEXFLAGS</dt>
<dd> The flags to pass to <tt>ocamllex</tt> (default <tt>-q</tt>).
</dd>
<dt>OCAMLYACC</dt>
<dd> The OCaml parser generator (default <tt>ocamlyacc</tt>).
</dd>
<dt>OCAMLDEP</dt>
<dd> The OCaml dependency analyzer (default <tt>ocamldep</tt>).
</dd>
<dt>OCAMLMKTOP</dt>
<dd> The OCaml toploop compiler (default <tt>ocamlmktop</tt>).
</dd>
<dt>OCAMLLINK</dt>
<dd> The OCaml bytecode linker (default <tt>$(OCAMLC)</tt>).
</dd>
<dt>OCAMLOPTLINK</dt>
<dd> The OCaml native-code linker (default <tt>$(OCAMLOPT)</tt>).
</dd>
<dt>OCAMLINCLUDES</dt>
<dd> Search path to pass to the OCaml compilers (default <tt>.</tt>).
The search path with the <tt>-I</tt> prefix is defined by the <tt>PREFIXED_OCAMLINCLUDES</tt>
variable.
</dd>
<dt>OCAMLFIND</dt>
<dd> The <tt>ocamlfind</tt> utility (default <tt>ocamlfind</tt> if
<tt>USE_OCAMLFIND</tt> is set, otherwise empty).
</dd>
<dt>OCAMLFINDFLAGS</dt>
<dd> The flags to pass to <tt>ocamlfind</tt> (default empty, <tt>USE_OCAMLFIND</tt> must be set).
</dd>
<dt>OCAMLPACKS</dt>
<dd> Package names to pass to <tt>ocamlfind</tt> (<tt>USE_OCAMLFIND</tt> must be set).
</dd>
<dt>BYTE_ENABLED</dt>
<dd> Flag indicating whether to use the bytecode compiler (default <tt>true</tt>, when no <tt>ocamlopt</tt> found, <tt>false</tt> otherwise).
</dd>
<dt>NATIVE_ENABLED</dt>
<dd> Flag indicating whether to use the native-code compiler (default <tt>true</tt>, when ocamlopt is found, <tt>false</tt> otherwise).
Both <tt>BYTE_ENABLED</tt> and <tt>NATIVE_ENABLED</tt> can be set to true;
at least one should be set to true.
</dd>
</dl>
<h4><a name="section_285">OCaml command flags</a></h4>

<p>
The following variables specify additional options to be passed to
the OCaml tools.
<dl compact>
<dt>OCAMLDEPFLAGS</dt>
<dd> Flags to pass to <tt>OCAMLDEP</tt>.
</dd>
<dt>OCAMLPPFLAGS</dt>
<dd> Flags to pass to <tt>CAMLP4</tt>.
</dd>
<dt>OCAMLCFLAGS</dt>
<dd> Flags to pass to the byte-code compiler (default <tt>-g</tt>).
</dd>
<dt>OCAMLOPTFLAGS</dt>
<dd> Flags to pass to the native-code compiler (default empty).
</dd>
<dt>OCAMLFLAGS</dt>
<dd> Flags to pass to either compiler (default <tt>-warn-error A</tt>).
</dd>
<dt>OCAMLINCLUDES</dt>
<dd> Include path (default <tt>.</tt>).
</dd>
<dt>OCAML_BYTE_LINK_FLAGS</dt>
<dd> Flags to pass to the byte-code linker (default empty).
</dd>
<dt>OCAML_NATIVE_LINK_FLAGS</dt>
<dd> Flags to pass to the native-code linker (default empty).
</dd>
<dt>OCAML_LINK_FLAGS</dt>
<dd> Flags to pass to either linker.
</dd>
</dl>
<h4><a name="section_286">Library variables</a></h4>

<p>
The following variables are used during linking.
<p>
<dl compact>
<dt>OCAML_LIBS</dt>
<dd> Libraries to pass to the linker. These libraries become dependencies
of the link step.
</dd>
<dt>OCAML_OTHER_LIBS</dt>
<dd> Additional libraries to pass to the linker. These libraries are
<em>not</em>
included as dependencies to the link step. Typical use is for the OCaml
standard libraries like <tt>unix</tt> or <tt>str</tt>.
</dd>
<dt>OCAML_CLIBS</dt>
<dd> C libraries to pass to the linker.
</dd>
<dt>OCAML_LIB_FLAGS</dt>
<dd> Extra flags for the library.
</dd>
</dl>
<h4><a name="section_287">OCamlGeneratedFiles, LocalOCamlGeneratedFiles</a></h4>

<pre>
OCamlGeneratedFiles(files)
LocalOCamlGeneratedFiles(files)
</pre>
<p>
The <tt>OCamlGeneratedFiles</tt> and <tt>LocalOCamlGeneratedFiles</tt> functions specify files
that need to be generated before any OCaml files are scanned for dependencies. For example,
if <tt>parser.ml</tt> and <tt>lexer.ml</tt> are both generated files, specify:
<pre>
OCamlGeneratedFiles(parser.ml lexer.ml)
</pre>
<p>
The <tt>OCamlGeneratedFiles</tt> function is <em>global</em>
--- its arguments will be generated
before any OCaml files anywhere in the project are scanned for dependencies. The
<tt>LocalOCamlGeneratedFiles</tt> function follows the normal scoping rules of OMake.
<p>
<h4><a name="section_288">OCamlLibrary</a></h4>

<p>
The <tt>OCamlLibrary</tt> function builds an OCaml library.
<p>
<tt>OCamlLibrary(&lt;libname&gt;, &lt;files&gt;)</tt>
<p>
The <tt>&lt;libname&gt;</tt> and <tt>&lt;files&gt;</tt> are listed <em>without</em>
suffixes.
<p>
Additional variables used by the function:
<dl compact>
<dt>ABORT_ON_DEPENDENCY_ERRORS</dt>
<dd> The linker requires that the files to be
listed in dependency order. If this variable is true, the order of
the files is determined by the command line, but <tt>omake</tt>
will
abort with an error message if the order is illegal. Otherwise,
the files are sorted automatically.
</dd>
</dl>
<p>
This function returns the list of all the targets that it defines the rules
for (including the <tt>$(name)$(EXT_LIB)</tt> file when <tt>NATIVE_ENABLED</tt> is set).
<p>
The following code builds the <tt>libfoo.cmxa</tt> library from the files <tt>foo.cmx</tt>
and <tt>bar.cmx</tt> (if <tt>NATIVE_ENABLED</tt> is set), and <tt>libfoo.cma</tt> from
<tt>foo.cmo</tt> and <tt>bar.cmo</tt> (if <tt>BYTE_ENABLED</tt> is set).
<p>
<pre>
OCamlLibrary(libfoo, foo bar)
</pre>
<h4><a name="section_289">OCamlLibraryCopy</a></h4>

<p>
The <tt>OCamlLibraryCopy</tt> function copies a library to an install location.
<p>
<tt>OCamlLibraryCopy(&lt;tag&gt;, &lt;libdir&gt;, &lt;libname&gt;, &lt;interface-files&gt;)</tt>
<p>
The <tt>&lt;interface-files&gt;</tt> specify additional interface files
to be copied if the <tt>INSTALL_INTERFACES</tt> variable is true.
<h4><a name="section_290">OCamlLibraryInstall</a></h4>

<p>
The <tt>OCamlLibraryInstall</tt> function builds a library
and copies it to an install location in one step.
<p>
<tt>OCamlLibraryInstall(&lt;tag&gt;, &lt;libdir&gt;, &lt;libname&gt;, &lt;files&gt;)</tt>
<h4><a name="section_291">OCamlProgram</a></h4>

<p>
The <tt>OCamlProgram</tt> function builds an OCaml program. It returns the array with all
the targets for which it have defined the rules (<tt>$(name)$(EXE)</tt> and <tt>$(name).run</tt>
and/or <tt>$(name).opt</tt>, depending on the <tt>NATIVE_ENABLED</tt> and <tt>BYTE_ENABLED</tt>
variables).
<p>
<tt>OCamlProgram(&lt;name&gt;, &lt;files&gt;)</tt>
<p>
Additional variables used:
<dl compact>
<dt>OCAML_LIBS</dt>
<dd> Additional libraries passed to the linker, without suffix. These files
become dependencies of the target program.
</dd>
<dt>OCAML_OTHER_LIBS</dt>
<dd> Additional libraries passed to the linker, without suffix. These
files do <em>not</em>
become dependencies of the target program.
</dd>
<dt>OCAML_CLIBS</dt>
<dd> C libraries to pass to the linker.
</dd>
<dt>OCAML_BYTE_LINK_FLAGS</dt>
<dd> Flags to pass to the bytecode linker.
</dd>
<dt>OCAML_NATIVE_LINK_FLAGS</dt>
<dd> Flags to pass to the native code linker.
</dd>
<dt>OCAML_LINK_FLAGS</dt>
<dd> Flags to pass to both linkers.
</dd>
</dl>
<h4><a name="section_292">OCamlProgramCopy</a></h4>

<p>
The <tt>OCamlProgramCopy</tt> function copies an OCaml program to an install location.
<p>
<tt>OCamlProgramCopy(&lt;tag&gt;, &lt;bindir&gt;, &lt;name&gt;)</tt>
<p>
Additional variables used:
<dl compact>
<dt>NATIVE_ENABLED</dt>
<dd> If <tt>NATIVE_ENABLED</tt> is set, the native-code executable
is copied; otherwise the byte-code executable is copied.
</dd>
</dl>
<h4><a name="section_293">OCamlProgramInstall</a></h4>

<p>
The <tt>OCamlProgramInstall</tt> function builds a programs and copies it to
an install location in one step.
<p>
<tt>OCamlProgramInstall(&lt;tag&gt;, &lt;bindir&gt;, &lt;name&gt;, &lt;files&gt;)</tt>
<h2><a name="section_294">Building LaTeX programs</a></h2>

<p>
<h4><a name="section_295">Configuration variables</a></h4>

<p>
The following variables can be modified in your project.
<dl compact>
<dt>LATEX</dt>
<dd> The LaTeX command (default <tt>latex</tt>).
</dd>
<dt>TETEX2_ENABLED</dt>
<dd> Flag indicating whether to use advanced LaTeX options
present in TeTeX v.2 (default value is determined the first time omake reads <tt>LaTeX.src</tt>
and depends on the version of LaTeX you have installed).
</dd>
<dt>LATEXFLAGS</dt>
<dd> The LaTeX flags (defaults depend on the <tt>TETEX2_ENABLED</tt> variable)
</dd>
<dt>BIBTEX</dt>
<dd> The BibTeX command (default <tt>bibtex</tt>).
</dd>
<dt>MAKEINDEX</dt>
<dd> The command to build an index (default <tt>makeindex</tt>).
</dd>
<dt>DVIPS</dt>
<dd> The <tt>.dvi</tt> to PostScript converter (default <tt>dvips</tt>).
</dd>
<dt>DVIPSFLAGS</dt>
<dd> Flags to pass to <tt>dvips</tt> (default <tt>-t letter</tt>).
</dd>
<dt>DVIPDFM</dt>
<dd> The <tt>.dvi</tt> to <tt>.pdf</tt> converter (default <tt>dvipdfm</tt>).
</dd>
<dt>DVIPDFMFLAGS</dt>
<dd> Flags to pass to <tt>dvipdfm</tt> (default <tt>-p letter</tt>).
</dd>
<dt>PDFLATEX</dt>
<dd> The <tt>.latex</tt> to <tt>.pdf</tt> converter (default <tt>pdflatex</tt>).
</dd>
<dt>PDFLATEXFLAGS</dt>
<dd> Flags to pass to pdflatex (default is empty).
</dd>
<dt>USEPDFLATEX</dt>
<dd> Flag indicating whether to use pdflatex instead of dvipdfm
to generate the <tt>.pdf</tt> document (default <tt>false</tt>).
</dd>
</dl>
<h4><a name="section_296">LaTeXDocument</a></h4>

<p>
The <tt>LaTeXDocument</tt> produces a LaTeX document.
<p>
<tt>LaTeXDocument(&lt;name&gt;, &lt;texfiles&gt;)</tt>
<p>
The document <tt>&lt;name&gt;</tt> and <tt>&lt;texfiles&gt;</tt> are listed without suffixes. This function
returns the filenames for the generated <tt>.ps</tt> and <tt>.pdf</tt> files.
<p>
Additional variables used:
<dl compact>
<dt>TEXINPUTS</dt>
<dd> The LaTeX search path (an array of directories, default is
taken from the <tt>TEXINPUTS</tt> environment variable).
</dd>
<dt>TEXDEPS</dt>
<dd> Additional files this document depends on.
</dd>
</dl>
<h4><a name="section_297">TeXGeneratedFiles, LocalTeXGeneratedFiles</a></h4>

<pre>
TeXGeneratedFiles(files)
LocalTeXGeneratedFiles(files)
</pre>
<p>
The <tt>TeXGeneratedFiles</tt> and <tt>LocalTeXGeneratedFiles</tt> functions specify files
that need to be generated before any LaTeXfiles are scanned for dependencies. For example,
if <tt>config.tex</tt> and <tt>inputs.tex</tt> are both generated files, specify:
<pre>
TeXGeneratedFiles(config.tex inputs.tex)
</pre>
<p>
The <tt>TeXGeneratedFiles</tt> function is <em>global</em>
--- its arguments will be generated
before any TeX files anywhere in the project are scanned for dependencies. The
<tt>LocalTeXGeneratedFiles</tt> function follows the normal scoping rules of OMake.
<p>
<h4><a name="section_298">LaTeXDocumentCopy</a></h4>

<p>
The <tt>LaTeXDocumentCopy</tt> copies the document to an install location.
<p>
<tt>LaTeXDocumentCopy(&lt;tag&gt;, &lt;libdir&gt;, &lt;installname&gt;, &lt;docname&gt;)</tt>
<p>
This function copies just the <tt>.pdf</tt> and <tt>.ps</tt> files.
<h4><a name="section_299">LaTeXDocumentInstall</a></h4>

<p>
The <tt>LaTeXDocumentInstall</tt> builds a document and copies it to an
install location in one step.
<p>
<tt>LaTeXDocumentInstall(&lt;tag&gt;, &lt;libdir&gt;, &lt;installname&gt;, &lt;docname&gt;, &lt;files&gt;)</tt>
<h2><a name="section_300">Examining the dependency graph</a></h2>

<h4><a name="section_301">dependencies, dependencies-all</a></h4>

<p>
<pre>
   $(dependencies targets) : File Array
   $(dependencies-all targets) : File Array
   $(dependencies-proper targets) : File Array
      targets : File Array
   raises RuntimeException
</pre>
<p>
The <tt>dependencies</tt> function returns the set of immediate dependencies of
the given targets. This function can only be used within a rule body and
all the arguments to the <tt>dependency</tt> function must also be dependencies of
this rule. This restriction ensures that all the dependencies are known when
this function is executed.
<p>
The <tt>dependencies-all</tt> function is similar, but it expands the dependencies
recursively, returning all of the dependencies of a target, not just the immediate
ones.
<p>
The <tt>dependencies-proper</tt> function returns all recursive dependencies, except
the dependencies that are leaf targets. A leaf target is a target that has no
dependencies and no build commands; a leaf target corresponds to a source file
in the current project.
<p>
In all three functions, files that are not part of the current project are silently
discarded.
<p>
One purpose of the <tt>dependencies-proper</tt> function is for &ldquo;clean&rdquo; targets.
For example, one way to delete all intermediate files in a build is with a rule
that uses the <tt>dependencies-proper</tt>. Note however, that the rule requires
building the project before it can be deleted. For a shorter form, see the
<tt>filter-proper-targets</tt> function.
<p>
<pre>
    .PHONY: clean

    APP = ...     # the name of the target application
    clean: $(APP)
       rm $(dependencies-proper $(APP))
</pre>
<p>
<h4><a name="section_302">target</a></h4>

<pre>
   $(target targets) : Rule Array
      targets : File Sequence
   raises RuntimeException
</pre>
<p>
The <tt>target</tt> function returns the Target object associated with each
of the targets. See the <tt>Target</tt> object for more information.
<h4><a name="section_303">rule</a></h4>

<p>
The <tt>rule</tt> function is called whenever a build rule is defined.
It is unlikely that you will need to redefine this function, except in
very exceptional cases.
<p>
<pre>
   rule(multiple, target, pattern, sources, options, body) : Rule
      multiple : String
      target   : Sequence
      pattern  : Sequence
      sources  : Sequence
      options  : Array
      body     : Body
</pre>
<p>
The <tt>rule</tt> function is called when a rule is evaluated.
<p>
<dl compact>
<dt>multiple</dt>
<dd> A Boolean value indicating whether the rule was defined
with a double colon <tt>::</tt>.
</dd>
<dt>target</dt>
<dd> The sequence of target names.
</dd>
<dt>pattern</dt>
<dd> The sequence of patterns. This sequence will be empty
for two-part rules.
</dd>
<dt>sources</dt>
<dd> The sequence of dependencies.
</dd>
<dt>options</dt>
<dd> An array of options. Each option is represented
as a two-element array with an option name, and the option value.
</dd>
<dt>body</dt>
<dd> The body expression of the rule.
</dd>
</dl>
<p>
Consider the following rule.
<p>
<pre>
   target: pattern: sources :name1: option1 :name2: option2
      expr1
      expr2
</pre>
<p>
This expression represents the following function call, where
square brackets are used to indicate arrays.
<p>
<pre>
   rule(false, target, pattern, sources,
        [[:name1:, option1], [:name2:, option2]]
        [expr1; expr2])
</pre>
<h2><a name="section_304">References</a></h2>

<p>
<h4><a name="section_305">See Also</a></h4>

<p>
<a href="omake.html">omake(1)</a>,
<a href="omake-quickstart.html">omake-quickstart(1)</a>,
<a href="omake-options.html">omake-options(1)</a>,
<a href="omake-root.html">omake-root(1)</a>,
<a href="omake-language.html">omake-language(1)</a>,
<a href="omake-shell.html">omake-shell(1)</a>,
<a href="omake-rules.html">omake-rules(1)</a>,
<a href="omake-base.html">omake-base(1)</a>,
<a href="omake-system.html">omake-system(1)</a>,
<a href="omake-pervasives.html">omake-pervasives(1)</a>,
<a href="osh.html">osh(1)</a>,
<em>make</em>(1)
<p>
<h4><a name="section_306">Version</a></h4>

<p>
Version: 0.9.6.9 of April 11, 2006.
<p>
<h4><a name="section_307">License and Copyright</a></h4>

<p>
&copy;2003-2006, Mojave Group, Caltech
<p>
This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.
<p>
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.
<p>
You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
<p>
<h4><a name="section_308">Author</a></h4>

<p>
Jason Hickey <em>et. al.</em><br>
Caltech 256-80 <br>

Pasadena, CA 91125, USA <br>

Email: <a href ="mailto:omake-devel@metaprl.org"><tt>omake-devel@metaprl.org</tt></a>
<br>
WWW: <a href ="http://www.cs.caltech.edu/~jyh"><tt>http://www.cs.caltech.edu/~jyh</tt></a>
<p>
</body>
</html>
<!-- NOTE: This file is generated, DO NOT EDIT. -->
