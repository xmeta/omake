<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>



<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.08">
<LINK rel="stylesheet" type="text/css" href="omake-doc.css">
<TITLE>
Additional language examples
</TITLE>
</HEAD>
<BODY >
<A HREF="omake-language.html"><IMG SRC ="previous_motif.gif" ALT="Previous"></A>
<A HREF="omake-toc.html"><IMG SRC ="contents_motif.gif" ALT="Up"></A>
<A HREF="omake-rules.html"><IMG SRC ="next_motif.gif" ALT="Next"></A>
<HR>
<A HREF="http://omake.metaprl.org/">OMake Home</A>
<A HREF="omake-toc.html">Table of contents</A>
<A HREF="omake.html">Guide</A>
<A HREF="omake-options.html">Options</A>
<A HREF="omake-all-index.html">Index</A>
<A HREF="omake-var-index.html">Variables</A>
<A HREF="omake-fun-index.html">Functions</A>
<A HREF="omake-obj-index.html">Objects</A>
<A HREF="omake-target-index.html">Targets</A>

<H1 CLASS="chapter"><A NAME="htoc51">Chapter&nbsp;5</A>&nbsp;&nbsp;Additional language examples</H1>
<A NAME="chapter:language-examples"></A>
<BR>
<BR>
In this section, we'll explore the core language through a series of examples (examples of the build
system are the topic of the Chapter&nbsp;<A HREF="omake-build-examples.html#chapter:build-examples">3</A>).<BR>
<BR>
For most of these examples, we'll use the <CODE>osh</CODE> command interpreter. For simplicity, the
values printed by <CODE>osh</CODE> have been abbreviated.<BR>
<BR>
<A NAME="toc38"></A>
<H2 CLASS="section"><A NAME="htoc52">5.1</A>&nbsp;&nbsp;Strings and arrays</H2>
The basic OMake values are strings, sequences, and arrays of values. Sequences are like arrays of
values separated by whitespace; the sequences are split on demand by functions that expect arrays.
<PRE CLASS="verbatim">
   osh&gt; X = 1 2
   - : "1 2" : Sequence
   osh&gt; addsuffix(.c, $X)
   - : &lt;array 1.c 2.c&gt; : Array
</PRE>
Sometimes you want to define an array explicitly. For this, use the <CODE>[]</CODE> brackets after the
variable name, and list each array entry on a single indented line.
<PRE CLASS="verbatim">
   osh&gt; A[] =
           Hello world
           $(getenv HOME)
   - : &lt;array "Hello world" "/home/jyh"&gt; : Array
</PRE>
One central property of arrays is that whitespace in the elements is significant. This can be
useful, especially for filenames that contain whitespace. 
<PRE CLASS="verbatim">
   # List the current files in the directory
    osh&gt; ls -Q
    "fee"  "fi"  "foo"  "fum"
    osh&gt; NAME[] = 
            Hello world
    - : &lt;array "Hello world"&gt; : Array
    osh&gt; touch $(NAME)
    osh&gt; ls -Q
    "fee"  "fi"  "foo"  "fum"  "Hello world"
</PRE>
<A NAME="toc39"></A>
<H2 CLASS="section"><A NAME="htoc53">5.2</A>&nbsp;&nbsp;Files and directories</H2>
OMake projects usually span multiple directories, and different parts of the project execute
commands in different directories. There is a need to define a location-independent name for a file
or directory.<BR>
<BR>
This is done with the <CODE>$(file &lt;names&gt;)</CODE> and <CODE>$(dir &lt;names&gt;)</CODE> functions.
<PRE CLASS="verbatim">
   osh&gt; mkdir tmp
   osh&gt; F = $(file fee)
   osh&gt; section:
            cd tmp
            echo $F
   ../fee
   osh&gt; echo $F
   fee
</PRE>
Note the use of a <CODE>section:</CODE> to limit the scope of the <CODE>cd</CODE> command. The section
temporarily changes to the <CODE>tmp</CODE> directory where the name of the file is <CODE>../fee</CODE>. Once
the section completes, we are still in the current directory, where the name of the file is
<CODE>fee</CODE>.<BR>
<BR>
One common way to use the file functions is to define proper file names in your project
<CODE>OMakefile</CODE>, so that references within the various parts of the project will refer to the same
file.
<PRE CLASS="verbatim">
    osh&gt; cat OMakefile
    ROOT = $(dir .)
    TMP  = $(dir tmp)
    BIN  = $(dir bin)
    ...
</PRE>
<A NAME="toc40"></A>
<H2 CLASS="section"><A NAME="htoc54">5.3</A>&nbsp;&nbsp;Iteration, mapping, and foreach</H2>
Most builtin functions operate transparently on arrays.
<PRE CLASS="verbatim">
    osh&gt; addprefix(-D, DEBUG WIN32)
    - : -DDEBUG -DWIN32 : Array
    osh&gt; mapprefix(-I, /etc /tmp)
    - : -I /etc -I /tmp : Array
    osh&gt; uppercase(fee fi foo fum)
    - : FEE FI FOO FUM : Array
</PRE>
The <CODE>mapprefix</CODE> and <CODE>addprefix</CODE> functions are slightly different (the <CODE>addsuffix</CODE> and
<CODE>mapsuffix</CODE> functions are similar). The <CODE>addprefix</CODE> adds the prefex to each array
element. The <CODE>mapprefix</CODE> doubles the length of the array, adding the prefix as a new array
element before each of the original elements.<BR>
<BR>
Even though most functions work on arrays, there are times when you will want to do it yourself.
The <CODE>foreach</CODE> function is the way to go. The <CODE>foreach</CODE> function has two forms, but the
form with a body is most useful. In this form, the function takes two arguments and a body. The
second argument is an array, and the first is a variable. The body is evaluated once for each
element of the array, where the variable is bound to the element. Let's define a function to add 1
to each element of an array of numbers.
<PRE CLASS="verbatim">
   osh&gt; add1(l) =
            foreach(i, $l):
                add($i, 1)
   osh&gt; add1(7 21 75)
   - : 8 22 76 : Array
</PRE>
Sometimes you have an array of filenames, and you want to define a rule for each of them. Rules are
not special, you can define them anywhere a statement is expected. Say we want to write a function
that describes how to process each file, placing the result in the <CODE>tmp/</CODE> directory.
<PRE CLASS="verbatim">
   TMP = $(dir tmp)

   my-special-rule(files) =
      foreach(name, $(files))
         $(TMP)/$(name): $(name)
            process $&lt; &gt; $@
</PRE>
Later, in some other part of the project, we may decide that we want to use this function to process some files.
<PRE CLASS="verbatim">
   # These are the files to process in src/lib
   MY_SPECIAL_FILES[] =
       fee.src
       fi.src
       file with spaces in its name.src
   my-special-rule($(MY_SPECIAL_FILES))
</PRE>
The result of calling <CODE>my-special-rule</CODE> is
exactly the same as if we had written the following three rules explicitly.
<PRE CLASS="verbatim">
    $(TMP)/fee.src: fee.src
        process fee &gt; $@
    $(TMP)/fi.src: fi.src
        process fi.src &gt; $@
    $(TMP)/$"file with spaces in its name.src": $"file with spaces in its name.src"
        process $&lt; &gt; $@
</PRE>
Of course, writing these rules is not nearly as pleasant as calling the function. The usual
properties of function abstraction give us the usual benefits. The code is less redundant, and
there is a single location (the <CODE>my-special-rule</CODE> function) that defines the build rule.
Later, if we want to modify/update the rule, we need do so in only one location.<BR>
<BR>
<A NAME="toc41"></A>
<H2 CLASS="section"><A NAME="htoc55">5.4</A>&nbsp;&nbsp;Lazy expressions</H2>
<A NAME="section:lazy"></A>
Lazy expressions are expressions that are not evaluated until their result is needed. Some people,
including this author, frown on overuse of lazy expressions, mainly because it is difficult to know
when evaluation actually happens. However, there are cases where they pay off.<BR>
<BR>
One example comes from option processing. Consider the specification of &#8220;include&#8221; directories on
the command line for a C compiler. If we want to include files from /home/jyh/include and ../foo,
we specify it on the command line with the options <CODE>-I/home/jyh/include -I../foo</CODE>.<BR>
<BR>
Suppose we want to define a generic rule for building C files. We could define a <CODE>INCLUDES</CODE>
array to specify the directories to be included, and then define a generic implicit rule in our root
OMakefile.
<PRE CLASS="verbatim">
    # Generic way to compile C files.
    CFLAGS = -g
    INCLUDES[] =
    %.o: %.c
       $(CC) $(CFLAGS) $(INCLUDES) -c $&lt;

    # The src directory builds my_widget+ from 4 source files.
    # It reads include files from the include directory.
    .SUBDIRS: src
        FILES = fee fi foo fum
        OFILES = $(addsuffix .o, $(FILES))
        INCLUDES[] += -I../include
        my_widget: $(OFILES)
           $(CC) $(CFLAGS) -o $@ $(OFILES)
</PRE>
But this is not quite right. The problem is that INCLUDES is an array of options, not directories.
If we later wanted to recover the directories, we would have to strip the leading <CODE>-I</CODE> prefix,
which is a hassle. Furthermore, we aren't using proper names for the directories. The solution
here is to use a lazy expression. We'll define INCLUDES as a directory array, and a new variable
<CODE>PREFIXED_INCLUDES</CODE> that adds the -I prefix. The <CODE>PREFIXED_INCLUDES</CODE> is computed lazily,
ensuring that the value uses the most recent value of the INCLUDES variable.
<PRE CLASS="verbatim">
    # Generic way to compile C files.
    CFLAGS = -g
    INCLUDES[] =
    PREFIXED_INCLUDES[] = $`(addprefix -I, $(INCLUDES))
    %.o: %.c
       $(CC) $(CFLAGS) $(PREFIXED_INCLUDES) -c $&lt;

    # For this example, we define a proper name for the include directory
    STDINCLUDE = $(dir include)

    # The src directory builds my_widget+ from 4 source files.
    # It reads include files from the include directory.
    .SUBDIRS: src
        FILES = fee fi foo fum
        OFILES = $(addsuffix .o, $(FILES))
        INCLUDES[] += $(STDINCLUDE)
        my_widget: $(OFILES)
           $(CC) $(CFLAGS) -o $@ $(OFILES)
</PRE>
Note that there is a close connection between lazy values and functions. In the example above, we
could equivalently define <CODE>PREFIXED_INCLUDES</CODE> as a function with zero arguments.
<PRE CLASS="verbatim">
    PREFIXED_INCLUDES() =
        addprefix(-I, $(INCLUDES))
</PRE>
<A NAME="toc42"></A>
<H2 CLASS="section"><A NAME="htoc56">5.5</A>&nbsp;&nbsp;Scoping and exports</H2>
The OMake language is functional (apart from IO and shell commands). This comes in two parts:
functions are first-class, and variables are immutable (there is no assignment operator). The
latter property may seem strange to users used to GNU make, but it is actually a central point of
OMake. Since variables can't be modified, it is impossible (or at least hard) for one part of the
project to interfere with another.<BR>
<BR>
To be sure, pure functional programming can be awkward. In OMake, each new indentation level
introduces a new scope, and new definitions in that scope are lost when the scope ends. If OMake
were overly strict about scoping, we would wind up with a lot of convoluted code.
<PRE CLASS="verbatim">
   osh&gt; X = 1
   osh&gt; setenv(BOO, 12)
   osh&gt; if $(equal $(OSTYPE), Win32)
            setenv(BOO, 17)
            X = 2
   osh&gt; println($X $(getenv BOO))
   1 12
</PRE>
The <CODE>export</CODE> command presents a way out. It takes care of &#8220;exporting&#8221; a value (or the entire
variable environment) from an inner scope to an outer one.
<PRE CLASS="verbatim">
   osh&gt; X = 1
   osh&gt; setenv(BOO, 12)
   osh&gt; if $(equal $(OSTYPE), Win32)
            setenv(BOO, 17)
            X = 2
            export
   osh&gt; println($X $(getenv BOO))
   2 17
</PRE>
Exports are especially useful in loop to export values from one iteration of a loop to the next.
<PRE CLASS="verbatim">
   # Ok, let's try to add up the elements of the array
   osh&gt;sum(l) =
           total = 0
           foreach(i, $l)
               total = $(add $(total), $i)
           value $(total)
   osh&gt;sum(1 2 3)
   - : 0 : Int

   # Oops, that didn't work!
   osh&gt;sum(l) =
           total = 0
           foreach(i, $l)
               total = $(add $(total), $i)
               export
           value $(total)
   osh&gt;sum(1 2 3)
   - : 6 : Int
</PRE>
A <CODE>while</CODE> loop is another form of loop, with an auto-export.
<PRE CLASS="verbatim">
    osh&gt;i = 0
    osh&gt;total = 0
    osh&gt;while $(lt $i, 10)
            total = $(add $(total), $i)
            i = $(add $i, 1)
    osh&gt;println($(total))
    45
</PRE>
<A NAME="toc43"></A>
<H2 CLASS="section"><A NAME="htoc57">5.6</A>&nbsp;&nbsp;Shell aliases</H2>
Sometimes you may want to define an <EM>alias</EM>, an OMake command that masquerades as a real shell
command. You can do this by adding your function as a method to the <CODE>Shell</CODE> object.<BR>
<BR>
For an example, suppose we use the <CODE>awk</CODE> function to print out all the comments in a file.
<PRE CLASS="verbatim">
    osh&gt;cat comment.om
    # Comment function
    comments(filename) =
        awk($(filename))
        case $'^#'
            println($0)
    # File finished
    osh&gt;include comment
    osh&gt;comments(comment.om)
    # Comment function
    # File finished
</PRE>
To add it as an alias, add the method (using += to preserve the existing entries in the Shell).
<PRE CLASS="verbatim">
   osh&gt;Shell. +=
           printcom(argv) =
               comments($(nth 0, $(argv)))
   osh&gt;printcom comment.om &gt; output.txt
   osh&gt;cat output.txt
   # Comment function
   # File finished
</PRE>
A shell command is passed an array of arguments <CODE>argv</CODE>. This does <EM>not</EM> include the name
of the alias.<BR>
<BR>
<A NAME="toc44"></A>
<H2 CLASS="section"><A NAME="htoc58">5.7</A>&nbsp;&nbsp;Input/output redirection on the cheap</H2>
As it turns out, scoping also provides a nice alternate way to perform redirection. Suppose you
have already written a lot of code that prints to the standard output channel, but now you decide
you want to redirect it. One way to do it is using the technique in the previous example: define
your function as an alias, and then use shell redirection to place the output where you want.<BR>
<BR>
There is an alternate method that is easier in some cases. The variables <CODE>stdin</CODE>,
<CODE>stdout</CODE>, and <CODE>stderr</CODE> define the standard I/O channels. To redirect output, redefine
these variables as you see fit. Of course, you would normally do this in a nested scope, so that
the outer channels are not affected.
<PRE CLASS="verbatim">
    osh&gt;f() =
            println(Hello world)
    osh&gt;f()
    Hello world
    osh&gt;section:
            stdout = $(fopen output.txt, w)
            f()
            close($(stdout))
    osh&gt;cat output.txt
    Hello world
</PRE>
This also works for shell commands. If you like to gamble, you can try the following example.
<PRE CLASS="verbatim">
    osh&gt;f() =
            println(Hello world)
    osh&gt;f()
    Hello world
    osh&gt;section:
            stdout = $(fopen output.txt, w)
            f()
            cat output.txt
            close($(stdout))
    osh&gt;cat output.txt
    Hello world
    Hello world
</PRE>

<A HREF="http://omake.metaprl.org/">OMake Home</A>
<A HREF="omake-toc.html">Table of contents</A>
<A HREF="omake.html">Guide</A>
<A HREF="omake-options.html">Options</A>
<A HREF="omake-all-index.html">Index</A>
<A HREF="omake-var-index.html">Variables</A>
<A HREF="omake-fun-index.html">Functions</A>
<A HREF="omake-obj-index.html">Objects</A>
<A HREF="omake-target-index.html">Targets</A>
<HR>
<A HREF="omake-language.html"><IMG SRC ="previous_motif.gif" ALT="Previous"></A>
<A HREF="omake-toc.html"><IMG SRC ="contents_motif.gif" ALT="Up"></A>
<A HREF="omake-rules.html"><IMG SRC ="next_motif.gif" ALT="Next"></A>
</BODY>
</HTML>
