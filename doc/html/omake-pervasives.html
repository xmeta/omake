<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>



<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.08">
<LINK rel="stylesheet" type="text/css" href="omake-doc.css">
<TITLE>
Pervasives
</TITLE>
</HEAD>
<BODY >

<img src="images/omake-manual.gif" border="0" align="top"><br>

<TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=left NOWRAP>Jump to:</TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP><A HREF="http://omake.metaprl.org/">OMake Home</A>
&bull;&nbsp;<A HREF="omake.html">Guide Home</A>
&bull;&nbsp;<A HREF="omake-doc.html">Guide (single-page)</A>
&bull;&nbsp;<A HREF="omake-toc.html">Contents (short)</A>
&bull;&nbsp;<A HREF="omake-contents.html">Contents (long)</A></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>Index:</TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP><A HREF="omake-all-index.html">All</A>
&bull;&nbsp;<A HREF="omake-var-index.html">Variables</A>
&bull;&nbsp;<A HREF="omake-fun-index.html">Functions</A>
&bull;&nbsp;<A HREF="omake-obj-index.html">Objects</A>
&bull;&nbsp;<A HREF="omake-target-index.html">Targets</A>
&bull;&nbsp;<A HREF="omake-option-index.html">Options</A></TD>
</TR></TABLE>

<H1 CLASS="chapter"><A NAME="htoc298">Chapter&nbsp;11</A>&nbsp;&nbsp;Pervasives</H1><UL>
<LI><A HREF="omake-pervasives.html#toc85">Pervasives objects</A>
</UL>

<A NAME="chapter:pervasives"></A>
<BR>
<BR>
<CODE>Pervasives</CODE> defines the objects that are defined in all
programs. The following objects are defined.<BR>
<BR>
<A NAME="toc85"></A>
<H2 CLASS="section"><A NAME="htoc299">11.1</A>&nbsp;&nbsp;Pervasives objects</H2>

<H3 CLASS="subsection"><A NAME="htoc300">11.1.1</A>&nbsp;&nbsp;Object</H3><A NAME="@default263"></A><A NAME="@obj6"></A><A NAME="obj:Object"></A>
Parent objects: none.<BR>
<BR>
The <CODE>Object</CODE> object is the root object.
Every class is a subclass of <CODE>Object</CODE>.<BR>
<BR>
It provides the following fields:
<UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>$(o.object-length)</CODE>: the number of fields and methods in the object.
<LI CLASS="li-itemize"><CODE>$(o.object-mem &lt;var&gt;)</CODE>: returns <CODE>true</CODE> iff the <CODE>&lt;var&gt;</CODE> is a field
 or method of the object.
<LI CLASS="li-itemize"><CODE>$(o.object-add &lt;var&gt;, &lt;value&gt;)</CODE>: adds the field to the object,
 returning a new object.
<LI CLASS="li-itemize"><CODE>$(o.object-find &lt;var&gt;)</CODE>: fetches the field or method from the object;
 it is equivalent to <CODE>$(o.&lt;var&gt;)</CODE>, but the variable can be non-constant.
<LI CLASS="li-itemize"><CODE>$(o.object-map &lt;fun&gt;)</CODE>: maps a function over the object. The function
 should take two arguments; the first is a field name, the second is the
 value of that field. The result is a new object constructed from the
 values returned by the function.
<LI CLASS="li-itemize"><CODE>o.object-foreach</CODE>: the <CODE>foreach</CODE> form is equivalent to <CODE>map</CODE>,
 but with altered syntax.
<PRE CLASS="verbatim">
   o.foreach(&lt;var1&gt;, &lt;var2&gt;)
      &lt;body&gt;
   </PRE>
 For example, the following function prints all the fields of an
 object <CODE>o</CODE>.
<PRE CLASS="verbatim">
   PrintObject(o) =
      o.foreach(v, x)
         println($(v) = $(x))
   </PRE>
 The <CODE>export</CODE> form is valid in a <CODE>foreach</CODE> body. The following
 function collects just the field names of an object.
<PRE CLASS="verbatim">
   FieldNames(o) =
      names =
      o.foreach(v, x)
         names += $(v)
         export
      return $(names)
   </PRE></UL>

<H3 CLASS="subsection"><A NAME="htoc301">11.1.2</A>&nbsp;&nbsp;Map</H3><A NAME="@default264"></A><A NAME="@obj7"></A><A NAME="obj:Map"></A>
Parent objects: <CODE>Object</CODE>.<BR>
<BR>
A <CODE>Map</CODE> object is a dictionary from values to values. The <CODE>&lt;key&gt;</CODE>
values are restricted to simple values: integers, floating-point numbers,
strings, files, directories, and arrays of simple values.<BR>
<BR>
The Map object provides the following methods.
<UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>$(o.mem &lt;key&gt;)</CODE>: returns <CODE>true</CODE> iff the <CODE>&lt;key&gt;</CODE> is defined
 in the map.
<LI CLASS="li-itemize"><CODE>$(o.add &lt;key&gt;, &lt;value&gt;)</CODE>: adds the field to the map,
 returning a new map.
<LI CLASS="li-itemize"><CODE>$(o.find &lt;key&gt;)</CODE>: fetches the field from the map.
<LI CLASS="li-itemize"><CODE>$(o.map &lt;fun&gt;)</CODE>: maps a function over the map. The function
 should take two arguments; the first is a field name, the second is the
 value of that field. The result is a new object constructed from the
 values returned by the function.
<LI CLASS="li-itemize"><CODE>o.foreach</CODE>: the <CODE>foreach</CODE> form is equivalent to <CODE>map</CODE>,
 but with altered syntax.
<PRE CLASS="verbatim">
   o.foreach(&lt;var1&gt;, &lt;var2&gt;)
      &lt;body&gt;
   </PRE>
 For example, the following function prints all the fields of an
 object <CODE>o</CODE>.
<PRE CLASS="verbatim">
   PrintObject(o) =
      o.foreach(v, x)
         println($(v) = $(x))
   </PRE>
 The <CODE>export</CODE> form is valid in a <CODE>foreach</CODE> body. The following
 function collects just the field names of the map.
<PRE CLASS="verbatim">
   FieldNames(o) =
      names =
      o.foreach(v, x)
         names += $(v)
         export
      return $(names)
   </PRE></UL>
There is also simpler syntax when the key is a string. The table can be
defined using definitions with the form <CODE>$|key|</CODE>
(the number of pipe symbols <CODE>|</CODE> is allowed to vary).
<PRE CLASS="verbatim">
    $|key 1| = value1
    $||key1|key2|| = value2    # The key is key1|key2
    X = $|key 1|               # Define X to be the value of field $|key 1|
</PRE>
The usual modifiers are also allowed. The expression <CODE>$`|key|</CODE> represents
lazy evaluation of the key, and <CODE>$,|key|</CODE> is normal evaluation.<BR>
<BR>

<H3 CLASS="subsection"><A NAME="htoc302">11.1.3</A>&nbsp;&nbsp;Number</H3><A NAME="@default265"></A><A NAME="@obj8"></A><A NAME="obj:Number"></A>
Parent objects: <CODE>Object</CODE>.<BR>
<BR>
The <CODE>Number</CODE> object is the parent object for integers
and floating-point numbers.

<H3 CLASS="subsection"><A NAME="htoc303">11.1.4</A>&nbsp;&nbsp;Int</H3><A NAME="@default266"></A><A NAME="@obj9"></A><A NAME="obj:Int"></A>
Parent objects: <CODE>Number</CODE>.<BR>
<BR>
The <CODE>Int</CODE> object represents integer values.

<H3 CLASS="subsection"><A NAME="htoc304">11.1.5</A>&nbsp;&nbsp;Float</H3><A NAME="@default267"></A><A NAME="@obj10"></A><A NAME="obj:Float"></A>
Parent objects: <CODE>Number</CODE>.<BR>
<BR>
The <CODE>Float</CODE> object represents floating-point numbers.

<H3 CLASS="subsection"><A NAME="htoc305">11.1.6</A>&nbsp;&nbsp;Sequence</H3><A NAME="@default268"></A><A NAME="@obj11"></A><A NAME="obj:Sequence"></A>
Parent objects: <CODE>Object</CODE>.<BR>
<BR>
The <CODE>Sequence</CODE> object represents a generic object containing
sequential elements. It provides the following methods.
<UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>$(s.length)</CODE>: the number of elements in the sequence.
<LI CLASS="li-itemize"><CODE>$(s.map &lt;fun&gt;)</CODE>: maps a function over the fields in the sequence.
 The function should take one argument. The result is a new sequence
 constructed from the values returned by the function.
<LI CLASS="li-itemize"><CODE>s.foreach</CODE>: the <CODE>foreach</CODE> form is equivalent to <CODE>map</CODE>,
 but with altered syntax.
<PRE CLASS="verbatim">
   s.foreach(&lt;var&gt;)
      &lt;body&gt;
   </PRE>
 For example, the following function prints all the elements of the sequence.
<PRE CLASS="verbatim">
   PrintSequence(s) =
      s.foreach(x)
         println(Elem = $(x))
   </PRE>
 The <CODE>export</CODE> form is valid in a <CODE>foreach</CODE> body. The following
 function counts the number of zeros in the sequence.
<PRE CLASS="verbatim">
   Zeros(s) =
      count = $(int 0)
      s.foreach(v)
         if $(equal $(v), 0)
            count = $(add $(count), 1)
            export
         export
      return $(count)
   </PRE></UL>

<H3 CLASS="subsection"><A NAME="htoc306">11.1.7</A>&nbsp;&nbsp;Array</H3><A NAME="@default269"></A><A NAME="@obj12"></A><A NAME="obj:Array"></A>
Parent objects: <CODE>Sequence</CODE>.<BR>
<BR>
The <CODE>Array</CODE> is a random-access sequence.
It provides the following additional methods.
<UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>$(s.nth &lt;i&gt;)</CODE>: returns element <CODE>i</CODE> of the sequence.
<LI CLASS="li-itemize"><CODE>$(s.rev &lt;i&gt;)</CODE>: returns the reversed sequence.
</UL>

<H3 CLASS="subsection"><A NAME="htoc307">11.1.8</A>&nbsp;&nbsp;String</H3><A NAME="@default270"></A><A NAME="@obj13"></A><A NAME="obj:String"></A>
Parent objects: <CODE>Array</CODE>.

<H3 CLASS="subsection"><A NAME="htoc308">11.1.9</A>&nbsp;&nbsp;Fun</H3><A NAME="@default271"></A><A NAME="@obj14"></A><A NAME="obj:Fun"></A>
Parent objects: <CODE>Object</CODE>.<BR>
<BR>
The <CODE>Fun</CODE> object provides the following methods.
<UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>$(f.arity)</CODE>: the arity if the function.
</UL>

<H3 CLASS="subsection"><A NAME="htoc309">11.1.10</A>&nbsp;&nbsp;Rule</H3><A NAME="@default272"></A><A NAME="@obj15"></A><A NAME="obj:Rule"></A>
Parent objects: <CODE>Object</CODE>.<BR>
<BR>
The <CODE>Rule</CODE> object represents a build rule.
It does not currently have any methods.

<H3 CLASS="subsection"><A NAME="htoc310">11.1.11</A>&nbsp;&nbsp;Target</H3><A NAME="@default273"></A><A NAME="@obj16"></A><A NAME="obj:Target"></A>
Parent object: <CODE>Object</CODE>.<BR>
<BR>
The <CODE>Target</CODE> object contains information collected for
a specific target file.
<UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>target</CODE>: the target file.
<LI CLASS="li-itemize"><CODE>effects</CODE>: the files that may be modified by a
 side-effect when this target is built.
<LI CLASS="li-itemize"><CODE>scanner_deps</CODE>: static dependencies that must be built
 before this target can be scanned.
<LI CLASS="li-itemize"><CODE>static-deps</CODE>: statically-defined build dependencies
 of this target.
<LI CLASS="li-itemize"><CODE>build-deps</CODE>: all the build dependencies for the target,
 including static and scanned dependencies.
<LI CLASS="li-itemize"><CODE>build-values</CODE>: all the value dependencies associated
 with the build.
<LI CLASS="li-itemize"><CODE>build-commands</CODE>: the commands to build the target.
<LI CLASS="li-itemize"><CODE>output-file</CODE>: if output was diverted to a file,
 with one of the <CODE>--divert-*</CODE> options&nbsp;<A HREF="omake-options.html#chapter:options">A</A>,
 this field names that file. Otherwise it is <CODE>false</CODE>.
</UL>
The object supports the following methods.
<UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>find(file)</CODE>: returns a Target object for the given file.
 Raises a <CODE>RuntimeException</CODE> if the specified target is
 not part of the project.
<LI CLASS="li-itemize"><CODE>find-optional(file)</CODE>: returns a <CODE>Target</CODE> object
 for the given file, or <CODE>false</CODE> if the file is not
 part of the project.
</UL>
NOTE: the information for a target is constructed dynamically,
so it is possible that the <CODE>Target</CODE> object for a node will
contain different values in different contexts. The easiest way
to make sure that the <CODE>Target</CODE> information is complete is
to compute it within a rule body, where the rule depends on
the target file, or the dependencies of the target file.

<H3 CLASS="subsection"><A NAME="htoc311">11.1.12</A>&nbsp;&nbsp;Node</H3><A NAME="@default274"></A><A NAME="@obj17"></A><A NAME="obj:Node"></A>
Parent objects: <CODE>Object</CODE>.<BR>
<BR>
The <CODE>Node</CODE> object is the parent object for files and directories.
It supports the following operations.
<UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>$(node.stat)</CODE>: returns a <CODE>stat</CODE> object for the file. If the
file is a symbolic link, the <CODE>stat</CODE> information is for the destination of
the link, not the link itself.<BR>
<BR>
<LI CLASS="li-itemize"><CODE>$(node.lstat)</CODE>: returns a <CODE>stat</CODE> object for the file or symbolic link.
<LI CLASS="li-itemize"><CODE>$(node.unlink)</CODE>: removes the file.
<LI CLASS="li-itemize"><CODE>$(node.rename &lt;file&gt;)</CODE>: renames the file.
<LI CLASS="li-itemize"><CODE>$(node.link &lt;file&gt;)</CODE>: creates a hard link <CODE>&lt;dst&gt;</CODE> to this file.
<LI CLASS="li-itemize"><CODE>$(node.symlink &lt;file&gt;)</CODE>: create a symbolic link <CODE>&lt;dst&gt;</CODE> to this file.
<LI CLASS="li-itemize"><CODE>$(node.chmod &lt;perm&gt;)</CODE>: change the permission of this file.
<LI CLASS="li-itemize"><CODE>$(node.chown &lt;uid&gt;, &lt;gid&gt;)</CODE>: change the owner and group id of this file.
</UL>

<H3 CLASS="subsection"><A NAME="htoc312">11.1.13</A>&nbsp;&nbsp;File</H3><A NAME="@default275"></A><A NAME="@obj18"></A><A NAME="obj:File"></A>
Parent objects: <CODE>Node</CODE>.<BR>
<BR>
The file object represents the name of a file.

<H3 CLASS="subsection"><A NAME="htoc313">11.1.14</A>&nbsp;&nbsp;Dir</H3><A NAME="@default276"></A><A NAME="@obj19"></A><A NAME="obj:Dir"></A>
Parent objects: <CODE>Node</CODE>.<BR>
<BR>
The <CODE>Dir</CODE> object represents the name of a directory.

<H3 CLASS="subsection"><A NAME="htoc314">11.1.15</A>&nbsp;&nbsp;Channel</H3><A NAME="@default277"></A><A NAME="@obj20"></A><A NAME="obj:Channel"></A>
Parent objects: <CODE>Object</CODE>.<BR>
<BR>
A <CODE>Channel</CODE> is a generic IO channel.
It provides the following methods.
<UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>$(o.close)</CODE>: close the channel.
</UL>

<H3 CLASS="subsection"><A NAME="htoc315">11.1.16</A>&nbsp;&nbsp;InChannel</H3><A NAME="@default278"></A><A NAME="@obj21"></A><A NAME="obj:InChannel"></A>
Parent objects: <CODE>Channel</CODE>.<BR>
<BR>
A <CODE>InChannel</CODE> is an input channel. The variable <CODE>stdin</CODE> is the
standard input channel.<BR>
<BR>
It provides the following methods.
<UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>$(InChannel.fopen &lt;file&gt;)</CODE>: open a new input channel.
<LI CLASS="li-itemize"><CODE>$(InChannel.of-string &lt;string&gt;)</CODE>: open a new input channel,
using a string as input.
</UL>

<H3 CLASS="subsection"><A NAME="htoc316">11.1.17</A>&nbsp;&nbsp;OutChannel</H3><A NAME="@default279"></A><A NAME="@obj22"></A><A NAME="obj:OutChannel"></A>
Parent object: <CODE>Channel</CODE>.<BR>
<BR>
A <CODE>OutChannel</CODE> is an output channel. The variables <CODE>stdout</CODE>
and <CODE>stderr</CODE> are the standard output and error channels.<BR>
<BR>
It provides the following methods.
<UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>$(OutChannel.fopen &lt;file&gt;)</CODE>: open a new output channel.
<LI CLASS="li-itemize"><CODE>$(OutChannel.string)</CODE>: open a new output channel,
writing to a string.
<LI CLASS="li-itemize"><CODE>$(OutChannel.to-string)</CODE>: get the current string of
output, for an output channel created as <CODE>OutChannel.open-string</CODE>.
<LI CLASS="li-itemize"><CODE>$(OutChannel.append &lt;file&gt;)</CODE>: opens a new output channel,
appending to the file.
<LI CLASS="li-itemize"><CODE>$(c.flush)</CODE>: flush the output channel.
<LI CLASS="li-itemize"><CODE>$(c.print &lt;string&gt;)</CODE>: print a string to the channel.
<LI CLASS="li-itemize"><CODE>$(c.println &lt;string&gt;)</CODE>: print a string to the channel,
followed by a line terminator.
</UL>

<H3 CLASS="subsection"><A NAME="htoc317">11.1.18</A>&nbsp;&nbsp;Location</H3><A NAME="@default280"></A><A NAME="@obj23"></A><A NAME="obj:Location"></A>
Parent objects: <CODE>Location</CODE>.<BR>
<BR>
The <CODE>Location</CODE> object represents a location in a file.

<H3 CLASS="subsection"><A NAME="htoc318">11.1.19</A>&nbsp;&nbsp;Position</H3><A NAME="@default281"></A><A NAME="@obj24"></A><A NAME="obj:Position"></A>
Parent objects: <CODE>Position</CODE>.<BR>
<BR>
The <CODE>Position</CODE> object represents a stack trace.

<H3 CLASS="subsection"><A NAME="htoc319">11.1.20</A>&nbsp;&nbsp;Exception</H3><A NAME="@default282"></A><A NAME="@obj25"></A><A NAME="obj:Exception"></A>
Parent objects: <CODE>Object</CODE>.<BR>
<BR>
The <CODE>Exception</CODE> object is used as the base object for exceptions.
It has no fields.

<H3 CLASS="subsection"><A NAME="htoc320">11.1.21</A>&nbsp;&nbsp;RuntimeException</H3><A NAME="@default283"></A><A NAME="@obj26"></A><A NAME="obj:RuntimeException"></A>
Parent objects: <CODE>Exception</CODE>.<BR>
<BR>
The <CODE>RuntimeException</CODE> object represents an exception from the
runtime system. It has the following fields.
<UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>position</CODE>: a string representing the location where the
 exception was raised.
<LI CLASS="li-itemize"><CODE>message</CODE>: a string containing the exception message.
</UL>

<H3 CLASS="subsection"><A NAME="htoc321">11.1.22</A>&nbsp;&nbsp;UnbuildableException</H3><A NAME="@default284"></A><A NAME="@obj27"></A><A NAME="obj:UnbuildableException"></A>
Parent objects: <CODE>Exception</CODE>.<BR>
<BR>
The <CODE>UnbuildableException</CODE> object should be used to signal that a target
is not buildable. It will be caught by functions such as
<CODE>target-exists</CODE>&nbsp;<A HREF="omake-system.html#fun:target-exists">9.3.1</A>.
This exception has the following fields:
<UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>target</CODE>: indicates which target is not buildable.
<LI CLASS="li-itemize"><CODE>message</CODE>: a string containing the exception message.
</UL>

<H3 CLASS="subsection"><A NAME="htoc322">11.1.23</A>&nbsp;&nbsp;Shell</H3><A NAME="@default285"></A><A NAME="@obj28"></A><A NAME="obj:Shell"></A>
Parent objects: <CODE>Object</CODE>.<BR>
<BR>
The <CODE>Shell</CODE> object contains the collection of builtin functions
available as shell commands.<BR>
<BR>
You can define aliases by extending this object with additional methods.
All methods in this class are called with one argument: a single array
containing an argument list.
<UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>echo</CODE><BR>
<BR>
The <CODE>echo</CODE> function prints its arguments to the standard output channel.
<LI CLASS="li-itemize"><CODE>jobs</CODE><BR>
<BR>
The <CODE>jobs</CODE> method prints the status of currently running commands.
<LI CLASS="li-itemize"><CODE>cd</CODE><BR>
<BR>
The <CODE>cd</CODE> function changes the current directory.
Note that the current directory follows the usual scoping
rules. For example, the following program lists the
files in the <CODE>foo</CODE> directory, but the current
directory is not changed.
<PRE CLASS="verbatim">
   section
      echo Listing files in the foo directory...
      cd foo
      ls

   echo Listing files in the current directory...
   ls
</PRE><LI CLASS="li-itemize"><CODE>bg</CODE><BR>
<BR>
The <CODE>bg</CODE> method places a job in the background.
The job is resumed if it has been suspended.
<LI CLASS="li-itemize"><CODE>fg</CODE><BR>
<BR>
The <CODE>fg</CODE> method brings a job to the foreground.
The job is resumed if it has been suspended.
<LI CLASS="li-itemize"><CODE>stop</CODE><BR>
<BR>
The <CODE>stop</CODE> method suspends a running job.
<LI CLASS="li-itemize"><CODE>wait</CODE><BR>
<BR>
The <CODE>wait</CODE> function waits for a running job to terminate.
It is not possible to wait for a suspended job.<BR>
<BR>
The job is not brought to the foreground. If the <CODE>wait</CODE>
is interrupted, the job continues to run in the background.
<LI CLASS="li-itemize"><CODE>kill</CODE><BR>
<BR>
The <CODE>kill</CODE> function signal a job.<BR>
<BR>
<CODE>kill [signal] &lt;pid...&gt;</CODE>.<BR>
<BR>
The signals are either numeric, or symbolic.
The symbolic signals are named as follows.<BR>
<BR>
ABRT, ALRM, HUP, ILL, KILL, QUIT, SEGV, TERM, USR1,
USR2, CHLD, STOP, TSTP, TTIN, TTOU, VTALRM, PROF.
<LI CLASS="li-itemize"><CODE>exit</CODE><BR>
<BR>
The <CODE>exit</CODE> function terminates the current session.
<LI CLASS="li-itemize"><CODE>which</CODE>, <CODE>where</CODE><BR>
<BR>
See the documentation for the corresponding functions.
<LI CLASS="li-itemize"><CODE>rehash</CODE><BR>
<BR>
Reset the search path.
<LI CLASS="li-itemize"><CODE>history</CODE><BR>
<BR>
Print the current command-line history.
<LI CLASS="li-itemize"><CODE>digest</CODE><BR>
<BR>
Print the digests of the given files.
<LI CLASS="li-itemize">Win32 functions.<BR>
<BR>
Win32 doesn't provide very many programs for scripting, except
 for the functions that are builtin to the DOS <CODE>cmd.exe</CODE>.
 The following functions are defined on Win32 and only on Win32.
 On other systems, it is expected that these programs already
 exist.
<UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>grep</CODE>
<PRE CLASS="verbatim">
   grep [-q] [-n] pattern files...
</PRE>
The <CODE>grep</CODE> function calls the <TT>omake</TT>
<CODE>grep</CODE> function.
</UL>
By default, <TT>omake</TT> uses internal versions of the following commands:
<CODE>cp</CODE>, <CODE>mv</CODE>, <CODE>cat</CODE>, <CODE>rm</CODE>, <CODE>mkdir</CODE>, <CODE>chmod</CODE>,
<CODE>test</CODE>, <CODE>find</CODE>.
If you really want to use the standard system versions of these
commands, set the <CODE>USE_SYSTEM_COMMANDS</CODE> as one of the first
definitions in your <CODE>OMakeroot</CODE> file.
<UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>mkdir</CODE>
<PRE CLASS="verbatim">
    mkdir [-m &lt;mode&gt;] [-p] files
</PRE>
The <CODE>mkdir</CODE> function is used to create directories.
The -verb+-m+ option can be used to specify the permission
mode of the created directory. If the <CODE>-p</CODE> option
is specified, the full path is created.
<LI CLASS="li-itemize"><CODE>cp</CODE>
<LI CLASS="li-itemize"><CODE>mv</CODE>
<PRE CLASS="verbatim">
    cp [-f] [-i] [-v] src dst
    cp [-f] [-i] [-v] files dst
    mv [-f] [-i] [-v] src dst
    mv [-f] [-i] [-v] files dst
</PRE>
The <CODE>cp</CODE> function copies a <CODE>src</CODE> file to
a <CODE>dst</CODE> file, overwriting it if it already exists.
If more than one source file is specified, the final file
must be a directory, and the source files are copied
into the directory.
<DL CLASS="description" COMPACT=compact><DT CLASS="dt-description">
<B>-f</B><DD CLASS="dd-description"> Copy files forcibly, do not prompt.
<DT CLASS="dt-description"><B>-i</B><DD CLASS="dd-description"> Prompt before removing destination files.
<DT CLASS="dt-description"><B>-v</B><DD CLASS="dd-description"> Explain what is happening.
</DL>
<LI CLASS="li-itemize"><CODE>rm</CODE>
<PRE CLASS="verbatim">
   rm [-f] [-i] [-v] [-r] files
   rmdir [-f] [-i] [-v] [-r] dirs
</PRE>
The <CODE>rm</CODE> function removes a set of files.
No warnings are issued if the files do not exist, or if
they cannot be removed.<BR>
<BR>
Options:
<DL CLASS="description" COMPACT=compact><DT CLASS="dt-description">
<B>-f</B><DD CLASS="dd-description"> Forcibly remove files, do not prompt.
<DT CLASS="dt-description"><B>-i</B><DD CLASS="dd-description"> Prompt before removal.
<DT CLASS="dt-description"><B>-v</B><DD CLASS="dd-description"> Explain what is happening.
<DT CLASS="dt-description"><B>-r</B><DD CLASS="dd-description"> Remove contents of directories recursively.
</DL>
<LI CLASS="li-itemize"><CODE>chmod</CODE>
<PRE CLASS="verbatim">
    chmod [-r] [-v] [-f] mode files
</PRE>
The <CODE>chmod</CODE> function changes the permissions on a set of
files or directories. This function does nothing on Win32.
The <CODE>mode</CODE> may be specified as an octal number,
or in symbolic form <CODE>[ugoa]*[</CODE>-=][rwxXstugo]+.
See the man page for <CODE>chmod</CODE> for details.<BR>
<BR>
Options:
<DL CLASS="description" COMPACT=compact><DT CLASS="dt-description">
<B>-r</B><DD CLASS="dd-description"> Change permissions of all files in a directory recursively.
<DT CLASS="dt-description"><B>-v</B><DD CLASS="dd-description"> Explain what is happening.
<DT CLASS="dt-description"><B>-f</B><DD CLASS="dd-description"> Continue on errors.
</DL>
<LI CLASS="li-itemize"><CODE>cat</CODE>
<PRE CLASS="verbatim">
   cat files...
</PRE>
The <CODE>cat</CODE> function prints the contents of the files to stdout
<LI CLASS="li-itemize"><CODE>test</CODE>
<PRE CLASS="verbatim">
   test \emph{expression}
   \verb+[+ \emph{expression} +]+
   \verb+[ --help+
   \verb+[ --version+
</PRE>
See the documentation for the <CODE>test</CODE> function.<BR>
<BR>
<LI CLASS="li-itemize"><CODE>find</CODE>
<PRE CLASS="verbatim">
   find \emph{expression}
</PRE>
See the documentation for the <CODE>find</CODE> function.</UL><BR>

</UL>


<TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=left NOWRAP>Jump to:</TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP><A HREF="http://omake.metaprl.org/">OMake Home</A>
&bull;&nbsp;<A HREF="omake.html">Guide Home</A>
&bull;&nbsp;<A HREF="omake-doc.html">Guide (single-page)</A>
&bull;&nbsp;<A HREF="omake-toc.html">Contents (short)</A>
&bull;&nbsp;<A HREF="omake-contents.html">Contents (long)</A></TD>
</TR>
<TR><TD ALIGN=left NOWRAP>Index:</TD>
<TD VALIGN=top ALIGN=center NOWRAP>&nbsp;&nbsp;</TD>
<TD ALIGN=left NOWRAP><A HREF="omake-all-index.html">All</A>
&bull;&nbsp;<A HREF="omake-var-index.html">Variables</A>
&bull;&nbsp;<A HREF="omake-fun-index.html">Functions</A>
&bull;&nbsp;<A HREF="omake-obj-index.html">Objects</A>
&bull;&nbsp;<A HREF="omake-target-index.html">Targets</A>
&bull;&nbsp;<A HREF="omake-option-index.html">Options</A></TD>
</TR></TABLE>
</BODY>
</HTML>
