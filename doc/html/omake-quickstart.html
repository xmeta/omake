<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>



<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.08">
<LINK rel="stylesheet" type="text/css" href="omake-doc.css">
<TITLE>
OMake quickstart guide
</TITLE>
</HEAD>
<BODY >

<img src="images/omake-manual.gif" border="0" align="top"><br>
<A HREF="http://omake.metaprl.org/">OMake Home</A>
<A HREF="omake-toc.html">Contents (short)</A>
<A HREF="omake-contents.html">Contents (long)</A>
<A HREF="omake.html">Guide</A>
<A HREF="omake-options.html">Options</A>
<A HREF="omake-all-index.html">Index</A>
<A HREF="omake-var-index.html">Variables</A>
<A HREF="omake-fun-index.html">Functions</A>
<A HREF="omake-obj-index.html">Objects</A>
<A HREF="omake-target-index.html">Targets</A>

<H1 CLASS="chapter"><A NAME="htoc5">Chapter&nbsp;2</A>&nbsp;&nbsp;OMake quickstart guide</H1><UL>
<LI><A HREF="omake-quickstart.html#toc4">For users already familiar with make</A>
<LI><A HREF="omake-quickstart.html#toc5">Building a small C program</A>
<LI><A HREF="omake-quickstart.html#toc6">Larger projects</A>
<LI><A HREF="omake-quickstart.html#toc7">Subdirectories</A>
<LI><A HREF="omake-quickstart.html#toc8">Other things to consider</A>
<LI><A HREF="omake-quickstart.html#toc9">Building OCaml programs</A>
<LI><A HREF="omake-quickstart.html#toc10">The OMakefile and OMakeroot files</A>
<LI><A HREF="omake-quickstart.html#toc11">Multiple version support</A>
<LI><A HREF="omake-quickstart.html#toc12">Notes</A>
</UL>

<A NAME="chapter:quickstart"></A>
<BR>
<BR>
<A NAME="toc4"></A>
<H2 CLASS="section"><A NAME="htoc6">2.1</A>&nbsp;&nbsp;For users already familiar with make</H2>
For users already familiar with the <TT>make</TT>(1) command, here is a list of
differences to keep in mind when using <TT>omake</TT>.
<UL CLASS="itemize"><LI CLASS="li-itemize">
In <TT>omake</TT>, you are much less likely to define build rules of your own.
 The system provides many standard functions (like <CODE>StaticCLibrary</CODE>&nbsp;<A HREF="omake-rule.html#fun:StaticCLibrary">11.3.19</A> and <CODE>CProgram</CODE>&nbsp;<A HREF="omake-rule.html#fun:CProgram">11.3.25</A>)
 to specify these builds more simply.
<LI CLASS="li-itemize">Implicit rules using <CODE>.SUFFIXES</CODE> and the <CODE>.suf1.suf2:</CODE> are not supported.
 You should use wildcard patterns instead <CODE>%.suf2: %.suf1</CODE>.
<LI CLASS="li-itemize">Scoping is significant: you should define variables and <CODE>.PHONY</CODE>&nbsp;<A HREF="omake-rules.html#target:.PHONY">6.12</A> targets before they are used.
<LI CLASS="li-itemize">Subdirectories are incorporated into a project using the <CODE>.SUBDIRS:</CODE>&nbsp;<A HREF="omake-rules.html#target:.SUBDIRS">6.10</A>.
 target.
</UL>
<A NAME="toc5"></A>
<H2 CLASS="section"><A NAME="htoc7">2.2</A>&nbsp;&nbsp;Building a small C program</H2>
To start a new project, the easiest method is to change directories to the project
root and use the command <CODE>omake --install</CODE> to install default <TT>OMakefile</TT>s.
<PRE CLASS="verbatim">
    $ cd ~/newproject
    $ omake --install
    *** omake: creating OMakeroot
    *** omake: creating OMakefile
    *** omake: project files OMakefile and OMakeroot have been installed
    *** omake: you should edit these files before continuing
</PRE>
The default <TT>OMakefile</TT> contains sections for building C and OCaml programs.
For now, we'll build a simple C project.<BR>
<BR>
Suppose we have a C file called <CODE>hello_code.c</CODE> containing the following code:
<PRE CLASS="verbatim">
    #include &lt;stdio.h&gt;

    int main(int argc, char **argv)
    {
        printf("Hello world\n");
        return 0;
    }
</PRE>
To build the program a program <CODE>hello</CODE> from this file, we can use the <CODE>CProgram</CODE>&nbsp;<A HREF="omake-rule.html#fun:CProgram">11.3.25</A> function.
The <TT>OMakefile</TT> contains just one line that specifies that the program <CODE>hello</CODE> is
to be built from the source code in the <CODE>hello_code.c</CODE> file (note that file suffixes
are not passed to these functions).
<PRE CLASS="verbatim">
    CProgram(hello, hello_code)
</PRE>
Now we can run <TT>omake</TT> to build the project. Note that the first time we run <TT>omake</TT>,
it both scans the <CODE>hello_code.c</CODE> file for dependencies, and compiles it using the <CODE>cc</CODE>
compiler. The status line printed at the end indicates how many files were scanned, how many
were built, and how many MD5 digests were computed.
<PRE CLASS="verbatim">
    $ omake hello
    *** omake: reading OMakefiles
    *** omake: finished reading OMakefiles (0.0 sec)
    - scan . hello_code.o
    + cc -I. -MM hello_code.c
    - build . hello_code.o
    + cc -I. -c -o hello_code.o hello_code.c
    - build . hello
    + cc -o hello hello_code.o
    *** omake: done (0.5 sec, 1/6 scans, 2/6 rules, 5/22 digests)
    $ omake
    *** omake: reading OMakefiles
    *** omake: finished reading OMakefiles (0.1 sec)
    *** omake: done (0.1 sec, 0/4 scans, 0/4 rules, 0/9 digests)
</PRE>
If we want to change the compile options, we can redefine the <CODE>CC</CODE> and <CODE>CFLAGS</CODE>
variables <EM>before</EM> the <CODE>CProgram</CODE>&nbsp;<A HREF="omake-rule.html#fun:CProgram">11.3.25</A> line. In this example, we will use the <CODE>gcc</CODE>
compiler with the <CODE>-g</CODE> option. In addition, we will specify a <CODE>.DEFAULT</CODE> target
to be built by default. The <CODE>EXE</CODE> variable is defined to be <CODE>.exe</CODE> on <CODE>Win32</CODE>
systems; it is empty otherwise.
<PRE CLASS="verbatim">
    CC = gcc
    CFLAGS += -g
    CProgram(hello, hello_code)
    .DEFAULT: hello$(EXE)
</PRE>
Here is the corresponding run for <TT>omake</TT>.
<PRE CLASS="verbatim">
    $ omake
    *** omake: reading OMakefiles
    *** omake: finished reading OMakefiles (0.0 sec)
    - scan . hello_code.o
    + gcc -g -I. -MM hello_code.c
    - build . hello_code.o
    + gcc -g -I. -c -o hello_code.o hello_code.c
    - build . hello
    + gcc -g -o hello hello_code.o
    *** omake: done (0.4 sec, 1/7 scans, 2/7 rules, 3/22 digests)
</PRE>
We can, of course, include multiple files in the program. Suppose we write a new
file <CODE>hello_helper.c</CODE>. We would include this in the project as follows.
<PRE CLASS="verbatim">
    CC = gcc
    CFLAGS += -g
    CProgram(hello, hello_code hello_helper)
    .DEFAULT: hello$(EXE)
</PRE>
<A NAME="toc6"></A>
<H2 CLASS="section"><A NAME="htoc8">2.3</A>&nbsp;&nbsp;Larger projects</H2>
As the project grows it is likely that we will want to build libraries of code.
Libraries can be built using the <CODE>StaticCLibrary</CODE> function. Here is an example
of an <TT>OMakefile</TT> with two libraries.
<PRE CLASS="verbatim">
    CC = gcc
    CFLAGS += -g

    FOO_FILES = foo_a foo_b
    BAR_FILES = bar_a bar_b bar_c

    StaticCLibrary(libfoo, $(FOO_FILES))
    StaticCLibrary(libbar, $(BAR_FILES))

    # The hello program is linked with both libraries
    LIBS = libfoo libbar
    CProgram(hello, hello_code hello_helper)

    .DEFAULT: hello$(EXE)
</PRE>
<A NAME="toc7"></A>
<H2 CLASS="section"><A NAME="htoc9">2.4</A>&nbsp;&nbsp;Subdirectories</H2>
As the project grows even further, it is a good idea to split it into several directories.
Suppose we place the <CODE>libfoo</CODE> and <CODE>libbar</CODE> into subdirectories.<BR>
<BR>
In each subdirectory, we define an <TT>OMakefile</TT> for that directory. For example, here
is an example <TT>OMakefile</TT> for the <CODE>foo</CODE> subdirectory.
<PRE CLASS="verbatim">
    INCLUDES += .. ../bar

    FOO_FILES = foo_a foo_b
    StaticCLibrary(libfoo, $(FOO_FILES))
</PRE>
Note the the <CODE>INCLUDES</CODE> variable is defined to include the other directories in the project.<BR>
<BR>
Now, the next step is to link the subdirectories into the main project. The project <TT>OMakefile</TT>
should be modified to include a <CODE>.SUBDIRS:</CODE> target.
<PRE CLASS="verbatim">
    # Project configuration
    CC = gcc
    CFLAGS += -g

    # Subdirectories
    .SUBDIRS: foo bar

    # The libraries are now in subdirectories
    LIBS = foo/libfoo bar/libbar

    CProgram(hello, hello_code hello_helper)

    .DEFAULT: hello$(EXE)
</PRE>
Note that the variables <CODE>CC</CODE> and <CODE>CFLAGS</CODE> are defined <EM>before</EM> the <CODE>.SUBDIRS</CODE>
target. These variables remain defined in the subdirectories, so that <CODE>libfoo</CODE> and <CODE>libbar</CODE>
use <CODE>gcc -g</CODE>.<BR>
<BR>
If the two directories are to be configured differently, we have two choices. The <TT>OMakefile</TT>
in each subdirectory can be modified with its configuration (this is how it would normally be done).
Alternatively, we can also place the change in the root <TT>OMakefile</TT>.
<PRE CLASS="verbatim">
    # Default project configuration
    CC = gcc
    CFLAGS += -g

    # libfoo uses the default configuration
    .SUBDIRS: foo

    # libbar uses the optimizing compiler
    CFLAGS += -O3
    .SUBDIRS: bar

    # Main program
    LIBS = foo/libfoo bar/libbar
    CProgram(hello, hello_code hello_helper)

    .DEFAULT: hello$(EXE)
</PRE>
Note that the way we have specified it, the <CODE>CFLAGS</CODE> variable also contains the <CODE>-O3</CODE>
option for the <CODE>CProgram</CODE>&nbsp;<A HREF="omake-rule.html#fun:CProgram">11.3.25</A>, and <CODE>hello_code.c</CODE> and <CODE>hello_helper.c</CODE> file will both be
compiled with the <CODE>-O3</CODE> option. If we want to make the change truly local to <CODE>libbar</CODE>, we
can put the <CODE>bar</CODE> subdirectory in its own scope using the <CODE>section</CODE> form.
<PRE CLASS="verbatim">
    # Default project configuration
    CC = gcc
    CFLAGS += -g

    # libfoo uses the default configuration
    .SUBDIRS: foo

    # libbar uses the optimizing compiler
    section
        CFLAGS += -O3
        .SUBDIRS: bar

    # Main program does not use the optimizing compiler
    LIBS = foo/libfoo bar/libbar
    CProgram(hello, hello_code hello_helper)

    .DEFAULT: hello$(EXE)
</PRE>
Later, suppose we decide to port this project to <CODE>Win32</CODE>, and we discover that we need
different compiler flags and an additional library.
<PRE CLASS="verbatim">
    # Default project configuration
    if $(equal $(OSTYPE), Win32)
        CC = cl /nologo
        CFLAGS += /DWIN32 /MT
        export
    else
        CC = gcc
        CFLAGS += -g
        export

    # libfoo uses the default configuration
    .SUBDIRS: foo

    # libbar uses the optimizing compiler
    section
        CFLAGS += $(if $(equal $(OSTYPE), Win32), $(EMPTY), -O3)
        .SUBDIRS: bar

    # Default libraries
    LIBS = foo/libfoo bar/libbar

    # We need libwin32 only on Win32
    if $(equal $(OSTYPE), Win32)
       LIBS += win32/libwin32

       .SUBDIRS: win32
       export

    # Main program does not use the optimizing compiler
    CProgram(hello, hello_code hello_helper)

    .DEFAULT: hello$(EXE)
</PRE>
Note the use of the <CODE>export</CODE> directives to export the variable definitions from the
if-statements. Variables in <TT>omake</TT> are <EM>scoped</EM>&mdash;variables in nested blocks (blocks
with greater indentation), are not normally defined in outer blocks. The <CODE>export</CODE> directive
specifies that the variable definitions in the nested blocks should be exported to their parent
block.<BR>
<BR>
Finally, for this example, we decide to copy all libraries into a common <CODE>lib</CODE> directory. We
first define a directory variable, and replace occurrences of the <CODE>lib</CODE> string with the
variable.
<PRE CLASS="verbatim">
    # The common lib directory
    LIB = $(dir lib)

    # phony target to build just the libraries
    .PHONY: makelibs

    # Default project configuration
    if $(equal $(OSTYPE), Win32)
        CC = cl /nologo
        CFLAGS += /DWIN32 /MT
        export
    else
        CC = gcc
        CFLAGS += -g
        export

    # libfoo uses the default configuration
    .SUBDIRS: foo

    # libbar uses the optimizing compiler
    section
        CFLAGS += $(if $(equal $(OSTYPE), Win32), $(EMPTY), -O3)
        .SUBDIRS: bar

    # Default libraries
    LIBS = $(LIB)/libfoo $(LIB)/libbar

    # We need libwin32 only on Win32
    if $(equal $(OSTYPE), Win32)
       LIBS += $(LIB)/libwin32

       .SUBDIRS: win32
       export

    # Main program does not use the optimizing compiler
    CProgram(hello, hello_code hello_helper)

    .DEFAULT: hello$(EXE)
</PRE>
In each subdirectory, we modify the <TT>OMakefile</TT>s in the library directories to install them
into the <CODE>$(LIB)</CODE> directory. Here is the relevant change to <TT>foo/OMakefile</TT>.
<PRE CLASS="verbatim">
    INCLUDES += .. ../bar

    FOO_FILES = foo_a foo_b
    StaticCLibraryInstall(makelib, $(LIB), libfoo, $(FOO_FILES))
</PRE>
Directory (and file names) evaluate to relative pathnames. Within the <CODE>foo</CODE> directory, the
<CODE>$(LIB)</CODE> variable evaluates to <CODE>../lib</CODE>.<BR>
<BR>
As another example, instead of defining the <CODE>INCLUDES</CODE> variable separately
in each subdirectory, we can define it in the toplevel as follows.
<PRE CLASS="verbatim">
    INCLUDES = $(ROOT) $(dir foo bar win32)
</PRE>
In the <CODE>foo</CODE> directory, the <CODE>INCLUDES</CODE> variable will evaluate to
the string <CODE>.. . ../bar ../win32</CODE>. In the <CODE>bar</CODE> directory,
it would be <CODE>.. ../foo . ../win32</CODE>. In the root directory it
would be <CODE>. foo bar win32</CODE>.<BR>
<BR>
<A NAME="toc8"></A>
<H2 CLASS="section"><A NAME="htoc10">2.5</A>&nbsp;&nbsp;Other things to consider</H2>
<TT>omake</TT> also handles recursive subdirectories. For example, suppose the <CODE>foo</CODE>
directory itself contains several subdirectories. The <TT>foo/OMakefile</TT> would then
contain its own <CODE>.SUBDIRS</CODE> target, and each of its subdirectories would
contain its own <CODE>OMakefile</CODE>.<BR>
<BR>
<A NAME="toc9"></A>
<H2 CLASS="section"><A NAME="htoc11">2.6</A>&nbsp;&nbsp;Building OCaml programs</H2>
By default, <TT>omake</TT> is also configured with functions for building OCaml programs.
The functions for OCaml program use the <CODE>OCaml</CODE> prefix. For example, suppose
we reconstruct the previous example in OCaml, and we have a file called <CODE>hello_code.ml</CODE>
that contains the following code.
<PRE CLASS="verbatim">
   open Printf

   let () = printf "Hello world\n"
</PRE>
An example <TT>OMakefile</TT> for this simple project would contain the following.
<PRE CLASS="verbatim">
    # Use the byte-code compiler
    BYTE_ENABLED = true
    NATIVE_ENABLED = false
    OCAMLCFLAGS += -g

    # Build the program
    OCamlProgram(hello, hello_code)
    .DEFAULT: hello.run
</PRE>
Next, suppose the we have two library subdirectories: the <CODE>foo</CODE> subdirectory
is written in C, the <CODE>bar</CODE> directory is written in OCaml, and we need to
use the standard OCaml <CODE>Unix</CODE> module.
<PRE CLASS="verbatim">
    # Default project configuration
    if $(equal $(OSTYPE), Win32)
        CC = cl /nologo
        CFLAGS += /DWIN32 /MT
        export
    else
        CC = gcc
        CFLAGS += -g
        export

    # Use the byte-code compiler
    BYTE_ENABLED = true
    NATIVE_ENABLED = false
    OCAMLCFLAGS += -g

    # library subdirectories
    INCLUDES += $(dir foo bar)
    OCAMLINCLUDES += $(dir foo bar)
    .SUBDIRS: foo bar

    # C libraries
    LIBS = foo/libfoo

    # OCaml libraries
    OCAML_LIBS = bar/libbar

    # Also use the Unix module
    OCAML_OTHER_LIBS = unix

    # The main program
    OCamlProgram(hello, hello_code hello_helper)

    .DEFAULT: hello
</PRE>
The <TT>foo/OMakefile</TT> would be configured as a C library.
<PRE CLASS="verbatim">
    FOO_FILES = foo_a foo_b
    StaticCLibrary(libfoo, $(FOO_FILES))
</PRE>
The <TT>bar/OMakefile</TT> would build an ML library.
<PRE CLASS="verbatim">
   BAR_FILES = bar_a bar_b bar_c
   OCamlLibrary(libbar, $(BAR_FILES))
</PRE>
<A NAME="toc10"></A>
<H2 CLASS="section"><A NAME="htoc12">2.7</A>&nbsp;&nbsp;The OMakefile and OMakeroot files</H2>
<A NAME="section:omakeroot"></A>
<A NAME="@default0"></A>
<A NAME="@default1"></A>
<TT>OMake</TT> uses the <TT>OMakefile</TT> and <TT>OMakeroot</TT> files for configuring a project. The
syntax of these files is the same, but their role is slightly different. For one thing, every
project must have exactly one <TT>OMakeroot</TT> file in the project root directory. This file serves
to identify the project root, and it contains code that sets up the project. In contrast, a
multi-directory project will often have an <TT>OMakefile</TT> in each of the project subdirectories,
specifying how to build the files in that subdirectory.<BR>
<BR>
Normally, the <TT>OMakeroot</TT> file is boilerplate. The following listing is a typical example.
<PRE CLASS="verbatim">
    include $(STDLIB)/build/Common
    include $(STDLIB)/build/C
    include $(STDLIB)/build/OCaml
    include $(STDLIB)/build/LaTeX

    # Redefine the command-line variables
    DefineCommandVars(.)

    # The current directory is part of the project
    .SUBDIRS: .
</PRE>
The <CODE>include</CODE> lines include the standard configuration files needed for the project. The
<CODE>$(STDLIB)</CODE> represents the <TT>omake</TT> library directory. The only required configuration
file is <CODE>Common</CODE>. The others are optional; for example, the <CODE>$(STDLIB)/build/OCaml</CODE> file
is needed only when the project contains programs written in OCaml.<BR>
<BR>
The <CODE>DefineCommandVars</CODE> function defines any variables specified on the command line (as
arguments of the form <CODE>VAR=&lt;value&gt;</CODE>). The <CODE>.SUBDIRS</CODE> line specifies that the current
directory is part of the project (so the <CODE>OMakefile</CODE> should be read).<BR>
<BR>
Normally, the <CODE>OMakeroot</CODE> file should be small and project-independent. Any project-specific
configuration should be placed in the <CODE>OMakefiles</CODE> of the project.<BR>
<BR>
<A NAME="toc11"></A>
<H2 CLASS="section"><A NAME="htoc13">2.8</A>&nbsp;&nbsp;Multiple version support</H2>
<A NAME="@default2"></A>
OMake version <CODE>0.9.6</CODE> introduced preliminary support for multiple, simultaneous versions of a
project. Versioning uses the <CODE>vmount(dir1, dir2)</CODE> function, which defines a &#8220;virtual mount&#8221;
of directory <CODE>dir1</CODE> over directory <CODE>dir2</CODE>. A &#8220;virtual mount&#8221; is like a transparent
mount in Unix, where the files from <CODE>dir1</CODE> appear in the <CODE>dir2</CODE> namespace, but new files
are created in <CODE>dir2</CODE>. More precisely, the filename <CODE>dir2/foo</CODE> refers to: a) the file
<CODE>dir1/foo</CODE> if it exists, or b) <CODE>dir2/foo</CODE> otherwise.<BR>
<BR>
The <CODE>vmount</CODE> function makes it easy to specify multiple versions of a project. Suppose we have
a project where the source files are in the directory <CODE>src/</CODE>, and we want to compile two
versions, one with debugging support and one optimized. We create two directories, <TT>debug</TT> and
<TT>opt</TT>, and mount the <TT>src</TT> directory over them.
<PRE CLASS="verbatim">
    section
        CFLAGS += -g
        vmount(-l, src, debug)
        .SUBDIRS: debug

    section
        CFLAGS += -O3
        vmount(-l, src, opt)
        .SUBDIRS: opt
</PRE>
Here, we are using <CODE>section</CODE> blocks to define the scope of the <CODE>vmount</CODE>&mdash;you may not need
them in your project.<BR>
<BR>
The <CODE>-l</CODE> option is optional. It specifies that files form the <CODE>src</CODE> directory should be
linked into the target directories (or copied, if the system is Win32). The links are added as
files are referenced. If no options are given, then files are not copied or linked, but filenames
are translated to refer directly to the <CODE>src/</CODE> files.<BR>
<BR>
Now, when a file is referenced in the <CODE>debug</CODE> directory, it is linked from the <CODE>src</CODE>
directory if it exists. For example, when the file <CODE>debug/OMakefile</CODE> is read, the
<CODE>src/OMakefile</CODE> is linked into the <CODE>debug/</CODE> directory.<BR>
<BR>
The <CODE>vmount</CODE> model is fairly transparent. The <CODE>OMakefile</CODE>s can be written <EM>as if</EM>
referring to files in the <CODE>src/</CODE> directory&mdash;they need not be aware of mounting.
However, there are a few points to keep in mind.<BR>
<BR>
<A NAME="toc12"></A>
<H2 CLASS="section"><A NAME="htoc14">2.9</A>&nbsp;&nbsp;Notes</H2>
<UL CLASS="itemize"><LI CLASS="li-itemize">
When using the <CODE>vmount</CODE> function for versioning, it wise to keep the source files
distinct from the compiled versions. For example, suppose the source directory contained a file
<CODE>src/foo.o</CODE>. When mounted, the <CODE>foo.o</CODE> file will be the same in all versions, which is
probably not what you want. It is better to keep the <CODE>src/</CODE> directory pristine, containing no
compiled code.<BR>
<BR>
<LI CLASS="li-itemize">When using the <CODE>vmount -l</CODE> option, files are linked into the version directory only if
they are referenced in the project. Functions that examine the filesystem (like <CODE>$(ls ...)</CODE>)
may produce unexpected results.
</UL>

<A HREF="http://omake.metaprl.org/">OMake Home</A>
<A HREF="omake-toc.html">Contents (short)</A>
<A HREF="omake-contents.html">Contents (long)</A>
<A HREF="omake.html">Guide</A>
<A HREF="omake-options.html">Options</A>
<A HREF="omake-all-index.html">Index</A>
<A HREF="omake-var-index.html">Variables</A>
<A HREF="omake-fun-index.html">Functions</A>
<A HREF="omake-obj-index.html">Objects</A>
<A HREF="omake-target-index.html">Targets</A>
</BODY>
</HTML>
