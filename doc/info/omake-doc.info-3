This file has been translated from LaTeX by HeVeA.

Node: Section 6-7,	Next: Section 6-8,	Prev: Section 6-6,	Up: Chapter 6
  

6.7   Named scanners, and the :scanner: target
*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=

   
  Sometimes it may be useful to specify explicitly which scanner should
be used in a rule. For example, we might compile `.c' files with
different options, or (heaven help us) we may be using both `gcc' and
the Microsoft Visual C++ compiler `cl'. In general, the target of a
`.SCANNER' is not tied to a particular target, and we may name it as we
like.
<<
      .SCANNER: scan-gcc-%.c: %.c :value: $(digest-in-path-optional
$(INCLUDES), $&)
          gcc -MM $(addprefix -I, $(INCLUDES)) $<
  
      .SCANNER: scan-cl-%.c: %.c :value: $(digest-in-path-optional
$(INCLUDES), $&)
          cl --scan-dependencies-or-something $(addprefix /I,
$(INCLUDES)) $<
>>
  
  The next step is to define explicit scanner dependencies. The
`:scanner:' dependency is used for this. In this case, the scanner
dependencies are specified explicitly.
<<
      $(GCC_FILES): %.o: %.c :scanner: scan-gcc-%c
          gcc ...
  
      $(CL_FILES): %.obj: %.c :scanner: scan-cl-%c
          cl ...
>>
  
  Explicit `:scanner:' scanner specification may also be used to state
that a single `.SCANNER' rule should be used to generate dependencies
for more than one target. For example,
<<
      .SCANNER: scan-all-c: $(GCC_FILES) :value:
$(digest-in-path-optional $(INCLUDES), $&)
          gcc -MM $(addprefix -I, $(INCLUDES)) $(GCC_FILES)
  
      $(GCC_FILES): %.o: %.c :scanner: scan-all-c
          ...
>>
  
  The above has the advantage of only running gcc once and a
disadvantage that when a single source file changes, all the files will
end up being re-scanned.

Node: Section 6-8,	Next: Section 6-9,	Prev: Section 6-7,	Up: Chapter 6
  

6.8   Notes
*=*=*=*=*=*

  
  In most cases, you won't need to define scanners of your own. The
standard installation includes default scanners (both explicitly and
implicitly named ones) for C, OCaml, and LaTeX files.
  The `SCANNER_MODE' 11.2.8*Note Subsection 11-2-8:: variable
controls the usage of implicit scanner dependencies.
  The explicit `:scanner:' dependencies reduce the chances of scanner
mis-specifications. In large complicated projects it might be a good
idea to set `SCANNER_MODE' to `error' and use only the named `.SCANNER'
rules and explicit `:scanner:' specifications.

Node: Section 6-9,	Next: Section 6-10,	Prev: Section 6-8,	Up: Chapter 6
  

6.9   .DEFAULT
*=*=*=*=*=*=*=

   
  The `.DEFAULT' target specifies a target to be built by default if
omake is run without explicit targets. The following rule instructs
omake to build the program `hello' by default
<<
     .DEFAULT: hello
>>
  

Node: Section 6-10,	Next: Section 6-11,	Prev: Section 6-9,	Up: Chapter 6
  

6.10   .SUBDIRS
*=*=*=*=*=*=*=*

   
  The `.SUBDIRS' target is used to specify a set of subdirectories that
are part of the project. Each subdirectory should have its own
OMakefile, which is evaluated in the context of the current environment.
<<
     .SUBDIRS: src doc tests
>>
  
  This rule specifies that the `OMakefile's in each of the `src', `doc',
and `tests' directories should be read.
  In some cases, especially when the `OMakefile's are very similar in a
large number of subdirectories, it is inconvenient to have a separate
`OMakefile' for each directory. If the `.SUBDIRS' rule has a body, the
body is used instead of the `OMakefile'.
<<
     .SUBDIRS: src1 src2 src3
        println(Subdirectory $(CWD))
        .DEFAULT: lib.a
>>
  
  In this case, the `src1', `src2', and `src3' files do not need
`OMakefile's. Furthermore, if one exists, it is ignored. The following
includes the file if it exists.
<<
     .SUBDIRS: src1 src2 src3
         if $(file-exists OMakefile)
            include OMakefile
         .DEFAULT: lib.a
>>
  

Node: Section 6-11,	Next: Section 6-12,	Prev: Section 6-10,	Up: Chapter 6
  

6.11   .INCLUDE
*=*=*=*=*=*=*=*

   
  The `.INCLUDE' target is like the `include' directive, but it
specifies a rule to build the file if it does not exist.
<<
     .INCLUDE: config
         echo "CONFIG_READ = true" > config
  
      echo CONFIG_READ is $(CONFIG_READ)
>>
  
  You may also specify dependencies to an `.INCLUDE' rule.
<<
     .INCLUDE: config: config.defaults
        cp config.defaults config
>>
  
  A word of caution is in order here. The usual policy is used for
determining when the rule is out-of-date. The rule is executed if any of
the following hold.
  
  
 - the target does not exist, 
 - the rule has never been executed before, 
 - any of the following have changed since the last time the rule was
   executed, 
     
    - the target, 
    - the dependencies, 
    - the commands-text. 
  
  
  In some of the cases, this will mean that the rule is executed even if
the target file already exists. If the target is a file that you expect
to edit by hand (and therefore you don't want to overwrite it), you
should make the rule evaluation conditional on whether the target
already exists.
<<
     .INCLUDE: config: config.defaults
         # Don't overwrite my carefully hand-edited file
         if $(not $(file-exists config))
            cp config.defaults config
>>
  

Node: Section 6-12,	Next: Section 6-13,	Prev: Section 6-11,	Up: Chapter 6
  

6.12   .PHONY
*=*=*=*=*=*=*

   
  A ``phony'' target is a target that is not a real file, but exists to
collect a set of dependencies. Phony targets are specified with the
`.PHONY' rule. In the following example, the `install' target does not
correspond to a file, but it corresponds to some commands that should be
run whenever the `install' target is built (for example, by running
`omake install').
<<
     .PHONY: install
  
     install: myprogram.exe
        cp myprogram.exe /usr/bin
>>
  

Node: Section 6-13,	Next: Subsection 6-13-1,	Prev: Section 6-12,	Up: Chapter 6
  

6.13   Rule scoping
*=*=*=*=*=*=*=*=*=*

   
  As we have mentioned before, omake is a scoped language. This provides
great flexibility---different parts of the project can define different
configurations without interfering with one another (for example, one
part of the project might be compiled with `CFLAGS=-O3' and another with
`CFLAGS=-g').
  But how is the scope for a target file selected? Suppose we are
building a file `dir/foo.o'. omake uses the following rules to determine
the scope.
  
  
 - First, if there is an explicit rule for building `dir/foo.o' (a rule
   with no wildcards), the context for that rule determines the scope
   for building the target. 
 - Otherwise, the directory `dir/' must be part of the project. This
   normally means that a configuration file `dir/OMakefile' exists
   (although, see the `.SUBDIRS' section for another way to specify the
   `OMakefile'). In this case, the scope of the target is the scope at
   the end of the `dir/OMakefile'. 
  
  To illustrate rule scoping, let's go back to the example of a ``Hello
world'' program with two files. Here is an example `OMakefile' (the two
definitions of `CFLAGS' are for illustration).
<<
      # The executable is compiled with debugging
      CFLAGS = -g
      hello: hello_code.o hello_lib.o
         $(CC) $(CFLAGS) -o $@ $+
  
      # Redefine CFLAGS
      CFLAGS += -O3
>>
  
  In this project, the target `hello' is explicit. The scope of the
`hello' target is the line beginning with `hello:', where the value of
`CFLAGS' is `-g'. The other two targets, `hello_code.o' and
`hello_lib.o' do not appear as explicit targets, so their scope is at
the end of the `OMakefile', where the `CFLAGS' variable is defined to be
`-g -O3'. That is, `hello' will be linked with `CFLAGS=-g' and the `.o'
files will be compiled with `CFLAGS=-g -O3'.
  We can change this behavior for any of the targets by specifying them
as explicit targets. For example, suppose we wish to compile
`hello_lib.o' with a preprocessor variable `LIBRARY'.
<<
      # The executable is compiled with debugging
      CFLAGS = -g
      hello: hello_code.o hello_lib.o
         $(CC) $(CFLAGS) -o $@ $+
  
      # Compile hello_lib.o with CFLAGS = -g -DLIBRARY
      section
          CFLAGS += -DLIBRARY
          hello_lib.o:
  
      # Redefine CFLAGS
      CFLAGS += -O3
>>
  
  In this case, `hello_lib.o' is also mentioned as an explicit target,
in a scope where `CFLAGS=-g -DLIBRARY'. Since no rule body is specified,
it is compiled using the usual implicit rule for building `.o' files (in
a context where `CFLAGS=-g -DLIBRARY').
* Menu:

* Subsection 6-13-1::	Scoping of implicit rules
* Subsection 6-13-2::	Scoping of .SCANNER rules
* Subsection 6-13-3::	Scoping for .PHONY targets


Node: Subsection 6-13-1,	Next: Subsection 6-13-2,	Prev: Section 6-13,	Up: Section 6-13
  

6.13.1   Scoping of implicit rules
==================================
  
  Implicit rules (rules containing wildcard patterns) are not global,
they follow the normal scoping convention. This allows different parts
of a project to have different sets of implicit rules. If we like, we
can modify the example above to provide a new implicit rule for building
`hello_lib.o'.
<<
      # The executable is compiled with debugging
      CFLAGS = -g
      hello: hello_code.o hello_lib.o
         $(CC) $(CFLAGS) -o $@ $+
  
      # Compile hello_lib.o with CFLAGS = -g -DLIBRARY
      section
          %.o: %.c
              $(CC) $(CFLAGS) -DLIBRARY -c $<
          hello_lib.o:
  
      # Redefine CFLAGS
      CFLAGS += -O3
>>
  
  In this case, the target `hello_lib.o' is built in a scope with a new
implicit rule for building `%.o' files. The implicit rule adds the
`-DLIBRARY' option. This implicit rule is defined only for the target
`hello_lib.o'; the target `hello_code.o' is built as normal.

Node: Subsection 6-13-2,	Next: Subsection 6-13-3,	Prev: Subsection 6-13-1,	Up: Section 6-13
  

6.13.2   Scoping of .SCANNER rules
==================================
   
  Scanner rules are scoped the same way as normal rules. If the
`.SCANNER' rule is explicit (containing no wildcard patterns), then the
scope of the scan target is the same as the the rule. If the `.SCANNER'
rule is implicit, then the environment is taken from the `:scanner:'
dependency.
<<
      # The executable is compiled with debugging
      CFLAGS = -g
      hello: hello_code.o hello_lib.o
         $(CC) $(CFLAGS) -o $@ $+
  
      # scanner for .c files
      .SCANNER: scan-c-%.c: %.c
         $(CC) $(CFLAGS) -MM $<
  
      # Compile hello_lib.o with CFLAGS = -g -DLIBRARY
      section
          CFLAGS += -DLIBRARY
          hello_lib.o: hello_lib.c :scanner: scan-c-hello_lib.c
             $(CC) $(CFLAGS) -c $<
  
      # Compile hello_code.c with CFLAGS = -g -O3
      section
          CFLAGS += -O3
          hello_code.o: hello_code.c :scanner: scan-c-hello_code.c
             $(CC) $(CFLAGS) -c $<
>>
  
  Again, this is for illustration---it is unlikely you would need to
write a complicated configuration like this! In this case, the
`.SCANNER' rule specifies that the C-compiler should be called with the
`-MM' flag to compute dependencies. For the target `hello_lib.o', the
scanner is called with `CFLAGS=-g -DLIBRARY', and for `hello_code.o' it
is called with `CFLAGS=-g -O3'.

Node: Subsection 6-13-3,	Next: Chapter 7,	Prev: Subsection 6-13-2,	Up: Section 6-13
  

6.13.3   Scoping for .PHONY targets
===================================
   
  Phony targets (targets that do not correspond to files) are defined
with a `.PHONY:' rule. Phony targets are scoped as usual. The following
illustrates a common mistake, where the `.PHONY' target is declared
after it is used.
<<
      # !!This example is broken!!
      all: hello
  
      hello: hello_code.o hello_lib.o
          $(CC) $(CFLAGS) -o $@ $+
  
      .PHONY: all
>>
  
  This doesn't work as expected because the `.PHONY' declaration occurs
too late. The proper way to write this example is to place the `.PHONY'
declaration first.
<<
      # Phony targets must be declared before being used
      .PHONY: all
  
      all: hello
  
      hello: hello_code.o hello_lib.o
          $(CC) $(CFLAGS) -o $@ $+
>>
  
  Phony targets are passed to subdirectories. As a practical matter, it
is wise to declare all `.PHONY' targets in your root `OMakefile', before
any `.SUBDIRS'. This will ensure that 1) they are considered as phony
targets in each of the sbdirectories, and 2) you can build them from the
project root.
<<
      .PHONY: all install clean
  
      .SUBDIRS: src lib clib
>>
  
   

Node: Chapter 7,	Next: Section 7-1,	Prev: Section 6-13,	Up: Top
  

Chapter 7     Base library
**************************
     
* Menu:

* Section 7-1::	Builtin variables
* Section 7-2::	Boolean functions and control flow
* Section 7-3::	Arrays and sequences
* Section 7-4::	Arithmetic
* Section 7-5::	First-class functions
* Section 7-6::	Iteration and mapping


Node: Section 7-1,	Next: Subsection 7-1-1,	Prev: Chapter 7,	Up: Chapter 7
  

7.1   Builtin variables
*=*=*=*=*=*=*=*=*=*=*=*

   
* Menu:

* Subsection 7-1-1::	OSTYPE
* Subsection 7-1-2::	SYSNAME
* Subsection 7-1-3::	NODENAME
* Subsection 7-1-4::	OS_VERSION
* Subsection 7-1-5::	MACHINE
* Subsection 7-1-6::	HOST
* Subsection 7-1-7::	OMAKE_VERSION
* Subsection 7-1-8::	USER
* Subsection 7-1-9::	HOME
* Subsection 7-1-10::	PID
* Subsection 7-1-11::	TARGETS


Node: Subsection 7-1-1,	Next: Subsection 7-1-2,	Prev: Section 7-1,	Up: Section 7-1
  

7.1.1   OSTYPE
==============
  Set to the machine
architecture omake is running on. Possible values are  `Unix' (for all
Unix versions, including Linux and Mac OS X), `Win32'  (for MS-Windows,
OMake compiled with MSVC++ or Mingw), and `Cygwin' (for  MS-Windows,
OMake compiled with Cygwin). 

Node: Subsection 7-1-2,	Next: Subsection 7-1-3,	Prev: Subsection 7-1-1,	Up: Section 7-1
  

7.1.2   SYSNAME
===============
  The name of the
operating system for the current machine. 

Node: Subsection 7-1-3,	Next: Subsection 7-1-4,	Prev: Subsection 7-1-2,	Up: Section 7-1
  

7.1.3   NODENAME
================
  The hostname of the
current machine. 

Node: Subsection 7-1-4,	Next: Subsection 7-1-5,	Prev: Subsection 7-1-3,	Up: Section 7-1
  

7.1.4   OS_VERSION
==================
  The operating
system release. 

Node: Subsection 7-1-5,	Next: Subsection 7-1-6,	Prev: Subsection 7-1-4,	Up: Section 7-1
  

7.1.5   MACHINE
===============
  The machine
architecture, e.g. `i386', `sparc', etc. 

Node: Subsection 7-1-6,	Next: Subsection 7-1-7,	Prev: Subsection 7-1-5,	Up: Section 7-1
  

7.1.6   HOST
============
  Same as `NODENAME'. 

Node: Subsection 7-1-7,	Next: Subsection 7-1-8,	Prev: Subsection 7-1-6,	Up: Section 7-1
  

7.1.7   OMAKE_VERSION
=====================
  Version of
OMake. 

Node: Subsection 7-1-8,	Next: Subsection 7-1-9,	Prev: Subsection 7-1-7,	Up: Section 7-1
  

7.1.8   USER
============
  The login name of the
user executing the process. 

Node: Subsection 7-1-9,	Next: Subsection 7-1-10,	Prev: Subsection 7-1-8,	Up: Section 7-1
  

7.1.9   HOME
============
  The home directory of
the user executing the process. 

Node: Subsection 7-1-10,	Next: Subsection 7-1-11,	Prev: Subsection 7-1-9,	Up: Section 7-1
  

7.1.10   PID
============
  The OMake process id. 

Node: Subsection 7-1-11,	Next: Section 7-2,	Prev: Subsection 7-1-10,	Up: Section 7-1
  

7.1.11   TARGETS
================
  The command-line
targets. For example, if `omake' is invoked with the  following command
line,
<<
        omake CFLAGS=1 foo bar.c
>>
  
   then `TARGETS' is defined as `foo bar.c'. 

Node: Section 7-2,	Next: Subsection 7-2-1,	Prev: Section 7-1,	Up: Chapter 7
  

7.2   Boolean functions and control flow
*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=

  
* Menu:

* Subsection 7-2-1::	not
* Subsection 7-2-2::	equal
* Subsection 7-2-3::	and
* Subsection 7-2-4::	or
* Subsection 7-2-5::	if
* Subsection 7-2-6::	switch
* Subsection 7-2-7::	match
* Subsection 7-2-8::	try
* Subsection 7-2-9::	raise
* Subsection 7-2-10::	exit
* Subsection 7-2-11::	defined
* Subsection 7-2-12::	defined-env
* Subsection 7-2-13::	getenv
* Subsection 7-2-14::	setenv
* Subsection 7-2-15::	get-registry
* Subsection 7-2-16::	getvar
* Subsection 7-2-17::	setvar


Node: Subsection 7-2-1,	Next: Subsection 7-2-2,	Prev: Section 7-2,	Up: Section 7-2
  

7.2.1   not
===========

<<
     $(not e) : String
        e : String
>>
  
  Boolean values in omake are represented by case-insensitive strings.
The false value can be represented by the strings `false', `no', `nil',
`undefined' or `0', and everything else is true. The `not' function
negates a Boolean value.
  For example, `$(not false)' expands to the string `true', and `$(not
hello world)' expands to `false'. 

Node: Subsection 7-2-2,	Next: Subsection 7-2-3,	Prev: Subsection 7-2-1,	Up: Section 7-2
  

7.2.2   equal
=============

<<
     $(equal e1, e2) : String
        e1 : String
        e2 : String
>>
  
  The `equal' function tests for equality of two values.
  For example `$(equal a, b)' expands to `false', and `$(equal hello
world, hello world)' expands to `true'. 

Node: Subsection 7-2-3,	Next: Subsection 7-2-4,	Prev: Subsection 7-2-2,	Up: Section 7-2
  

7.2.3   and
===========

<<
      $(and e1, ..., en) : String
         e1, ..., en: Sequence
>>
  
  The `and' function evaluates to the conjunction of its arguments.
  For example, in the following code, `X' is true, and `Y' is false.
<<
      A = a
      B = b
      X = $(and $(equal $(A), a) true $(equal $(B), b))
      Y = $(and $(equal $(A), a) true $(equal $(A), $(B)))
>>

Node: Subsection 7-2-4,	Next: Subsection 7-2-5,	Prev: Subsection 7-2-3,	Up: Section 7-2
  

7.2.4   or
==========

<<
     $(or e1, ..., en) : String
        e1, ..., en: String Sequence
>>
  
  The `or' function evaluates to the disjunction of its arguments.
  For example, in the following code, `X' is true, and `Y' is false.
<<
      A = a
      B = b
      X = $(or $(equal $(A), a) false $(equal $(A), $(B)))
      Y = $(or $(equal $(A), $(B)) $(equal $(A), b))
>>

Node: Subsection 7-2-5,	Next: Subsection 7-2-6,	Prev: Subsection 7-2-4,	Up: Section 7-2
  

7.2.5   if
==========

<<
      $(if e1, e2[, e3]) : value
         e1 : String
         e2, e3 : value
>>
  
  The `if' function represents a conditional based on a Boolean value.
For example `$(if $(equal a, b), c, d)' evaluates to `d'.
  Conditionals may also be declared with an alternate syntax.
<<
     if e1
        body1
     elseif e2
        body2
     ...
     else
        bodyn
>>
  
  If the expression `e1' is not false, then the expressions in `body1'
are evaluated and the result is returned as the value of the
conditional. Otherwise, if `e1' evaluates to false, the evaluation
continues with the `e2' expression. If none of the conditional
expressions is true, then the expressions in `bodyn' are evaluated and
the result is returned as the value of the conditional.
  There can be any number of `elseif' clauses; the `else' clause is
optional.
  Note that each branch of the conditional defines its own scope, so
variables defined in the branches are normally not visible outside the
conditional. The `export' command may be used to export the variables
defined in a scope. For example, the following expression represents a
common idiom for defining the C compiler configuration.
<<
     if $(equal $(OSTYPE), Win32)
        CC = cl
        CFLAGS += /DWIN32
        export
     else
        CC = gcc
        CFLAGS += -g -O2
        export
>>

Node: Subsection 7-2-6,	Next: Subsection 7-2-7,	Prev: Subsection 7-2-5,	Up: Section 7-2
  

7.2.6   switch
==============
 

Node: Subsection 7-2-7,	Next: Subsection 7-2-8,	Prev: Subsection 7-2-6,	Up: Section 7-2
  

7.2.7   match
=============

  The `switch' and `match' functions perform pattern matching.
  `$(switch <arg>, <pattern_1>, <value_1>, ..., <pattern_n>, <value_n>)'
`$(match <arg>, <pattern_1>, <value_1>, ..., <pattern_n>, <value_n>)'
  The number of `<pattern>/<value>' pairs is arbitrary. They strictly
alternate; the total number of arguments to `<match>' must be odd.
  The `<arg>' is evaluated to a string, and compared with `<pattern_1>'.
If it matches, the result of the expression is `<value_1>'. Otherwise
evaluation continues with the remaining patterns until a match is found.
If no pattern matches, the value is the empty string.
  The `switch' function uses string comparison to compare the argument
with the patterns. For example, the following expression defines the
`FILE' variable to be either `foo', `bar', or the empty string,
depending on the value of the `OSTYPE' variable.
<<
      FILE = $(switch $(OSTYPE), Win32, foo, Unix, bar)
>>
  
  The `match' function uses regular expression patterns (see the `grep'
function). If a match is found, the variables `$1, $2, ...' are bound to
the substrings matched between `\(' and `\)' delimiters. The `$0'
variable contains the entire match, and `$*' is an array of the matched
substrings. to the matched substrings.
<<
      FILE = $(match foo_xyz/bar.a, foo_\\\(.*\\\)/\\\(.*\\\)\.a,
foo_$2/$1.o)
>>
  
  The `switch' and `match' functions also have an alternate (more
usable) form.
<<
     match e
     case pattern1
        body1
     case pattern2
        body2
     ...
     default
        bodyd
>>
  
  If the value of expression `e' matches `pattern_i' and no previous
pattern, then `body_i' is evaluated and returned as the result of the
`match'. The `switch' function uses string comparison; the `match'
function uses regular expression matching.
<<
     match $(FILE)
     case $".*\(\.[^\/.]*\)"
        println(The string $(FILE) has suffix $1)
     default
        println(The string $(FILE) has no suffix)
>>

Node: Subsection 7-2-8,	Next: Subsection 7-2-9,	Prev: Subsection 7-2-7,	Up: Section 7-2
  

7.2.8   try
===========

<<
     try
        try-body
     catch class1(v1)
        catch-body
     when expr
        when-body
     ...
     finally
        finally-body
>>
  
  The `try' form is used for exception handling. First, the expressions
in the `try-body' are evaluated.
  If evaluation results in a value `v' without raising an exception,
then the expressions in the `finally-body' are evaluated and the value
`v' is returned as the result.
  If evaluation of the `try-body' results in a exception object `obj',
the `catch' clauses are examined in order. When examining `catch' clause
`catch class(v)', if the exception object `obj' is an instance of the
class name `class', the variable `v' is bound to the exception object,
and the expressions in the `catch-body' are evaluated.
  If a `when' clause is encountered while a `catch' body is being
evaluated, the predicate `expr' is evaluated. If the result is true,
evaluation continues with the expressions in the `when-body'. Otherwise,
the next `catch' clause is considered for evaluation.
  If evaluation of a `catch-body' or `when-body' completes successfully,
returning a value `v', without encountering another `when' clause, then
the expressions in the `finally-body' are evaluated and the value `v' is
returned as the result.
  There can be any number of `catch' clauses; the `finally' clause is
optional. 

Node: Subsection 7-2-9,	Next: Subsection 7-2-10,	Prev: Subsection 7-2-8,	Up: Section 7-2
  

7.2.9   raise
=============

<<
     raise exn
        exn : Exception
>>
  
  The `raise' function raises an exception. The `exn' object can be any
object. However, the normal convention is to raise an `Exception'
object. 

Node: Subsection 7-2-10,	Next: Subsection 7-2-11,	Prev: Subsection 7-2-9,	Up: Section 7-2
  

7.2.10   exit
=============

<<
     exit(code)
        code : Int
>>
  
  The `exit' function terminates omake abnormally.
  `$(exit <code>)'
  The `exit' function takes one integer argument, which is exit code.
Non-zero values indicate abnormal termination. 

Node: Subsection 7-2-11,	Next: Subsection 7-2-12,	Prev: Subsection 7-2-10,	Up: Section 7-2
  

7.2.11   defined
================

<<
     $(defined sequence) : String
        sequence : Sequence
>>
  
  The `defined' function test whether all the variables in the sequence
are currently defined. For example, the following code defines the `X'
variable if it is not already defined.
<<
      if $(not $(defined X))
         X = a b c
         export
>>

Node: Subsection 7-2-12,	Next: Subsection 7-2-13,	Prev: Subsection 7-2-11,	Up: Section 7-2
  

7.2.12   defined-env
====================

<<
     $(defined-env sequence) : String
        sequence : String
>>
  
  The `defined-env' function tests whether a variable is defined as part
of the process environment.
  For example, the following code adds the `-g' compile option if the
environment variable `DEBUG' is defined.
<<
  if $(defined-env DEBUG)
      CFLAGS += -g
      export
>>

Node: Subsection 7-2-13,	Next: Subsection 7-2-14,	Prev: Subsection 7-2-12,	Up: Section 7-2
  

7.2.13   getenv
===============

<<
     $(getenv name) : String
     $(getenv name, default) : String
>>
  
  The `getenv' function gets the value of a variable from the process
environment. The function takes one or two arguments.
  In the single argument form, an exception is raised if the variable
variable is not defined in the environment. In the two-argument form,
the second argument is returned as the result if the value is not
defined.
  For example, the following code defines the variable `X' to be a
space-separated list of elements of the `PATH' environment variable if
it is defined, and to `/bin /usr/bin' otherwise.
<<
      X = $(split $(PATHSEP), $(getenv PATH, /bin:/usr/bin))
>>
  
  You may also use the alternate form. 
<<
       getenv(NAME)
           default
>>

Node: Subsection 7-2-14,	Next: Subsection 7-2-15,	Prev: Subsection 7-2-13,	Up: Section 7-2
  

7.2.14   setenv
===============

<<
     setenv(name, value)
        name : String
        value : String
>>
  
  The `setenv' function sets the value of a variable in the process
environment. Environment variables are scoped like normal variables.

Node: Subsection 7-2-15,	Next: Subsection 7-2-16,	Prev: Subsection 7-2-14,	Up: Section 7-2
  

7.2.15   get-registry
=====================

<<
     get-registry(hkey, key, field) : String
     get-registry(hkey, key, field, default) : String
         hkey : String
         key : String
         field : String
>>
  
  The `get-registry' function retrieves a string value from the system
registry on Win32. On other architectures, there is no registry.
  The `hive' (I think that is the right word), indicates which part of
the registry to use. It should be one of the following values.
  
  
 - `HKEY_CLASSES_ROOT' 
 - `HKEY_CURRENT_CONFIG' 
 - `HKEY_CURRENT_USER' 
 - `HKEY_LOCAL_MACHINE' 
 - `HKEY_USERS' 
   Refer to the Microsoft documentation if you want to know what these
mean.
  The `key' is the field you want to get from the registry. It should
have a form like `A\B\C' (if you use forward slashes, they will be
converted to backslashes). The field is the sub-field of the key.
  In the 4-argument form, the `default' is returned on failure. You may
also use the alternate form.
<<
      get-registry(hkey, key, field)
         default
>>
  

Node: Subsection 7-2-16,	Next: Subsection 7-2-17,	Prev: Subsection 7-2-15,	Up: Section 7-2
  

7.2.16   getvar
===============

<<
     $(getvar name) : String
>>
  
  The `getvar' function gets the value of a variable.
  An exception is raised if the variable variable is not defined.
  For example, the following code defines X to be the string abc.
<<
      NAME = foo
      foo_1 = abc
      X = $(getvar $(NAME)_1)
>>

Node: Subsection 7-2-17,	Next: Section 7-3,	Prev: Subsection 7-2-16,	Up: Section 7-2
  

7.2.17   setvar
===============

<<
     setvar(name, value)
        name : String
        value : String
>>
  
  The `setvar' function defines a new variable. For example, the
following code defines the variable `X' to be the string `abc'.
<<
     NAME = X
     setvar($(NAME), abc)
>>

Node: Section 7-3,	Next: Subsection 7-3-1,	Prev: Section 7-2,	Up: Chapter 7
  

7.3   Arrays and sequences
*=*=*=*=*=*=*=*=*=*=*=*=*=

  
* Menu:

* Subsection 7-3-1::	array
* Subsection 7-3-2::	split
* Subsection 7-3-3::	concat
* Subsection 7-3-4::	length
* Subsection 7-3-5::	nth
* Subsection 7-3-6::	nth-hd
* Subsection 7-3-7::	nth-tl
* Subsection 7-3-8::	subrange
* Subsection 7-3-9::	rev
* Subsection 7-3-10::	string
* Subsection 7-3-11::	quote
* Subsection 7-3-12::	quote-argv
* Subsection 7-3-13::	html-string
* Subsection 7-3-14::	addsuffix
* Subsection 7-3-15::	mapsuffix
* Subsection 7-3-16::	addsuffixes
* Subsection 7-3-17::	removeprefix
* Subsection 7-3-18::	removesuffix
* Subsection 7-3-19::	replacesuffixes
* Subsection 7-3-20::	addprefix
* Subsection 7-3-21::	mapprefix
* Subsection 7-3-22::	add-wrapper
* Subsection 7-3-23::	set
* Subsection 7-3-24::	mem
* Subsection 7-3-25::	intersection
* Subsection 7-3-26::	intersects
* Subsection 7-3-27::	set-diff
* Subsection 7-3-28::	filter
* Subsection 7-3-29::	filter-out
* Subsection 7-3-30::	capitalize
* Subsection 7-3-31::	uncapitalize
* Subsection 7-3-32::	uppercase
* Subsection 7-3-33::	lowercase
* Subsection 7-3-34::	system
* Subsection 7-3-35::	shell
* Subsection 7-3-36::	while


Node: Subsection 7-3-1,	Next: Subsection 7-3-2,	Prev: Section 7-3,	Up: Section 7-3
  

7.3.1   array
=============

<<
      $(array elements) : Array
         elements : Sequence
>>
  
  The `array' function creates an array from a sequence. If the `<arg>'
is a string, the elements of the array are the whitespace-separated
elements of the string, respecting quotes.
  In addition, array variables can be declared as follows.
<<
      A[] =
         <val1>
         ...
         <valn>
>>
  
  In this case, the elements of the array are exactly `<val1>', ...,
`<valn>', and whitespace is preserved literally. 

Node: Subsection 7-3-2,	Next: Subsection 7-3-3,	Prev: Subsection 7-3-1,	Up: Section 7-3
  

7.3.2   split
=============

<<
     $(split sep, elements) : Array
        sep : String
        elements : Sequence
>>
  
  The `split' function takes two arguments, a string of separators, and
a string argument. The result is an array of elements determined by
splitting the elements by all occurrence of the separator in the
`elements' sequence.
  For example, in the following code, the `X' variable is defined to be
the array `/bin /usr/bin /usr/local/bin'.
<<
      PATH = /bin:/usr/bin:/usr/local/bin
      X = $(split :, $(PATH))
>>
  
  The `sep' argument may be omitted. In this case `split' breaks its
arguments along the white space. Quotations are not split. 

Node: Subsection 7-3-3,	Next: Subsection 7-3-4,	Prev: Subsection 7-3-2,	Up: Section 7-3
  

7.3.3   concat
==============

<<
     $(concat sep, elements) : String
        sep : String
        elements : Sequence
>>
  
  The `concat' function takes two arguments, a separator string, and a
sequence of elements. The result is a string formed by concatenating the
elements, placing the separator between adjacent elements.
  For example, in the following code, the `X' variable is defined to be
the string `foo_x_bar_x_baz'.
<<
      X = foo  bar     baz
      Y = $(concat _x_, $(X))
>>

Node: Subsection 7-3-4,	Next: Subsection 7-3-5,	Prev: Subsection 7-3-3,	Up: Section 7-3
  

7.3.4   length
==============

<<
     $(length sequence) : Int
        sequence : Sequence
>>
  
  The `length' function returns the number of elements in its argument.
  For example, the expression `$(length a  b "c d")' evaluates to 3. 

Node: Subsection 7-3-5,	Next: Subsection 7-3-6,	Prev: Subsection 7-3-4,	Up: Section 7-3
  

7.3.5   nth
===========

<<
     $(nth i, sequence) : value
        i : Int
        sequence : Sequence
     raises RuntimeException
>>
  
  The `nth' function returns the nth element of its argument, treated as
a list. Counting starts at 0. An exception is raised if the index is not
in bounds.
  For example, the expression `$(nth 1, a "b c" d)' evaluates to `"b
c"'. 

Node: Subsection 7-3-6,	Next: Subsection 7-3-7,	Prev: Subsection 7-3-5,	Up: Section 7-3
  

7.3.6   nth-hd
==============

<<
     $(nth-hd i, sequence) : value
        i : Int
        sequence : Sequence
     raises RuntimeException
>>
  
  The `nth-hd' function returns the first `i' elements of the sequence.
An exception is raised if the sequence is not at least `i' elements
long.
  For example, the expression `$(nth-hd 2, a "b c" d)' evaluates to `a
"b c"'.

Node: Subsection 7-3-7,	Next: Subsection 7-3-8,	Prev: Subsection 7-3-6,	Up: Section 7-3
  

7.3.7   nth-tl
==============

<<
     $(nth-tl i, sequence) : value
        i : Int
        sequence : Sequence
     raises RuntimeException
>>
  
  The `nth-tl' function skips `i' elements of the sequence and returns
the rest. An exception is raised if the sequence is not at least `i'
elements long.
  For example, the expression `$(nth-tl 1, a "b c" d)' evaluates to `"b
c" d'.

Node: Subsection 7-3-8,	Next: Subsection 7-3-9,	Prev: Subsection 7-3-7,	Up: Section 7-3
  

7.3.8   subrange
================

<<
     $(subrange off, len, sequent) : value
        off : Int
        len : Int
        sequence : Sequence
     raises RuntimeException
>>
  
  The `subrange' function returns a subrange of the sequence. Counting
starts at 0. An exception is raised if the specified range is not in
bounds.
  For example, the expression `$(subrange 1, 2, a "b c" d e)' evaluates
to `"b c" d'. 

Node: Subsection 7-3-9,	Next: Subsection 7-3-10,	Prev: Subsection 7-3-8,	Up: Section 7-3
  

7.3.9   rev
===========

<<
      $(rev sequence) : Sequence
         sequence : Sequence
>>
  
  The `rev' function returns the elements of a sequence in reverse
order. For example, the expression `$(rev a "b c" d)' evaluates to `d "b
c" a'. 

Node: Subsection 7-3-10,	Next: Subsection 7-3-11,	Prev: Subsection 7-3-9,	Up: Section 7-3
  

7.3.10   string
===============

<<
     $(string sequence) : String
        sequence : Sequence
>>
  
  The `string' function flattens a sequence into a single string. This
is similar to the `concat' function, but the elements are separated by
whitespace. The result is treated as a unit; whitespace is significant. 

Node: Subsection 7-3-11,	Next: Subsection 7-3-12,	Prev: Subsection 7-3-10,	Up: Section 7-3
  

7.3.11   quote
==============

<<
     $(quote sequence) : String
        sequence : Sequence
>>
  
  The `quote' function flattens a sequence into a single string and adds
quotes around the string. Inner quotation symbols are escaped.
  For example, the expression `$(quote a "b c" d)' evaluates to `"a \"b
c\" d"', and `$(quote abc)' evaluates to `"abc"'. 

Node: Subsection 7-3-12,	Next: Subsection 7-3-13,	Prev: Subsection 7-3-11,	Up: Section 7-3
  

7.3.12   quote-argv
===================

<<
     $(quote-argv sequence) : String
        sequence : Sequence
>>
  
  The `quote-argv' function flattens a sequence into a single string,
and adds quotes around the string. The quotation is formed so that a
command-line parse can separate the string back into its components. 

Node: Subsection 7-3-13,	Next: Subsection 7-3-14,	Prev: Subsection 7-3-12,	Up: Section 7-3
  

7.3.13   html-string
====================

<<
     $(html-string sequence) : String
        sequence : Sequence
>>
  
  The `html-string' function flattens a sequence into a single string,
and escaped special HTML characters. This is similar to the `concat'
function, but the elements are separated by whitespace. The result is
treated as a unit; whitespace is significant. 

Node: Subsection 7-3-14,	Next: Subsection 7-3-15,	Prev: Subsection 7-3-13,	Up: Section 7-3
  

7.3.14   addsuffix
==================

<<
     $(addsuffix suffix, sequence) : Array
        suffix : String
        sequence : Sequence
>>
  
  The `addsuffix' function adds a suffix to each component of sequence.
The number of elements in the array is exactly the same as the number of
elements in the sequence.
  For example, `$(addsuffix .c, a b "c d")' evaluates to `a.c b.c "c
d".c'. 

Node: Subsection 7-3-15,	Next: Subsection 7-3-16,	Prev: Subsection 7-3-14,	Up: Section 7-3
  

7.3.15   mapsuffix
==================

<<
     $(mapsuffix suffix, sequence) : Array
        suffix : value
        sequence : Sequence
>>
  
  The `mapsuffix' function adds a suffix to each component of sequence.
It is similar to `addsuffix', but uses array concatenation instead of
string concatenation. The number of elements in the array is twice the
number of elements in the sequence.
  For example, `$(mapsuffix .c, a b "c d")' evaluates to `a .c b .c "c
d" .c'. 

Node: Subsection 7-3-16,	Next: Subsection 7-3-17,	Prev: Subsection 7-3-15,	Up: Section 7-3
  

7.3.16   addsuffixes
====================

<<
     $(addsuffixes suffixes, sequence) : Array
        suffixes : Sequence
        sequence : Sequence
>>
  
  The `addsuffixes' function adds all suffixes in its first argument to
each component of a sequence. If `suffixes' has `n' elements, and
`sequence' has `m' elements, the the result has `n * m' elements.
  For example, the `$(addsuffixes .c .o, a b c)' expressions evaluates
to `a.c a.o b.c b.o c.o c.a'. 

Node: Subsection 7-3-17,	Next: Subsection 7-3-18,	Prev: Subsection 7-3-16,	Up: Section 7-3
  

7.3.17   removeprefix
=====================

<<
     $(removeprefix prefix, sequence) : Array
        prefix : String
        sequence : Array
>>
  
  The `removeprefix' function removes a prefix from each component of a
sequence. 

Node: Subsection 7-3-18,	Next: Subsection 7-3-19,	Prev: Subsection 7-3-17,	Up: Section 7-3
  

7.3.18   removesuffix
=====================

<<
     $(removesuffix sequence) : Array
        sequence : String
>>
  
  The `removesuffix' function removes the suffixes from each component
of a sequence.
  For example, `$(removesuffix a.c b.foo "c d")' expands to `a b "c d"'.

Node: Subsection 7-3-19,	Next: Subsection 7-3-20,	Prev: Subsection 7-3-18,	Up: Section 7-3
  

7.3.19   replacesuffixes
========================

<<
     $(replacesuffixes old-suffixes, new-suffixes, sequence) : Array
        old-suffixes : Sequence
        new-suffixes : Sequence
        sequence : Sequence
>>
  
  The `replacesuffixes' function modifies the suffix of each component
in sequence. The `old-suffixes' and `new-suffixes' sequences should have
the same length.
  For example, `$(replacesuffixes, .h .c, .o .o, a.c b.h c.z)' expands
to `a.o b.o c.z'. 

Node: Subsection 7-3-20,	Next: Subsection 7-3-21,	Prev: Subsection 7-3-19,	Up: Section 7-3
  

7.3.20   addprefix
==================

<<
     $(addprefix prefix, sequence) : Array
        prefix : String
        sequence : Sequence
>>
  
  The `addprefix' function adds a prefix to each component of a
sequence. The number of element in the result array is exactly the same
as the number of elements in the argument sequence.
  For example, `$(addprefix foo/, a b "c d")' evaluates to `foo/a foo/b
foo/"c d"'. 

Node: Subsection 7-3-21,	Next: Subsection 7-3-22,	Prev: Subsection 7-3-20,	Up: Section 7-3
  

7.3.21   mapprefix
==================

<<
     $(mapprefix prefix, sequence) : Array
        prefix : String
        sequence : Sequence
>>
  
  The `mapprefix' function adds a prefix to each component of a
sequence. It is similar to `addprefix', but array concatenation is used
instead of string concatenation. The result array contains twice as many
elements as the argument sequence.
  For example, `$(mapprefix foo, a b "c d")' expands to `foo a foo b foo
"c d"'. 

Node: Subsection 7-3-22,	Next: Subsection 7-3-23,	Prev: Subsection 7-3-21,	Up: Section 7-3
  

7.3.22   add-wrapper
====================

<<
     $(add-wrapper prefix, suffix, sequence) : Array
        prefix : String
        suffix : String
        sequence : Sequence
>>
  
  The `add-wrapper' functions adds both a prefix and a suffix to each
component of a sequence. For example, the expression `$(add-wrapper
dir/, .c, a b)' evaluates to `dir/a.c dir/b.c'. String concatenation is
used. The array result has the same number of elements as the argument
sequence. 

Node: Subsection 7-3-23,	Next: Subsection 7-3-24,	Prev: Subsection 7-3-22,	Up: Section 7-3
  

7.3.23   set
============

<<
     $(set sequence) : Array
        sequence : Sequence
>>
  
  The `set' function sorts a set of string components, eliminating
duplicates.
  For example, `$(set z y z "m n" w a)' expands to `"m n" a w y z'. 

Node: Subsection 7-3-24,	Next: Subsection 7-3-25,	Prev: Subsection 7-3-23,	Up: Section 7-3
  

7.3.24   mem
============

<<
     $(mem elem, sequence) : Boolean
        elem : String
        sequence : Sequence
>>
  
  The `mem' function tests for membership in a sequence.
  For example, `$(mem "m n", y z "m n" w a)' evaluates to `true', while
`$(mem m n, y z "m n" w a)' evaluates to `false'. 

Node: Subsection 7-3-25,	Next: Subsection 7-3-26,	Prev: Subsection 7-3-24,	Up: Section 7-3
  

7.3.25   intersection
=====================

<<
     $(intersection sequence1, sequence2) : Array
        sequence1 : Sequence
        sequence2 : Sequence
>>
  
  The `intersection' function takes two arguments, treats them as sets
of strings, and computes their intersection. The order of the result is
undefined, and it may contain duplicates. Use the `set' function to sort
the result and eliminate duplicates in the result if desired.
  For example, the expression `$(intersection c a b a, b a)' evaluates
to `a b a'. 

Node: Subsection 7-3-26,	Next: Subsection 7-3-27,	Prev: Subsection 7-3-25,	Up: Section 7-3
  

7.3.26   intersects
===================

<<
     $(intersects sequence1, sequence2) : Boolean
        sequence1 : Sequence
        sequence2 : Sequence
>>
  
  The `intersects' function tests whether two sets have a non-empty
intersection. This is slightly more efficient than computing the
intersection and testing whether it is empty.
  For example, the expression `$(intersects a b c, d c e)' evaluates to
`true', and `$(intersects a b c a, d e f)' evaluates to `false'. 

Node: Subsection 7-3-27,	Next: Subsection 7-3-28,	Prev: Subsection 7-3-26,	Up: Section 7-3
  

7.3.27   set-diff
=================

<<
     $(set-diff sequence1, sequence2) : Array
        sequence1 : Sequence
        sequence2 : Sequence
>>
  
  The `set-diff' function takes two arguments, treats them as sets of
strings, and computes their difference (all the elements of the first
set that are not present in the second one). The order of the result is
undefined and it may contain duplicates. Use the `set' function to sort
the result and eliminate duplicates in the result if desired.
  For example, the expression `$(set-diff c a b a e, b a)' evaluates to
`c e'. 

Node: Subsection 7-3-28,	Next: Subsection 7-3-29,	Prev: Subsection 7-3-27,	Up: Section 7-3
  

7.3.28   filter
===============

<<
     $(filter patterns, sequence) : Array
        patterns : Sequence
        sequence : Sequence
>>
  
  The `filter' function picks elements from a sequence. The patterns is
a non-empty sequence of patterns, each may contain one occurrence of the
wildcard `%' character.
  For example `$(filter %.h %.o, a.c x.o b.h y.o "hello world".c)'
evaluates to `x.o b.h y.o'. 

Node: Subsection 7-3-29,	Next: Subsection 7-3-30,	Prev: Subsection 7-3-28,	Up: Section 7-3
  

7.3.29   filter-out
===================

<<
     $(filter-out patterns, sequence) : Array
        patterns : Sequence
        sequence : Sequence
>>
  
  The `filter-out' function removes elements from a sequence. The
patterns is a non-empty sequence of patterns, each may contain one
occurrence of the wildcard `%' character.
  For example `$(filter-out %.c %.h, a.c x.o b.h y.o "hello world".c)'
evaluates to `x.o y.o'. 

Node: Subsection 7-3-30,	Next: Subsection 7-3-31,	Prev: Subsection 7-3-29,	Up: Section 7-3
  

7.3.30   capitalize
===================

<<
     $(capitalize sequence) : Array
        sequence : Sequence
>>
  
  The `capitalize' function capitalizes each word in a sequence. For
example, `$(capitalize through the looking Glass)' evaluates to `Through
The Looking Glass'. 

Node: Subsection 7-3-31,	Next: Subsection 7-3-32,	Prev: Subsection 7-3-30,	Up: Section 7-3
  

7.3.31   uncapitalize
=====================

<<
     $(uncapitalize sequence) : Array
        sequence : Sequence
>>
  
  The `uncapitalize' function uncapitalizes each word in its argument.
  For example, `$(uncapitalize through the looking Glass)' evaluates to
`through the looking glass'. 

Node: Subsection 7-3-32,	Next: Subsection 7-3-33,	Prev: Subsection 7-3-31,	Up: Section 7-3
  

7.3.32   uppercase
==================

<<
     $(uppercase sequence) : Array
        sequence : Sequence
>>
  
  The `uppercase' function converts each word in a sequence to
uppercase. For example, `$(uppercase through the looking Glass)'
evaluates to `THROUGH THE LOOKING GLASS'. 

Node: Subsection 7-3-33,	Next: Subsection 7-3-34,	Prev: Subsection 7-3-32,	Up: Section 7-3
  

7.3.33   lowercase
==================

<<
     $(lowercase sequence) : Array
        sequence : Sequence
>>
  
  The `lowercase' function reduces each word in its argument to
lowercase.
  For example, `$(lowercase through tHe looking Glass)' evaluates to
`through the looking glass'. 

Node: Subsection 7-3-34,	Next: Subsection 7-3-35,	Prev: Subsection 7-3-33,	Up: Section 7-3
  

7.3.34   system
===============

<<
     system(s)
        s : Sequence
>>
  
  The `system' function is used to evaluate a shell expression. This
function is used internally by omake to evaluate shell commands.
  For example, the following program is equivalent to the expression
`system(ls foo)'.
<<
     ls foo
>>

Node: Subsection 7-3-35,	Next: Subsection 7-3-36,	Prev: Subsection 7-3-34,	Up: Section 7-3
  

7.3.35   shell
==============

<<
     $(shell command) : Array
     $(shella command) : Array
     $(shell-code command) : Int
        command : Sequence
>>
  
  The `shell' function evaluates a command using the command shell, and
returns the whitespace-separated words of the standard output as the
result.
  The `shella' function acts similarly, but it returns the lines as
separate items in the array.
  The `shell-code' function returns the exit code. The output is not
diverted.
  For example, if the current directory contains the files `OMakeroot',
`OMakefile', and `hello.c', then `$(shell ls)' evaluates to `hello.c
OMakefile OMakeroot' (on a Unix system).  

Node: Subsection 7-3-36,	Next: Section 7-4,	Prev: Subsection 7-3-35,	Up: Section 7-3
  

7.3.36   while
==============

<<
     while <test>
        <body>
>>
  
  --or--
<<
      while <test>
      case <test1>
         <body1>
      ...
      case <testn>
         <bodyn>
      default
         <bodyd>
>>
  
  The loop is executed while the test is true. In the first form, the
`<body>' is executed on every loop iteration. In the second form, the
body `<bodyI>' is selected, as the first case where the test `<testI>'
is true. If none apply, the optional default case is evaluated. If no
cases are true, the loop exits. The environment is automatically
exported.
  Examples.
  Iterate for `i' from `0' to `9'.
<<
      i = 0
      while $(lt $i, 10)
         echo $i
         i = $(add $i, 1)
>>
  
  The following example is equivalent.
<<
     i = 0
     while true
     case $(lt $i, 10)
        echo $i
        i = $(add $i, 1)
>>
  
  The following example is similar, but some special cases are printed.
value is printed.
<<
      i = 0
      while $(lt $i, 10)
      case $(equal $i, 0)
         echo zero
      case $(equal $i, 1)
         echo one
      default
         echo $i
>>

Node: Section 7-4,	Next: Subsection 7-4-1,	Prev: Section 7-3,	Up: Chapter 7
  

7.4   Arithmetic
*=*=*=*=*=*=*=*=

   
* Menu:

* Subsection 7-4-1::	int
* Subsection 7-4-2::	float
* Subsection 7-4-3::	Basic arithmetic
* Subsection 7-4-4::	Comparisons


Node: Subsection 7-4-1,	Next: Subsection 7-4-2,	Prev: Section 7-4,	Up: Section 7-4
  

7.4.1   int
===========

  The `int' function can be used to create integers. It returns an `Int'
object.
  `$(int 17)'.

Node: Subsection 7-4-2,	Next: Subsection 7-4-3,	Prev: Subsection 7-4-1,	Up: Section 7-4
  

7.4.2   float
=============
 The `float' function
can be used to create floating-point numbers. It returns a `Float'
object.
  `$(float 3.1415926)'. 

Node: Subsection 7-4-3,	Next: Subsection 7-4-4,	Prev: Subsection 7-4-2,	Up: Section 7-4
  

7.4.3   Basic arithmetic
========================
   












  The following functions can be used to perform basic arithmetic.
  
  
 - `$(neg <numbers>)': arithmetic inverse 
 - `$(add <numbers>)': addition. 
 - `$(sub <numbers>)': subtraction. 
 - `$(mul <numbers>)': multiplication. 
 - `$(div <numbers>)': division. 
 - `$(mod <numbers>)': remainder. 
 - `$(lnot <numbers>)': bitwise inverse. 
 - `$(land <numbers>)': bitwise and. 
 - `$(lor <numbers>)': bitwise or. 
 - `$(lxor <numbers>)': bitwise exclusive-or. 
 - `$(lsl <numbers>)': logical shift left. 
 - `$(lsr <numbers>)': logical shift right. 
 - `$(asr <numbers>)': arithmetic shift right. 
   

Node: Subsection 7-4-4,	Next: Section 7-5,	Prev: Subsection 7-4-3,	Up: Section 7-4
  

7.4.4   Comparisons
===================
   








  The following functions can be used to perform numerical comparisons.
  
  
 - `$(lt <numbers>)': less then. 
 - `$(le <numbers>)': no more than. 
 - `$(eq <numbers>)': equal. 
 - `$(ge <numbers>)': no less than. 
 - `$(gt <numbers>)': greater than. 
 - `$(ult <numbers>)': unsigned less than. 
 - `$(ule <numbers>)': unsigned greater than. 
 - `$(uge <numbers>)': unsigned greater than or equal. 
 - `$(ugt <numbers>)': unsigned greater than. 
   

Node: Section 7-5,	Next: Subsection 7-5-1,	Prev: Section 7-4,	Up: Chapter 7
  

7.5   First-class functions
*=*=*=*=*=*=*=*=*=*=*=*=*=*

   
* Menu:

* Subsection 7-5-1::	fun
* Subsection 7-5-2::	apply
* Subsection 7-5-3::	applya


Node: Subsection 7-5-1,	Next: Subsection 7-5-2,	Prev: Section 7-5,	Up: Section 7-5
  

7.5.1   fun
===========

  The `fun' form introduces anonymous functions.
  `$(fun <v1>, ..., <vn>, <body>)'
  The last argument is the body of the function. The other arguments are
the parameter names.
  The three following definitions are equivalent.
<<
      F(X, Y) =
         return($(addsuffix $(Y), $(X)))
  
      F = $(fun X, Y, $(addsuffix $(Y), $(X)))
  
      F =
         fun(X, Y)
            value $(addsuffix $(Y), $(X))
>>
