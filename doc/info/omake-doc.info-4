This file has been translated from LaTeX by HeVeA.

Node: Subsection 7-5-2,	Next: Subsection 7-5-3,	Prev: Subsection 7-5-1,	Up: Section 7-5
  

7.5.2   apply
=============

  The `apply' operator is used to apply a function.
  `$(apply <fun>, <args>)'
  Suppose we have the following function definition.
<<
      F(X, Y) =
         return($(addsuffix $(Y), $(X)))
>>
  
  The the two expressions below are equivalent.
<<
      X = F(a b c, .c)
      X = $(apply $(F), a b c, .c)
>>

Node: Subsection 7-5-3,	Next: Section 7-6,	Prev: Subsection 7-5-2,	Up: Section 7-5
  

7.5.3   applya
==============

  The `applya' operator is used to apply a function to an array of
arguments.
  `$(applya <fun>, <args>)'
  For example, in the following program, the value of `Z' is `file.c'.
<<
      F(X, Y) =
         return($(addsuffix $(Y), $(X)))
      args[] =
         file
         .c
      Z = $(applya $(F), $(args))
>>

Node: Section 7-6,	Next: Subsection 7-6-1,	Prev: Section 7-5,	Up: Chapter 7
  

7.6   Iteration and mapping
*=*=*=*=*=*=*=*=*=*=*=*=*=*

  
* Menu:

* Subsection 7-6-1::	foreach


Node: Subsection 7-6-1,	Next: Chapter 8,	Prev: Section 7-6,	Up: Section 7-6
  

7.6.1   foreach
===============

  The `foreach' function maps a function over a sequence.
<<
      $(foreach <fun>, <args>)
  
      foreach(<var>, <args>)
         <body>
>>
  
  For example, the following program defines the variable `X' as an
array `a.c b.c c.c'.
<<
      X =
         foreach(x, a b c)
            value $(x).c
  
      # Equivalent expression
      X = $(foreach $(fun x, $(x).c), abc)
>>
  
  There is also an abbreviated syntax.
  The `export' form can also be used in a `foreach' body. The final
value of `X' is `a.c b.c c.c'.
<<
      X =
      foreach(x, a b c)
         X += $(x).c
         export
>>

Node: Chapter 8,	Next: Section 8-1,	Prev: Section 7-6,	Up: Top
  

Chapter 8     File operations
*****************************
     
* Menu:

* Section 8-1::	File names
* Section 8-2::	Path search
* Section 8-3::	File stats
* Section 8-4::	Globbing and file listings
* Section 8-5::	Filesystem operations
* Section 8-6::	vmount
* Section 8-7::	File predicates
* Section 8-8::	IO functions
* Section 8-9::	Printing functions
* Section 8-10::	Value printing functions
* Section 8-11::	Higher-level IO functions


Node: Section 8-1,	Next: Subsection 8-1-1,	Prev: Chapter 8,	Up: Chapter 8
  

8.1   File names
*=*=*=*=*=*=*=*=

   
* Menu:

* Subsection 8-1-1::	file
* Subsection 8-1-2::	dir
* Subsection 8-1-3::	tmpfile
* Subsection 8-1-4::	in
* Subsection 8-1-5::	basename
* Subsection 8-1-6::	rootname
* Subsection 8-1-7::	dirof
* Subsection 8-1-8::	fullname
* Subsection 8-1-9::	absname
* Subsection 8-1-10::	homename
* Subsection 8-1-11::	suffix


Node: Subsection 8-1-1,	Next: Subsection 8-1-2,	Prev: Section 8-1,	Up: Section 8-1
  

8.1.1   file
============
 

Node: Subsection 8-1-2,	Next: Subsection 8-1-3,	Prev: Subsection 8-1-1,	Up: Section 8-1
  

8.1.2   dir
===========

<<
     $(file sequence) : File Sequence
        sequence : Sequence
     $(dir sequence) : Dir Sequence
        sequence : Sequence
>>
  
  The `file' and `dir' functions define location-independent references
to files and directories. In omake, the commands to build a target are
executed in the target's directory. Since there may be many directories
in an omake project, the build system provides a way to construct a
reference to a file in one directory, and use it in another without
explicitly modifying the file name. The functions have the following
syntax, where the name should refer to a file or directory.
  For example, we can construct a reference to a file `foo' in the
current directory.
<<
     FOO = $(file foo)
     .SUBDIRS: bar
>>
  
  If the `FOO' variable is expanded in the `bar' subdirectory, it will
expand to `../foo'.
  These commands are often used in the top-level OMakefile to provide
location-independent references to top-level directories, so that build
commands may refer to these directories as if they were absolute.
<<
     ROOT = $(dir .)
     LIB  = $(dir lib)
     BIN  = $(dir bin)
>>
  
  Once these variables are defined, they can be used in build commands
in subdirectories as follows, where `$(BIN)' will expand to the location
of the `bin' directory relative to the command being executed.
<<
     install: hello
   cp hello $(BIN)
>>

Node: Subsection 8-1-3,	Next: Subsection 8-1-4,	Prev: Subsection 8-1-2,	Up: Section 8-1
  

8.1.3   tmpfile
===============

<<
      $(tmpfile prefix) : File
      $(tmpfile prefix, suffix) : File
          prefix : String
          suffix : String
>>
  
  The `tmpfile' function returns the name of a fresh temporary file in
the temporary directory. 

Node: Subsection 8-1-4,	Next: Subsection 8-1-5,	Prev: Subsection 8-1-3,	Up: Section 8-1
  

8.1.4   in
==========

<<
     $(in dir, exp) : String Array
        dir : Dir
        exp : expression
>>
  
  The `in' function is closely related to the `dir' and `file'
functions. It takes a directory and an expression, and evaluates the
expression in that effective directory. For example, one common way to
install a file is to define a symbol link, where the value of the link
is relative to the directory where the link is created.
  The following commands create links in the `$(LIB)' directory.
<<
      FOO = $(file foo)
      install:
         ln -s $(in $(LIB), $(FOO)) $(LIB)/foo
>>
  
  Note that the `in' function only affects the expansion of `Node'
(`File' and `Dir') values. 

Node: Subsection 8-1-5,	Next: Subsection 8-1-6,	Prev: Subsection 8-1-4,	Up: Section 8-1
  

8.1.5   basename
================

<<
     $(basename files) : String Sequence
        files : String Sequence
>>
  
  The `basename' function returns the base names for a list of files.
The basename is the filename with any leading directory components
removed.
  For example, the expression `$(basename dir1/dir2/a.out
/etc/modules.conf /foo.ml)' evaluates to `a.out modules.conf foo.ml'. 

Node: Subsection 8-1-6,	Next: Subsection 8-1-7,	Prev: Subsection 8-1-5,	Up: Section 8-1
  

8.1.6   rootname
================

<<
     $(rootname files) : String Sequence
        files : String Sequence
>>
  
  The `rootname' function returns the root name for a list of files. The
rootname is the filename with the final suffix removed.
  For example, the expression `$(rootname dir1/dir2/a.out /etc/a.b.c
/foo.ml)' evaluates to `dir1/dir2/a /etc/a.b /foo'. 

Node: Subsection 8-1-7,	Next: Subsection 8-1-8,	Prev: Subsection 8-1-6,	Up: Section 8-1
  

8.1.7   dirof
=============

<<
     $(dirof files) : Dir Sequence
        files : File Sequence
>>
  
  The `dirof' function returns the directory for each of the listed
files.
  For example, the expression `$(dirof dir/dir2/a.out /etc/modules.conf
/foo.ml)' evaluates to the directories `dir1/dir2 /etc /'. 

Node: Subsection 8-1-8,	Next: Subsection 8-1-9,	Prev: Subsection 8-1-7,	Up: Section 8-1
  

8.1.8   fullname
================

<<
     $(fullname files) : String Sequence
        files : File Sequence
>>
  
  The `fullname' function returns the pathname relative to the project
root for each of the files or directories. 

Node: Subsection 8-1-9,	Next: Subsection 8-1-10,	Prev: Subsection 8-1-8,	Up: Section 8-1
  

8.1.9   absname
===============

<<
     $(absname files) : String Sequence
        files : File Sequence
>>
  
  The `absname' function returns the absolute pathname for each of the
files or directories. 

Node: Subsection 8-1-10,	Next: Subsection 8-1-11,	Prev: Subsection 8-1-9,	Up: Section 8-1
  

8.1.10   homename
=================

<<
     $(homename files) : String Sequence
        files : File Sequence
>>
  
  The `homename' function returns the name of a file in tilde form, if
possible. The unexpanded forms are computed lazily: the `homename'
function will usually evaluate to an absolute pathname until the first
tilde-expansion for the same directory. 

Node: Subsection 8-1-11,	Next: Section 8-2,	Prev: Subsection 8-1-10,	Up: Section 8-1
  

8.1.11   suffix
===============

<<
     $(suffix files) : String Sequence
        files : StringSequence
>>
  
  The `suffix' function returns the suffixes for a list of files. If a
file has no suffix, the function returns the empty string.
  For example, the expression `$(suffix dir1/dir2/a.out /etc/a /foo.ml)'
evaluates to `.out .ml'. 

Node: Section 8-2,	Next: Subsection 8-2-1,	Prev: Section 8-1,	Up: Chapter 8
  

8.2   Path search
*=*=*=*=*=*=*=*=*

   
* Menu:

* Subsection 8-2-1::	which
* Subsection 8-2-2::	where
* Subsection 8-2-3::	rehash
* Subsection 8-2-4::	exists-in-path
* Subsection 8-2-5::	digest
* Subsection 8-2-6::	find-in-path
* Subsection 8-2-7::	digest-path


Node: Subsection 8-2-1,	Next: Subsection 8-2-2,	Prev: Section 8-2,	Up: Section 8-2
  

8.2.1   which
=============

<<
     $(which files) : File Sequence
        files : String Sequence
>>
  
  The `which' function searches for executables in the current command
search path, and returns `file' values for each of the commands. It is
an error if a command is not found. 

Node: Subsection 8-2-2,	Next: Subsection 8-2-3,	Prev: Subsection 8-2-1,	Up: Section 8-2
  

8.2.2   where
=============

  The `where' function is similar to which, except it returns the list
of all the locations of the given executable (in the order in which the
corresponding directories appear in `$PATH'). In case a command is
handled internally by the `Shell' object, the first string in the output
will describe the command as a built-in function.
<<
      % where echo
      echo is a Shell object method (a built-in function)
      /bin/echo
>>

Node: Subsection 8-2-3,	Next: Subsection 8-2-4,	Prev: Subsection 8-2-2,	Up: Section 8-2
  

8.2.3   rehash
==============

<<
      rehash()
>>
  
  The `rehash' function resets all search paths. 

Node: Subsection 8-2-4,	Next: Subsection 8-2-5,	Prev: Subsection 8-2-3,	Up: Section 8-2
  

8.2.4   exists-in-path
======================

<<
     $(exists-in-path files) : String
        files : String Sequence
>>
  
  The `exists-in-path' function tests whether all executables are
present in the current search path. 

Node: Subsection 8-2-5,	Next: Subsection 8-2-6,	Prev: Subsection 8-2-4,	Up: Section 8-2
  

8.2.5   digest
==============

<<
       $(digest files) : String Array
          file : File Array
       raises RuntimeException
  
       $(digest-optional files) : String Array
          file : File Array
>>
  
  The `digest' and `digest-optional' functions compute MD5 digests of
files. The `digest' function raises an exception if a file does no
exist. The `digest-optional' returns `false' if a file does no exist.
MD5 digests are cached. 

Node: Subsection 8-2-6,	Next: Subsection 8-2-7,	Prev: Subsection 8-2-5,	Up: Section 8-2
  

8.2.6   find-in-path
====================

<<
      $(find-in-path path, files) : File Array
         path : Dir Array
         files : String Array
      raises RuntimeException
  
      $(find-in-path-optional path, files) : File Array
>>
  
  The `find-in-path' function searches for the files in a search path.
Only the tail of the filename is significant. The `find-in-path'
function raises an exception if the file can't be found. The
`find-in-path-optional' function silently removes files that can't be
found. 

Node: Subsection 8-2-7,	Next: Section 8-3,	Prev: Subsection 8-2-6,	Up: Section 8-2
  

8.2.7   digest-path
===================

<<
      $(digest-in-path path, files) : String/File Array
         path : Dir Array
         files : String Array
      raises RuntimeException
  
      $(digest-in-path-optional path, files) : String/File Array
>>
  
  The `digest-in-path' function searches for the files in a search path
and returns the file and digest for each file. Only the tail of the
filename is significant. The `digest-in-path' function raises an
exception if the file can't be found. The `digest-in-path-optional'
function silently removes elements that can't be found. 

Node: Section 8-3,	Next: Subsection 8-3-1,	Prev: Section 8-2,	Up: Chapter 8
  

8.3   File stats
*=*=*=*=*=*=*=*=

   
* Menu:

* Subsection 8-3-1::	file-exists
* Subsection 8-3-2::	target-exists
* Subsection 8-3-3::	target-is-proper
* Subsection 8-3-4::	stat-reset
* Subsection 8-3-5::	filter-exists
* Subsection 8-3-6::	filter-targets
* Subsection 8-3-7::	filter-proper-targets
* Subsection 8-3-8::	file-sort
* Subsection 8-3-9::	file-check-sort


Node: Subsection 8-3-1,	Next: Subsection 8-3-2,	Prev: Section 8-3,	Up: Section 8-3
  

8.3.1   file-exists
===================
 

Node: Subsection 8-3-2,	Next: Subsection 8-3-3,	Prev: Subsection 8-3-1,	Up: Section 8-3
  

8.3.2   target-exists
=====================
 

Node: Subsection 8-3-3,	Next: Subsection 8-3-4,	Prev: Subsection 8-3-2,	Up: Section 8-3
  

8.3.3   target-is-proper
========================

<<
     $(file-exists files) : String
     $(target-exists files) : String
     $(target-is-proper files) : String
         files : File Sequence
>>
  
  The `file-exists' function checks whether the files listed exist. The
`target-exists' function is similar to the `file-exists' function.
However, it returns true if the file exists or if it can be built by the
current project. The `target-is-proper' returns true only if the file
can be generated in the current project. 

Node: Subsection 8-3-4,	Next: Subsection 8-3-5,	Prev: Subsection 8-3-3,	Up: Section 8-3
  

8.3.4   stat-reset
==================

<<
     $(stat-reset files) : String
         files : File Sequence
>>
  
  OMake uses a stat-cache. The `stat-reset' function reset the `stat'
information for the given files, forcing the `stat' information to be
recomputed the next time it is requested. 

Node: Subsection 8-3-5,	Next: Subsection 8-3-6,	Prev: Subsection 8-3-4,	Up: Section 8-3
  

8.3.5   filter-exists
=====================
 

Node: Subsection 8-3-6,	Next: Subsection 8-3-7,	Prev: Subsection 8-3-5,	Up: Section 8-3
  

8.3.6   filter-targets
======================
 

Node: Subsection 8-3-7,	Next: Subsection 8-3-8,	Prev: Subsection 8-3-6,	Up: Section 8-3
  

8.3.7   filter-proper-targets
=============================

<<
     $(filter-exists files) : File Sequence
     $(filter-targets files) : File Sequence
     $(filter-proper-targets) : File Sequence
        files : File Sequence
>>
  
  The `filter-exists', `filter-targets', and `filter-proper-targets'
functions remove files from a list of files. 
  
 - `filter-exists': the result is the list of files that exist. 
 - `filter-targets': the result is the list of files either exist, or 
   can be built by the current project. 
 - `filter-proper-targets': the result is the list of files that can  be
   built in the current project. 
  
  One way to create a simple ``clean'' rule that removes generated files
from the project is by removing all files that can be built in the
current project. CAUTION: you should be careful before you do this. The
rule removes any file that can potentially be reconstructed. There is no
check to make sure that the commands to rebuild the file would actually
succeed. Also, note that no file outside the current project will be
deleted.
<<
      .PHONY: clean
  
      clean:
          rm $(filter-proper-targets $(ls R, .))
>>
  
  See the `dependencies-proper' function to see an alternate method for
removing intermediate files.
  If you use CVS, you may wish to use the `cvs_realclean' program that
is distributed with `omake'.

Node: Subsection 8-3-8,	Next: Subsection 8-3-9,	Prev: Subsection 8-3-7,	Up: Section 8-3
  

8.3.8   file-sort
=================

 
<<
     $(file-sort order, files) : File Sequence
        order : String
        files : File Sequence
>>
  
  The `file-sort' function sorts a list of filenames by build order
augmented by a set of sort rules. Sort rules are declared using the
`.ORDER' target. The `.BUILDORDER' defines the default order.
  `$(file-sort <order>, <files>)'
  For example, suppose we have the following set of rules.
<<
     a: b c
     b: d
     c: d
  
     .DEFAULT: a b c d
        echo $(file-sort .BUILDORDER, a b c d)
>>
  
  In the case, the sorter produces the result `d b c a'. That is, a
target is sorted after its dependencies. The sorter is frequently used
to sort files that are to be linked by their dependencies (for languages
where this matters).
  There are three important restrictions to the sorter: 
  
 - The sorter can be used only within a rule body. The reason for this
   is that all dependencies must be known before the sort is performed. 
 - The sorter can only sort files that are buildable in the current
   project. 
 - The sorter will fail if the dependencies are cyclic. 
  
  

 sort rule
----------
  
  It is possible to further constrain the sorter through the use of sort
rules. A sort rule is declared in two steps. The target must be listed
as an `.ORDER' target; and then a set of sort rules must be given. A
sort rule defines a pattern constraint.
<<
     .ORDER: .MYORDER
  
     .MYORDER: %.foo: %.bar
     .MYORDER: %.bar: %.baz
  
     .DEFAULT: a.foo b.bar c.baz d.baz
        echo $(sort .MYORDER, a.foo b.bar c.baz d.baz)
>>
  
  In this example, the `.MYORDER' sort rule specifies that any file with
a suffix `.foo' should be placed after any file with suffix `.bar', and
any file with suffix `.bar' should be placed after a file with suffix
`.baz'.
  In this example, the result of the sort is `d.baz c.baz b.bar a.foo'. 

Node: Subsection 8-3-9,	Next: Section 8-4,	Prev: Subsection 8-3-8,	Up: Section 8-3
  

8.3.9   file-check-sort
=======================

<<
     file-check-sort(files)
        files : File Sequence
     raises RuntimeException
>>
  
  The `file-check-sort' function checks whether a list of files is in
sort order. If so, the list is returned unchanged. If not, the function
raises an exception.
  `$(file-check-sort <order>, <files>)' 

Node: Section 8-4,	Next: Subsection 8-4-1,	Prev: Section 8-3,	Up: Chapter 8
  

8.4   Globbing and file listings
*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=

   
* Menu:

* Subsection 8-4-1::	glob
* Subsection 8-4-2::	ls
* Subsection 8-4-3::	subdirs


Node: Subsection 8-4-1,	Next: Subsection 8-4-2,	Prev: Section 8-4,	Up: Section 8-4
  

8.4.1   glob
============

<<
     $(glob strings) : Node Array
        strings : String Sequence
     $(glob options, strings) : Node Array
        options : String
        strings : String Sequence
>>
  
  The `glob' function performs glob-expansion.
  The . and .. entries are always ignored.
  The options are: 
  
 b  Do not perform csh(1)-style brace expansion. 
 e  The `\' character does not escape special characters. 
 n  If an expansion fails, return the expansion literally instead of
   aborting. 
 i  If an expansion fails, it expands to nothing. 
 .  Allow wildcard patterns to match files beginning with a . 
 A  Return all files, including files that begin with a . 
 D  Match only directory files. 
 C  Ignore files according to cvs(1) rules. 
 P  Include only proper subdirectories. 
  
  In addition, the following variables may be defined that affect the
behavior of `glob'.
  
  
 GLOB_OPTIONS  A string containing default options. 
 GLOB_IGNORE  A list of shell patterns for filenames that `glob' should
   ignore. 
 GLOB_ALLOW  A list of shell patterns. If a file does not match a
   pattern in  `GLOB_ALLOW', it is ignored. 
  
  The returned files are sorted by name. 

Node: Subsection 8-4-2,	Next: Subsection 8-4-3,	Prev: Subsection 8-4-1,	Up: Section 8-4
  

8.4.2   ls
==========

<<
     $(ls files) : Node Array
        files : String Sequence
     $(ls options, files) : Node Array
        files : String Sequence
>>
  
  The `ls' function returns the filenames in a directory.
  The . and .. entries are always ignored. The patterns are shell-style
patterns, and are glob-expanded.
  The options include all of the options to the `glob' function, plus
the following.
  
  
 R  Perform a recursive listing. 
  
  The `GLOB_ALLOW' and `GLOB_IGNORE' variables can be defined to control
the globbing behavior. The returned files are sorted by name. 

Node: Subsection 8-4-3,	Next: Section 8-5,	Prev: Subsection 8-4-2,	Up: Section 8-4
  

8.4.3   subdirs
===============

<<
     $(subdirs dirs) : Dir Array
        dirs : String Sequence
     $(subdirs options, dirs) : Dir Array
        options : String
        dirs : String Sequence
>>
  
  The `subdirs' function returns all the subdirectories of a list of
directories, recursively.
  The possible options are the following: 
  
 A  Return directories that begin with a . 
 C  Ignore files according to .cvsignore rules. 
 P  Include only proper subdirectories. 
   

Node: Section 8-5,	Next: Subsection 8-5-1,	Prev: Section 8-4,	Up: Chapter 8
  

8.5   Filesystem operations
*=*=*=*=*=*=*=*=*=*=*=*=*=*

   
* Menu:

* Subsection 8-5-1::	mkdir
* Subsection 8-5-2::	Stat
* Subsection 8-5-3::	stat
* Subsection 8-5-4::	unlink
* Subsection 8-5-5::	rename
* Subsection 8-5-6::	link
* Subsection 8-5-7::	symlink
* Subsection 8-5-8::	readlink
* Subsection 8-5-9::	chmod
* Subsection 8-5-10::	chown
* Subsection 8-5-11::	umask


Node: Subsection 8-5-1,	Next: Subsection 8-5-2,	Prev: Section 8-5,	Up: Section 8-5
  

8.5.1   mkdir
=============

<<
     mkdir(mode, node...)
        mode : Int
        node : Node
     raises RuntimeException
  
     mkdir(node...)
        node : Node
     raises RuntimeException
>>
  
  The `mkdir' function creates a directory, or a set of directories. The
following options are supported. 
  
 -m mode  Specify the permissions of the created directory. 
 -p  Create parent directories if they do not exist. 
 --  Interpret the remaining names literally. 
   

Node: Subsection 8-5-2,	Next: Subsection 8-5-3,	Prev: Subsection 8-5-1,	Up: Section 8-5
  

8.5.2   Stat
============

  The `Stat' object represents the result returned by the `stat' and
`lstat' functions. It contains the following fields.
  A `stat' object has the following fields. Not all of the fields will
have meaning on all architectures.
  
  
 dev : the device number. 
 ino : the inode number. 
 kind : the kind of the file, one of the following:  `REG' (regular
   file),  `DIR' (directory),  `CHR' (character device),  `BLK' (block
   device),  `LNK' (symbolic link),  `FIFO' (named pipe),  `SOCK'
   (socket). 
 perm : access rights, represented as an integer. 
 nlink : number of links. 
 uid : user id of the owner. 
 gid : group id of the file's group. 
 rdev : device minor number. 
 size : size in bytes. 
 atime : last access time, as a floating point number. 
 mtime : last modification time, as a floating point number. 
 ctime : last status change time, as a floating point number. 
  

Node: Subsection 8-5-3,	Next: Subsection 8-5-4,	Prev: Subsection 8-5-2,	Up: Section 8-5
  

8.5.3   stat
============

<<
      $(stat node...) : Stat
         node : Node or Channel
      $(lstat node...) : Stat
         node : Node or Channel
      raises RuntimeException
>>
  
  The `stat' functions return file information. If the file is a
symbolic link, the `stat' function refers to the destination of the
link; the `lstat' function refers to the link itself. 

Node: Subsection 8-5-4,	Next: Subsection 8-5-5,	Prev: Subsection 8-5-3,	Up: Section 8-5
  

8.5.4   unlink
==============

<<
     $(unlink file...)
        file : File
     #(rm file...)
        file : File
     $(rmdir dir...)
        dir : Dir
     raises RuntimeException
>>
  
  The `unlink' and `rm' functions remove a file. The `rmdir' function
removes a directory.
  The following options are supported for `rm' and `rmdir'. 
  
 -f  ignore nonexistent files, never prompt. 
 -i  prompt before removal. 
 -r  remove the contents of directories recursively. 
 -v  explain what is going on. 
 --  the rest of the values are interpreted literally. 
   

Node: Subsection 8-5-5,	Next: Subsection 8-5-6,	Prev: Subsection 8-5-4,	Up: Section 8-5
  

8.5.5   rename
==============

<<
      rename(old, new)
         old : Node
         new : Node
      mv(nodes... dir)
         nodes : Node Sequence
         dir   : Dir
      cp(nodes... dir)
         nodes : Node Sequence
         dir   : Dir
      raises RuntimeException
>>
  
  The `rename' function changes the name of a file or directory named
`old' to `new'.
  The `mv' function is similar, but if `new' is a directory, and it
exists, then the files specified by the sequence are moved into the
directory. If not, the behavior of `mv' is identical to `rename'. The
`cp' function is similar, but the original file is not removed.
  The `mv' and `cp' functions take the following options. 
  
 -f  Do not prompt before overwriting. 
 -i  Prompt before overwriting. 
 -v  Explain what it happening. 
 -r  Copy the contents of directories recursively. 
 --  Interpret the remaining arguments literally. 
   

Node: Subsection 8-5-6,	Next: Subsection 8-5-7,	Prev: Subsection 8-5-5,	Up: Section 8-5
  

8.5.6   link
============

<<
     link(src, dst)
        src : Node
        dst : Node
     raises RuntimeException
>>
  
  The `link' function creates a hard link named `dst' to the file or
directory `src'.
  Hard links are not supported in Win32.
  Normally, only the superuser can create hard links to directories. 

Node: Subsection 8-5-7,	Next: Subsection 8-5-8,	Prev: Subsection 8-5-6,	Up: Section 8-5
  

8.5.7   symlink
===============

<<
     symlink(src, dst)
        src : Node
        dst : Node
     raises RuntimeException
>>
  
  The `symlink' function creates a symbolic link `dst' that points to
the `src' file.
  The link name is computed relative to the target directory. For
example, the expression `$(symlink a/b, c/d)' creates a link named `c/d
-> ../a/b'.
  Symbolic links are not supported in Win32. 

Node: Subsection 8-5-8,	Next: Subsection 8-5-9,	Prev: Subsection 8-5-7,	Up: Section 8-5
  

8.5.8   readlink
================

<<
     $(readlink node...) : Node
        node : Node
>>
  
  The `readlink' function reads the value of a symbolic link. 

Node: Subsection 8-5-9,	Next: Subsection 8-5-10,	Prev: Subsection 8-5-8,	Up: Section 8-5
  

8.5.9   chmod
=============

<<
     chmod(mode, dst...)
        mode : Int
        dst : Node or Channel
     chmod(mode dst...)
        mode : String
        dst : Node Sequence
     raises RuntimeException
>>
  
  The `chmod' function changes the permissions of the targets. The
`chmod' function does nothing on Win32 platforms.
  Options: 
  
 -v  Explain what is happening. 
 -r  Change files and directories recursively. 
 -f  Continue on errors. 
 --  Interpret the remaining argument literally. 
   

Node: Subsection 8-5-10,	Next: Subsection 8-5-11,	Prev: Subsection 8-5-9,	Up: Section 8-5
  

8.5.10   chown
==============

<<
     chown(uid, gid, node...)
        uid : Int
        gid : Int
        node : Node or Channel
     chown(uid, node...)
        uid : Int
        node : Node or Channel
     raises RuntimeException
>>
  
  The `chown' function changes the user and group id of the file. If the
`gid' is not specified, it is not changed. If either id is -1, that id
is not changed. 

Node: Subsection 8-5-11,	Next: Section 8-6,	Prev: Subsection 8-5-10,	Up: Section 8-5
  

8.5.11   umask
==============

<<
      $(umask mode) : Int
         mode : Int
      raises RuntimeException
>>
  
  Sets the file mode creation mask. The previous mask is returned. This
value is not scoped, changes have global effect. 

Node: Section 8-6,	Next: Subsection 8-6-1,	Prev: Section 8-5,	Up: Chapter 8
  

8.6   vmount
*=*=*=*=*=*=

   
* Menu:

* Subsection 8-6-1::	vmount
* Subsection 8-6-2::	add-project-directories
* Subsection 8-6-3::	remove-project-directories


Node: Subsection 8-6-1,	Next: Subsection 8-6-2,	Prev: Section 8-6,	Up: Section 8-6
  

8.6.1   vmount
==============

<<
      vmount(src, dst)
         src, dst : Dir
      vmount(flags, src, dst)
         flags : String
         src, dst : Dir
>>
  
  ``Mount'' the `src' directory on the `dst' directory. This is a
virtual mount, changing the behavior of the `$(file ...)' function. When
the `$(file str)' function is used, the resulting file is taken relative
to the `src' directory if the file exists. Otherwise, the file is
relative to the current directory.
  The main purpose of the `vmount' function is to support multiple
builds with separate configurations or architectures.
  The options are as follows. 
  
 l  Create symbolic links to files in the `src' directory. 
 c  Copy files from the `src' directory. 
  
  Mount operations are scoped. 

Node: Subsection 8-6-2,	Next: Subsection 8-6-3,	Prev: Subsection 8-6-1,	Up: Section 8-6
  

8.6.2   add-project-directories
===============================

<<
      add-project-directories(dirs)
         dirs : Dir Array
>>
  
  Add the directories to the set of directories that omake considers to
be part of the project. This is mainly used to avoid omake complaining
that the current directory is not part of the project. 

Node: Subsection 8-6-3,	Next: Section 8-7,	Prev: Subsection 8-6-2,	Up: Section 8-6
  

8.6.3   remove-project-directories
==================================

<<
      remove-project-directories(dirs)
         dirs : Dir Array
>>
  
  Removed the directories from the set of directories that omake
considers to be part of the project. This is mainly used to cancel a
`.SUBDIRS' from including a directory if it is determined that the
directory does not need to be compiled. 

Node: Section 8-7,	Next: Subsection 8-7-1,	Prev: Section 8-6,	Up: Chapter 8
  

8.7   File predicates
*=*=*=*=*=*=*=*=*=*=*

   
* Menu:

* Subsection 8-7-1::	test
* Subsection 8-7-2::	find


Node: Subsection 8-7-1,	Next: Subsection 8-7-2,	Prev: Section 8-7,	Up: Section 8-7
  

8.7.1   test
============

<<
     test(exp) : Bool
        exp : String Sequence
>>
  
  The expression grammar is as follows:
  
  
 - `!' expression : expression is not true 
 - expression1 `-a' expression2 : both expressions are true 
 - expression1 `-o' expression2 : at least one expression is true 
 - `(' expression `)' : expression is true 
  
  The base expressions are:
  
  
 - `-n' string : The string has nonzero length 
 - `-z' string : The string has zero length 
 - string `=' string : The strings are equal 
 - string `!=' string : The strings are not equal
 
 - int1 `-eq' int2 : The integers are equal 
 - int1 `-ne' int2 : The integers are not equal 
 - int1 `-gt' int2 : int1 is larger than int2 
 - int1 `-ge' int2 : int2 is not larger than int1 
 - int1 `-lt' int2 : int1 is smaller than int2 
 - int1 `-le' int2 : int1 is not larger than int2
 
 - file1 `-ef' file2 : On Unix, file1 and file2 have the  same device
   and inode number.  On Win32, file1 and file2 have the  same name. 
 - file1 `-nt' file2 : file1 is newer than file2 
 - file1 `-ot' file2 : file1 is older than file2
 
 - `-b' file : The file is a block special file 
 - `-c' file : The file is a character special file 
 - `-d' file : The file is a directory 
 - `-e' file : The file exists 
 - `-f' file : The file is a normal file 
 - `-g' file : The set`-group'`-id' bit is set on the file 
 - `-G' file : The file's group is the current effective group 
 - `-h' file : The file is a symbolic link (also `-L') 
 - `-k' file : The file's sticky bit is set 
 - `-L' file : The file is a symbolic link (also `-h') 
 - `-O' file : The file's owner is the current effective user 
 - `-p' file : The file is a named pipe 
 - `-r' file : The file is readable 
 - `-s' file : The file is empty 
 - `-S' file : The file is a socket 
 - `-u' file : The set`-user'`-id' bit is set on the file 
 - `-w' file : The file is writable 
 - `-x' file : The file is executable 
  
  A string is any sequence of characters; leading `-' characters are
allowed.
  An int is a string that can be interpreted as an integer. Unlike
traditional versions of the test program, the leading characters may
specify an arity. The prefix `0b' means the numbers is in binary; the
prefix `0o' means the number is in octal; the prefix `0x' means the
number is in hexadecimal. An int can also be specified as `-l' string,
which evaluates to the length of the string.
  A file is a string that represents the name of a file.
  The syntax mirrors that of the test(1) program. If you are on a Unix
system, the man page explains more. Here are some examples.
<<
      # Create an empty file
      osh> touch foo
      # Is the file empty?
      osh> test(-e foo)
      - : true
      osh> test(! -e foo)
      - : false
      # Create another file
      osh> touch boo
      # Is the newer file newer?
      osh> test(boo -nt foo)
      - : true
      # A more complex query
      # boo is newer than foo, and foo is empty
      osh> test(\( boo -nt foo \) -a -e foo)
      - : true
>>

Node: Subsection 8-7-2,	Next: Section 8-8,	Prev: Subsection 8-7-1,	Up: Section 8-7
  

8.7.2   find
============

<<
     find(exp) : Node Array
        exp : String Sequence
>>
  
  The `find' function searches a directory recursively, returning the
files for which the expression evaluates to true.
  The expression argument uses the same syntax as the `test' function,
with the following exceptions.
  
  
 1. The expression may begin with a directory. If not specified, the
   current  directory is searched. 
 2. The `{}' string expands to the current file being examined. 
  
  The syntax of the expression is the same as `test', with the following
additions.
  
  
 - `-name' string : The current file matches the regular expression. 
  
  The `find' function performs a recursive scan of all subdirectories.
The following call is being run from the root of the `omake' source
directory.
<<
      osh> find(. -name fo* )
      - : <array
              /home/jyh/.../omake/mk/.svn/format
              /home/jyh/.../omake/RPM/.svn/format
              ...
             
/home/jyh/.../omake/osx_resources/installer_files/.svn/format>
>>
  
  Another example, listing only those files that are normal files or
symbolic links.
<<
      osh> find(. -name fo* -a \( -f {} -o -L {} \))
      - : <array
              /home/jyh/.../omake/mk/.svn/format
              /home/jyh/.../omake/RPM/.svn/format
              ...
             
/home/jyh/.../omake/osx_resources/installer_files/.svn/format>
>>
   

Node: Section 8-8,	Next: Subsection 8-8-1,	Prev: Section 8-7,	Up: Chapter 8
  

8.8   IO functions
*=*=*=*=*=*=*=*=*=

   
* Menu:

* Subsection 8-8-1::	Standard channels
* Subsection 8-8-2::	stdin
* Subsection 8-8-3::	stdout
* Subsection 8-8-4::	stderr
* Subsection 8-8-5::	fopen
* Subsection 8-8-6::	close
* Subsection 8-8-7::	read
* Subsection 8-8-8::	write
* Subsection 8-8-9::	lseek
* Subsection 8-8-10::	rewind
* Subsection 8-8-11::	tell
* Subsection 8-8-12::	flush
* Subsection 8-8-13::	dup
* Subsection 8-8-14::	dup2
* Subsection 8-8-15::	set-nonblock
* Subsection 8-8-16::	set-close-on-exec-mode
* Subsection 8-8-17::	pipe
* Subsection 8-8-18::	mkfifo
* Subsection 8-8-19::	select
* Subsection 8-8-20::	lockf
* Subsection 8-8-21::	InetAddr
* Subsection 8-8-22::	Host
* Subsection 8-8-23::	gethostbyname
* Subsection 8-8-24::	Protocol
* Subsection 8-8-25::	getprotobyname
* Subsection 8-8-26::	Service
* Subsection 8-8-27::	getservbyname
* Subsection 8-8-28::	socket
* Subsection 8-8-29::	bind
* Subsection 8-8-30::	listen
* Subsection 8-8-31::	accept
* Subsection 8-8-32::	connect
* Subsection 8-8-33::	getchar
* Subsection 8-8-34::	gets
* Subsection 8-8-35::	fgets


Node: Subsection 8-8-1,	Next: Subsection 8-8-2,	Prev: Section 8-8,	Up: Section 8-8
  

8.8.1   Standard channels
=========================
  
  The following variables define the standard channels.

Node: Subsection 8-8-2,	Next: Subsection 8-8-3,	Prev: Subsection 8-8-1,	Up: Section 8-8
  

8.8.2   stdin
=============

<<
  stdin : InChannel
>>
  
  The standard input channel, open for reading.

Node: Subsection 8-8-3,	Next: Subsection 8-8-4,	Prev: Subsection 8-8-2,	Up: Section 8-8
  

8.8.3   stdout
==============
 
<<
  stdout : OutChannel
>>
  
  The standard output channel, open for writing.

Node: Subsection 8-8-4,	Next: Subsection 8-8-5,	Prev: Subsection 8-8-3,	Up: Section 8-8
  

8.8.4   stderr
==============
 
<<
  stderr : OutChannel
>>
  
  The standard error channel, open for writing. 

Node: Subsection 8-8-5,	Next: Subsection 8-8-6,	Prev: Subsection 8-8-4,	Up: Section 8-8
  

8.8.5   fopen
=============

  The `fopen' function opens a file for reading or writing.
<<
     $(fopen file, mode) : Channel
        file : File
        mode : String
>>
  
  The `file' is the name of the file to be opened. The `mode' is a
combination of the following characters. 
  
 r  Open the file for reading; it is an error if the file does not
   exist. 
 w  Open the file for writing; the file is created if it does not exist.
   
 a  Open the file in append mode; the file is created if it does not
   exist. 
 +  Open the file for both reading an writing. 
 t  Open the file in text mode (default). 
 b  Open the file in binary mode. 
 n  Open the file in nonblocking mode. 
 x  Fail if the file already exists. 
  
  Binary mode is not significant on Unix systems, where text and binary
modes are equivalent. 

Node: Subsection 8-8-6,	Next: Subsection 8-8-7,	Prev: Subsection 8-8-5,	Up: Section 8-8
  

8.8.6   close
=============

<<
      $(close channel...)
         channel : Channel
>>
  
  The `close' function closes a file that was previously opened with
`fopen'. 

Node: Subsection 8-8-7,	Next: Subsection 8-8-8,	Prev: Subsection 8-8-6,	Up: Section 8-8
  

8.8.7   read
============

<<
     $(read channel, amount) : String
        channel : InChannel
        amount  : Int
     raises RuntimeException
>>
  
  The `read' function reads up to `amount' bytes from an input channel,
and returns the data that was read. If an end-of-file condition is
reached, the function raises a `RuntimeException' exception. 

Node: Subsection 8-8-8,	Next: Subsection 8-8-9,	Prev: Subsection 8-8-7,	Up: Section 8-8
  

8.8.8   write
=============

<<
     $(write channel, buffer, offset, amount) : String
        channel : OutChannel
        buffer  : String
        offset  : Int
        amount  : Int
     $(write channel, buffer) : String
        channel : OutChannel
        buffer  : String
     raises RuntimeException
>>
  
  In the 4-argument form, the `write' function writes bytes to the
output channel `channel' from the `buffer', starting at position
`offset'. Up to `amount' bytes are written. The function returns the
number of bytes that were written.
  The 3-argument form is similar, but the `offset' is 0.
  In the 2-argument form, the `offset' is 0, and the `amount' if the
length of the `buffer'.
  If an end-of-file condition is reached, the function raises a
`RuntimeException' exception. 

Node: Subsection 8-8-9,	Next: Subsection 8-8-10,	Prev: Subsection 8-8-8,	Up: Section 8-8
  

8.8.9   lseek
=============

<<
      $(lseek channel, offset, whence) : Int
         channel : Channel
         offset  : Int
         whence  : String
      raises RuntimeException
>>
  
  The `lseek' function repositions the offset of the channel `channel'
according to the `whence' directive, as follows:
  
  
 SEEK_SET  The offset is set to `offset'. 
 SEEK_CUR  The offset is set to its current position plus `offset'
   bytes. 
 SEEK_END  The offset is set to the size of the file plus `offset'
   bytes. 
  
  The `lseek' function returns the new position in the file. 

Node: Subsection 8-8-10,	Next: Subsection 8-8-11,	Prev: Subsection 8-8-9,	Up: Section 8-8
  

8.8.10   rewind
===============

<<
     rewind(channel...)
        channel : Channel
>>
  
  The `rewind' function set the current file position to the beginning
of the file. 

Node: Subsection 8-8-11,	Next: Subsection 8-8-12,	Prev: Subsection 8-8-10,	Up: Section 8-8
  

8.8.11   tell
=============

<<
      $(tell channel...) : Int...
         channel : Channel
      raises RuntimeException
>>
  
  The `tell' function returns the current position of the `channel'. 

Node: Subsection 8-8-12,	Next: Subsection 8-8-13,	Prev: Subsection 8-8-11,	Up: Section 8-8
  

8.8.12   flush
==============

<<
     $(flush channel...)
        channel : OutChannel
>>
  
  The `flush' function can be used only on files that are open for
writing. It flushes all pending data to the file. 

Node: Subsection 8-8-13,	Next: Subsection 8-8-14,	Prev: Subsection 8-8-12,	Up: Section 8-8
  

8.8.13   dup
============

<<
      $(dup channel) : Channel
         channel : Channel
      raises RuntimeException
>>
  
  The `dup' function returns a new channel referencing the same file as
the argument. 

Node: Subsection 8-8-14,	Next: Subsection 8-8-15,	Prev: Subsection 8-8-13,	Up: Section 8-8
  

8.8.14   dup2
=============

<<
     dup2(channel1, channel2)
        channel1 : Channel
        channel2 : Channel
     raises RuntimeException
>>
  
  The `dup2' function causes `channel2' to refer to the same file as
`channel1'. 

Node: Subsection 8-8-15,	Next: Subsection 8-8-16,	Prev: Subsection 8-8-14,	Up: Section 8-8
  

8.8.15   set-nonblock
=====================

<<
     set-nonblock-mode(mode, channel...)
        channel : Channel
        mode : String
>>
  
  The `set-nonblock-mode' function sets the nonblocking flag on the
given channel. When IO is performed on the channel, and the operation
cannot be completed immediately, the operations raises a
`RuntimeException'. 

Node: Subsection 8-8-16,	Next: Subsection 8-8-17,	Prev: Subsection 8-8-15,	Up: Section 8-8
  

8.8.16   set-close-on-exec-mode
===============================

<<
     set-close-on-exec-mode(mode, channel...)
        channel : Channel
        mode : String
     raises RuntimeException
>>
  
  The `set-close-on-exec-mode' function sets the close-on-exec flags for
the given channels. If the close-on-exec flag is set, the channel is not
inherited by child processes. Otherwise it is. 

Node: Subsection 8-8-17,	Next: Subsection 8-8-18,	Prev: Subsection 8-8-16,	Up: Section 8-8
  

8.8.17   pipe
=============

<<
     $(pipe) : Pipe
     raises RuntimeException
>>
  
  The `pipe' function creates a `Pipe' object, which has two fields. The
`read' field is a channel that is opened for reading, and the `write'
field is a channel that is opened for writing. 

Node: Subsection 8-8-18,	Next: Subsection 8-8-19,	Prev: Subsection 8-8-17,	Up: Section 8-8
  

8.8.18   mkfifo
===============

<<
     mkfifo(mode, node...)
        mode : Int
        node : Node
>>
  
  The `mkfifo' function creates a named pipe. 

Node: Subsection 8-8-19,	Next: Subsection 8-8-20,	Prev: Subsection 8-8-18,	Up: Section 8-8
  

8.8.19   select
===============

<<
     $(select rfd..., wfd..., wfd..., timeout) : Select
        rfd : InChannel
        wfd : OutChannel
        efd : Channel
        timeout : float
     raises RuntimeException
>>
  
  The `select' function polls for possible IO on a set of channels. The
`rfd' are a sequence of channels for reading, `wfd' are a sequence of
channels for writing, and `efd' are a sequence of channels to poll for
error conditions. The `timeout' specifies the maximum amount of time to
wait for events.
  On successful return, `select' returns a `Select' object, which has
the following fields: 
  
 read  An array of channels available for reading. 
 write  An array of channels available for writing. 
 error  An array of channels on which an error has occurred. 
   

Node: Subsection 8-8-20,	Next: Subsection 8-8-21,	Prev: Subsection 8-8-19,	Up: Section 8-8
  

8.8.20   lockf
==============

<<
      lockf(channel, command, len)
         channel : Channel
         command : String
         len : Int
      raises RuntimeException
>>
  
  The `lockf' function places a lock on a region of the channel. The
region starts at the current position and extends for `len' bytes.
  The possible values for `command' are the following. 
  
 F_ULOCK  Unlock a region. 
 F_LOCK  Lock a region for writing; block if already locked. 
 F_TLOCK  Lock a region for writing; fail if already locked. 
 F_TEST  Test a region for other locks. 
 F_RLOCK  Lock a region for reading; block if already locked. 
 F_TRLOCK  Lock a region for reading; fail is already locked. 
   

Node: Subsection 8-8-21,	Next: Subsection 8-8-22,	Prev: Subsection 8-8-20,	Up: Section 8-8
  

8.8.21   InetAddr
=================

  The `InetAddr' object describes an Internet address. It contains the
following fields.
  
  
 addr  `String': the Internet address. 
 port  `Int': the port number. 
  

Node: Subsection 8-8-22,	Next: Subsection 8-8-23,	Prev: Subsection 8-8-21,	Up: Section 8-8
  

8.8.22   Host
=============

  A `Host' object contains the following fields.
  
  
 name  `String': the name of the host. 
 aliases  `String Array': other names by which the host is known. 
 addrtype  `String': the preferred socket domain. 
 addrs  `InetAddr Array': an array of Internet addresses belonging to
   the host. 
  

Node: Subsection 8-8-23,	Next: Subsection 8-8-24,	Prev: Subsection 8-8-22,	Up: Section 8-8
  

8.8.23   gethostbyname
======================

<<
     $(gethostbyname host...) : Host...
        host : String
     raises RuntimeException
>>
  
  The `gethostbyname' function returns a `Host' object for the specified
host. The `host' may specify a domain name or an Internet address.

Node: Subsection 8-8-24,	Next: Subsection 8-8-25,	Prev: Subsection 8-8-23,	Up: Section 8-8
  

8.8.24   Protocol
=================

  The `Protocol' object represents a protocol entry. It has the
following fields.
  
  
 name  `String': the canonical name of the protocol. 
 aliases  `String Array': aliases for the protocol. 
 proto  `Int': the protocol number. 
  

Node: Subsection 8-8-25,	Next: Subsection 8-8-26,	Prev: Subsection 8-8-24,	Up: Section 8-8
  

8.8.25   getprotobyname
=======================

<<
     $(getprotobyname name...) : Protocol...
        name : Int or String
     raises RuntimeException
>>
  
  The `getprotobyname' function returns a `Protocol' object for the
specified protocol. The `name' may be a protocol name, or a protocol
number. 

Node: Subsection 8-8-26,	Next: Subsection 8-8-27,	Prev: Subsection 8-8-25,	Up: Section 8-8
  

8.8.26   Service
================

  The `Service' object represents a network service. It has the
following fields.
  
  
 name  `String': the name of the service. 
 aliases  `String Array': aliases for the service. 
 port  `Int': the port number of the service. 
 proto  `Protocol': the protocol for the service. 
  

Node: Subsection 8-8-27,	Next: Subsection 8-8-28,	Prev: Subsection 8-8-26,	Up: Section 8-8
  

8.8.27   getservbyname
======================

<<
     $(getservbyname service...) : Service...
        service : String or Int
     raises RuntimeException
>>
  
  The `getservbyname' function gets the information for a network
service. The `service' may be specified as a service name or number. 

Node: Subsection 8-8-28,	Next: Subsection 8-8-29,	Prev: Subsection 8-8-27,	Up: Section 8-8
  

8.8.28   socket
===============

<<
     $(socket domain, type, protocol) : Channel
        domain : String
        type : String
        protocol : String
     raises RuntimeException
>>
  
  The `socket' function creates an unbound socket.
  The possible values for the arguments are as follows.
  The `domain' may have the following values. 
  
 PF_UNIX or unix  Unix domain, available only on Unix systems. 
 PF_INET or inet  Internet domain, IPv4. 
 PF_INET6 or inet6  Internet domain, IPv6. 
  
  The `type' may have the following values. 
  
 SOCK_STREAM or stream  Stream socket. 
 SOCK_DGRAM or dgram  Datagram socket. 
 SOCK_RAW or raw  Raw socket. 
 SOCK_SEQPACKET or seqpacket  Sequenced packets socket 
  
  The `protocol' is an `Int' or `String' that specifies a protocol in
the protocols database. 

Node: Subsection 8-8-29,	Next: Subsection 8-8-30,	Prev: Subsection 8-8-28,	Up: Section 8-8
  

8.8.29   bind
=============

<<
     bind(socket, host, port)
        socket : InOutChannel
        host : String
        port : Int
     bind(socket, file)
        socket : InOutChannel
        file : File
     raise RuntimeException
>>
  
  The `bind' function binds a socket to an address.
  The 3-argument form specifies an Internet connection, the `host'
specifies a host name or IP address, and the `port' is a port number.
  The 2-argument form is for `Unix' sockets. The `file' specifies the
filename for the address. 

Node: Subsection 8-8-30,	Next: Subsection 8-8-31,	Prev: Subsection 8-8-29,	Up: Section 8-8
  

8.8.30   listen
===============

<<
     listen(socket, requests)
        socket : InOutChannel
        requests : Int
     raises RuntimeException
>>
  
  The `listen' function sets up the socket for receiving up to
`requests' number of pending connection requests. 

Node: Subsection 8-8-31,	Next: Subsection 8-8-32,	Prev: Subsection 8-8-30,	Up: Section 8-8
  

8.8.31   accept
===============

<<
     $(accept socket) : InOutChannel
        socket : InOutChannel
     raises RuntimeException
>>
  
  The `accept' function accepts a connection on a socket. 

Node: Subsection 8-8-32,	Next: Subsection 8-8-33,	Prev: Subsection 8-8-31,	Up: Section 8-8
  

8.8.32   connect
================

<<
      connect(socket, addr, port)
         socket : InOutChannel
         addr : String
         port : int
      connect(socket, name)
         socket : InOutChannel
         name : File
      raise RuntimeException
>>
  
  The `connect' function connects a socket to a remote address.
  The 3-argument form specifies an Internet connection. The `addr'
argument is the Internet address of the remote host, specified as a
domain name or IP address. The `port' argument is the port number.
  The 2-argument form is for Unix sockets. The `name' argument is the
filename of the socket. 

Node: Subsection 8-8-33,	Next: Subsection 8-8-34,	Prev: Subsection 8-8-32,	Up: Section 8-8
  

8.8.33   getchar
================

<<
      $(getc) : String
      $(getc file) : String
         file : InChannel or File
      raises RuntimeException
>>
  
  The `getc' function returns the next character of a file. If the
argument is not specified, `stdin' is used as input. If the end of file
has been reached, the function returns `false'. 
