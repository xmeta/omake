This file has been translated from LaTeX by HeVeA.

Node: Chapter 11,	Next: Section 11-1,	Prev: Chapter 10,	Up: Top
  

Chapter 11     Build functions
******************************
     
* Menu:

* Section 11-1::	OMakeFlags
* Section 11-2::	OMakeVersion
* Section 11-3::	cmp-versions
* Section 11-4::	DefineCommandVars
* Section 11-5::	The OMakeroot file
* Section 11-6::	Building C programs
* Section 11-7::	Building OCaml programs
* Section 11-8::	Building LaTeX programs
* Section 11-9::	Examining the dependency graph


Node: Section 11-1,	Next: Section 11-2,	Prev: Chapter 11,	Up: Chapter 11
  

11.1   OMakeFlags
*=*=*=*=*=*=*=*=*

  
<<
     OMakeFlags(options)
        options : String
>>
  
  The `OMakeFlags' function is used to set `omake' options from within
OMakefiles. The options have exactly the same format as options on the
command line.
  For example, the following code displays the progress bar unless the
`VERBOSE' environment variable is defined.
<<
      if $(not $(defined-env VERBOSE))
          OMakeFlags(-S --progress)
          export
>>

Node: Section 11-2,	Next: Section 11-3,	Prev: Section 11-1,	Up: Chapter 11
  

11.2   OMakeVersion
*=*=*=*=*=*=*=*=*=*

  
<<
     OMakeVersion(version1)
     OMakeVersion(version1, version2)
        version1, version2 : String
>>
  
  The `OMakeVersion' function is used for version checking in
OMakefiles. It takes one or two arguments.
  In the one argument form, if the omake version number is less than
`<version1>', then an exception is raised. In the two argument form, the
version must lie between `version1' and `version2'.

Node: Section 11-3,	Next: Section 11-4,	Prev: Section 11-2,	Up: Chapter 11
  

11.3   cmp-versions
*=*=*=*=*=*=*=*=*=*

   
<<
     $(cmp-versions version1, version2)
        version1, version2 : String
>>
  
  The `cmp-versions\' functions can be used to compare arbitrary version
strings. It returns 0 when the two version strings are equal, a negative
number when the first string represents an earlier version, and a
positive number otherwise. 

Node: Section 11-4,	Next: Section 11-5,	Prev: Section 11-3,	Up: Chapter 11
  

11.4   DefineCommandVars
*=*=*=*=*=*=*=*=*=*=*=*=

  
<<
     DefineCommandVars()
>>
  
  The `DefineCommandVars' function redefines the variables passed on the
commandline. Variables definitions are passed on the command line in the
form `name=value'. This function is primarily for internal use by omake
to define these variables for the first time. 

Node: Section 11-5,	Next: Subsection 11-5-1,	Prev: Section 11-4,	Up: Chapter 11
  

11.5   The OMakeroot file
*=*=*=*=*=*=*=*=*=*=*=*=*

   
  The standard OMakeroot file defines the functions are rules for
building standard projects.
* Menu:

* Subsection 11-5-1::	Variables
* Subsection 11-5-2::	System variables


Node: Subsection 11-5-1,	Next: Subsection 11-5-2,	Prev: Section 11-5,	Up: Section 11-5
  

11.5.1   Variables
==================


 ROOT
-----
 The root directory of
the current project.

 CWD
----
 The current working
directory (the directory is set for each OMakefile in the project).

 EMPTY
------
 The empty string.

 STDROOT
--------
 The name of the
standard installed OMakeroot file.

 VERBOSE
--------
 Whether certain
commands should be verbose (`false' by default).

 ABORT_ON_COMMAND_ERROR
-----------------------
 If
set to true, the construction of a target should  be aborted whenever
one of the commands to build it fail. This defaults to true,  and should
normally be left that way.
  

 SCANNER_MODE
-------------
 This variable
should be defined as one of four values  (defaults to `enabled'). 
  
 enabled  Allow the use of default `.SCANNER' rules. Whenever a rule
   does  not specify a `:scanner:' dependency explicitly, try to find a 
   `.SCANNER' with the same target name. 
 disabled  Never use default `.SCANNER' rules. 
 warning  Allow the use of default `.SCANNER' rules, but print a warning
    whenever one is selected. 
 error  Do not allow the use of default `.SCANNER' rules. If a rule 
   does not specify a `:scanner:' dependency, and there is a default 
   `.SCANNER' rule, the build will terminate abnormally. 
   

Node: Subsection 11-5-2,	Next: Section 11-6,	Prev: Subsection 11-5-1,	Up: Section 11-5
  

11.5.2   System variables
=========================
  
  

 INSTALL
--------
 The command to
install a program (`install' on `Unix', `cp' on `Win32').

 PATHSEP
--------
 The normal path
separator (`:' on `Unix', `;' on `Win32').

 DIRSEP
-------
 The normal directory
separator (`/' on `Unix', `\' on `Win32').

 EXT_LIB
--------
 File suffix for a
static library (default is `.a' on `Unix', and `.lib' on `Win32').

 EXT_OBJ
--------
 File suffix for an
object file (default is `.o' on `Unix', and `.obj' on `Win32').

 EXT_ASM
--------
 File suffix for an
assembly file (default is `.s' on `Unix', and `.asm' on `Win32').

 EXE
----
 File suffix for
executables (default is empty for `Unix', and `.exe' on `Win32' and
`Cygwin'). 

Node: Section 11-6,	Next: Subsection 11-6-1,	Prev: Section 11-5,	Up: Chapter 11
  

11.6   Building C programs
*=*=*=*=*=*=*=*=*=*=*=*=*=

  
  omake provides extensive support for building C programs.
* Menu:

* Subsection 11-6-1::	C configuration variables


Node: Subsection 11-6-1,	Next: Section 11-7,	Prev: Section 11-6,	Up: Section 11-6
  

11.6.1   C configuration variables
==================================
  
  The following variables can be redefined in your project.
  

 CC
---
 The name of the C
compiler (on `Unix' it defaults to `gcc' when `gcc' is present and  to
`cc' otherwise; on `Win32' defaults to `cl /nologo').

 CXX
----
 The name of the C++
compiler (on `Unix' it defaults to `gcc' when `gcc' is present  and to
`c'++ otherwise; on `Win32' defaults to `cl /nologo').

 CPP
----
 The name of the C
preprocessor (defaults to `cpp' on `Unix', and `cl /E' on `Win32').

 CFLAGS
-------
 Compilation flags to
pass to the C compiler (default empty on `Unix', and `/DWIN32'  on
`Win32').

 CXXFLAGS
---------
 Compilation flags
to pass to the C++ compiler (default empty on `Unix', and `/DWIN32'  on
`Win32').

 INCLUDES
---------
 Additional
directories that specify the search path to the C and C++ compilers
(default is `.').  The directories are passed to the C and C++ compilers
with the `-I' option.  The include path with `-I' prefixes is defined in
the `PREFIXED_INCLUDES' variable.

 LIBS
-----
 Additional libraries
needed when building a program (default is empty).

 AS
---
 The name of the
assembler (defaults to `as' on `Unix', and `ml' on `Win32').

 ASFLAGS
--------
 Flags to pass to
the assembler (default is empty on `Unix', and `/c /coff' on `Win32').

 AR
---
 The name of the program
to create static libraries (defaults to `ar cq' on `Unix',  and `lib' on
`Win32').

 AROUT
------
 The option string
that specifies the output file for `AR'.

 LD
---
 The name of the linker
(defaults to `ld' on `Unix', and `cl' on `Win32').

 LDFLAGS
--------
 Options to pass to
the linker (default is empty).

 YACC
-----
 The name of the `yacc'
parser generator (default is `yacc' on `Unix', empty on `Win32').

 LEX
----
 The name of the `lex'
lexer generator (default is `lex' on `Unix', empty on `Win32').

 CGeneratedFiles
----------------


 LocalCGeneratedFiles
---------------------
 
<<
  CGeneratedFiles(files)
  LocalCGeneratedFiles(files)
>>
  
  The `CGeneratedFiles' and `LocalCGeneratedFiles' functions specify
files that need to be generated before any C files are scanned for
dependencies. For example, if `config.h' and `inputs.h' are both
generated files, specify: 
<<
  CGeneratedFiles(config.h inputs.h)
>>
  
  The `CGeneratedFiles' function is global --- its arguments will be
generated before any C files anywhere in the project are scanned for
dependencies. The `LocalCGeneratedFiles' function follows the normal
scoping rules of OMake.
  

 StaticCLibrary
---------------

  The `StaticCLibrary' builds a static library.
  `StaticCLibrary(<target>, <files>)'
  The `<target>' does not include the library suffix, and The `<files>'
list does not include the object suffix. These are obtained from the
`EXT_LIB' and `EXT_OBJ' variables.
  This function returns the library filename.
  The following command builds the library `libfoo.a' from the files
`a.o b.o c.o' on `Unix', or the library `libfoo.lib' from the files
`a.obj b.obj c.obj' on `Win32'.
<<
  StaticCLibrary(libfoo, a b c)
  .DEFAULT: $(StaticCLibrary libbar, a b c d)
>>
  

 StaticCLibraryCopy
-------------------

  The `StaticCLibraryCopy' function copies the static library to an
install location.
  `StaticCLibraryCopy(<tag>, <dir>, <lib>)'
  The `<tag>' is the name of a target (typically a `.PHONY' target); the
`<dir>' is the installation directory, and `<lib>' is the library to be
copied (without the library suffix).
  This function returns the filename of the library in the target
directory.
  For example, the following code copies the library `libfoo.a' to the
`/usr/lib' directory.
<<
  .PHONY: install
  
  StaticCLibraryCopy(install, /usr/lib, libfoo)
>>
  

 StaticCLibraryInstall
----------------------

  The `StaticCLibraryInstall' function builds a library, and sets the
install location in one step. It returns the filename of the library in
the target directory.
  `StaticCLibraryInstall(<tag>, <dir>, <libname>, <files>)'
<<
  StaticCLibraryInstall(install, /usr/lib, libfoo, a b c)
>>
  

 StaticCObject
--------------


 StaticCObjectCopy
------------------


 StaticCObjectInstall
---------------------

  These functions mirror the `StaticCLibrary', `StaticCLibraryCopy', and
`StaticCLibraryInstall' functions, but they build an object file (a `.o'
file on `Unix', and a `.obj' file on `Win32').

 CProgram
---------

  The `CProgram' function builds a C program from a set of object files
and libraries.
  `CProgram(<name>, <files>)'
  The `<name>' argument specifies the name of the program to be built;
the `<files>' argument specifies the files to be linked. The function
returns the filename of the executable.
  Additional options can be passed through the following variables. 
  
 CFLAGS  Flags used by the C compiler during the link step. 
 LDFLAGS  Flags to pass to the loader. 
 LIBS  Additional libraries to be linked. 
  
  For example, the following code specifies that the program `foo' is to
be produced by linking the files `bar.o' and `baz.o' and libraries
`libfoo.a'.
<<
  section
     LIBS = libfoo$(EXT_LIB)
     CProgram(foo, bar baz)
>>
  

 CProgramCopy
-------------

  The `CProgramCopy' function copies a file to an install location.
  `CProgramCopy(<tag>, <dir>, <program>)'
<<
  CProgramCopy(install, /usr/bin, foo)
>>
  

 CProgramInstall
----------------

  The `CProgramInstall' function specifies a program to build, and a
location to install, simultaneously.
  `CProgramInstall(<tag>, <dir>, <name>, <files>)'
<<
  section
     LIBS = libfoo$(EXT_LIB)
     CProgramInstall(install, /usr/bin, foo, bar baz)
>>
  

 CXXProgram
-----------


 CXXProgramInstall
------------------

  The `CXXProgram' and `CXXProgramInstall' functions are equivalent to
their C counterparts, except that would use `$(CXX)' and `$(CXXFLAGS)'
for linking instead of `$(CC)' and `$(CFLAGS)'. 

Node: Section 11-7,	Next: Subsection 11-7-1,	Prev: Section 11-6,	Up: Chapter 11
  

11.7   Building OCaml programs
*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=

  
* Menu:

* Subsection 11-7-1::	Variables for OCaml programs
* Subsection 11-7-2::	OCaml command flags
* Subsection 11-7-3::	Library variables


Node: Subsection 11-7-1,	Next: Subsection 11-7-2,	Prev: Section 11-7,	Up: Section 11-7
  

11.7.1   Variables for OCaml programs
=====================================
  
  The following variables can be redefined in your project.

 USE_OCAMLFIND
--------------
 Whether to
use the `ocamlfind' utility (default `false\')

 OCAMLC
-------
 The OCaml bytecode
compiler (default `ocamlc.opt' if it exists  and `USE_OCAMLFIND' is not
set, otherwise `ocamlc').

 OCAMLOPT
---------
 The OCaml
native-code compiler (default `ocamlopt.opt' if it  exists and
`USE_OCAMLFIND' is not set, otherwise `ocamlopt').

 CAMLP4
-------
 The `camlp4'
preprocessor (default `camlp4').

 OCAMLLEX
---------
 The OCaml lexer
generator (default `ocamllex').

 OCAMLLEXFLAGS
--------------
 The flags to
pass to `ocamllex' (default `-q').

 OCAMLYACC
----------
 The OCaml parser
generator (default `ocamlyacc').

 OCAMLDEP
---------
 The OCaml
dependency analyzer (default `ocamldep').

 OCAMLMKTOP
-----------
 The OCaml
toploop compiler (default `ocamlmktop').

 OCAMLLINK
----------
 The OCaml
bytecode linker (default `$(OCAMLC)').

 OCAMLOPTLINK
-------------
 The OCaml
native-code linker (default `$(OCAMLOPT)').

 OCAMLINCLUDES
--------------
 Search path
to pass to the OCaml compilers (default `.').  The search path with the
`-I' prefix is defined by the `PREFIXED_OCAMLINCLUDES'  variable.

 OCAMLFIND
----------
 The `ocamlfind'
utility (default `ocamlfind' if  `USE_OCAMLFIND' is set, otherwise
empty).

 OCAMLFINDFLAGS
---------------
 The flags to
pass to `ocamlfind' (default empty, `USE_OCAMLFIND' must be set).

 OCAMLPACKS
-----------
 Package names to
pass to `ocamlfind' (`USE_OCAMLFIND' must be set).

 BYTE_ENABLED
-------------
 Flag
indicating whether to use the bytecode compiler (default `true', when no
`ocamlopt' found, `false' otherwise).

 NATIVE_ENABLED
---------------
 Flag
indicating whether to use the native-code compiler (default `true', when
ocamlopt is found, `false' otherwise).  Both `BYTE_ENABLED' and
`NATIVE_ENABLED' can be set to true;  at least one should be set to
true. 

Node: Subsection 11-7-2,	Next: Subsection 11-7-3,	Prev: Subsection 11-7-1,	Up: Section 11-7
  

11.7.2   OCaml command flags
============================
  
  The following variables specify additional options to be passed to the
OCaml tools.

 OCAMLDEPFLAGS
--------------
 Flags to pass
to `OCAMLDEP'.

 OCAMLPPFLAGS
-------------
 Flags to pass
to `CAMLP4'.

 OCAMLCFLAGS
------------
 Flags to pass
to the byte-code compiler (default `-g').

 OCAMLOPTFLAGS
--------------
 Flags to pass
to the native-code compiler (default empty).

 OCAMLFLAGS
-----------
 Flags to pass to
either compiler (default `-warn-error A').

 OCAML_BYTE_LINK_FLAGS
----------------------
 Flags
to pass to the byte-code linker (default empty).

 OCAML_NATIVE_LINK_FLAGS
------------------------

Flags to pass to the native-code linker (default empty).

 OCAML_LINK_FLAGS
-----------------
 Flags to
pass to either linker. 

Node: Subsection 11-7-3,	Next: Section 11-8,	Prev: Subsection 11-7-2,	Up: Section 11-7
  

11.7.3   Library variables
==========================
  
  The following variables are used during linking.
  

 OCAML_LIBS
-----------
 Libraries to
pass to the linker. These libraries become dependencies  of the link
step.

 OCAML_OTHER_LIBS
-----------------
 Additional
libraries to pass to the linker. These libraries are  not included as
dependencies to the link step. Typical use is for the OCaml  standard
libraries like `unix' or `str'.

 OCAML_CLIBS
------------
 C libraries to
pass to the linker.

 OCAML_LIB_FLAGS
----------------
 Extra flags
for the library.

 OCamlGeneratedFiles
--------------------


 LocalOCamlGeneratedFiles
-------------------------
 
<<
  OCamlGeneratedFiles(files)
  LocalOCamlGeneratedFiles(files)
>>
  
  The `OCamlGeneratedFiles' and `LocalOCamlGeneratedFiles' functions
specify files that need to be generated before any OCaml files are
scanned for dependencies. For example, if `parser.ml' and `lexer.ml' are
both generated files, specify: 
<<
  OCamlGeneratedFiles(parser.ml lexer.ml)
>>
  
  The `OCamlGeneratedFiles' function is global --- its arguments will be
generated before any OCaml files anywhere in the project are scanned for
dependencies. The `LocalOCamlGeneratedFiles' function follows the normal
scoping rules of OMake.
  

 OCamlLibrary
-------------

  The `OCamlLibrary' function builds an OCaml library.
  `OCamlLibrary(<libname>, <files>)'
  The `<libname>' and `<files>' are listed without suffixes.
  

 ABORT_ON_DEPENDENCY_ERRORS
---------------------------
 
The linker requires that the files to be  listed in dependency order. If
this variable is true, the order of  the files is determined by the
command line, but omake will  abort with an error message if the order
is illegal. Otherwise,  the files are sorted automatically.
  This function returns the list of all the targets that it defines the
rules for (including the `$(name)$(EXT_LIB)' file when `NATIVE_ENABLED'
is set).
  The following code builds the `libfoo.cmxa' library from the files
`foo.cmx' and `bar.cmx' (if `NATIVE_ENABLED' is set), and `libfoo.cma'
from `foo.cmo' and `bar.cmo' (if `BYTE_ENABLED' is set).
<<
  OCamlLibrary(libfoo, foo bar)
>>
  

 OCamlPackage
-------------

  The `OCamlPackage' function builds an OCaml package.
  `OCamlPackage(<name>, <files>)'
  The `<name>' and `<files>' are listed without suffixes. The `<files>'
must have been compiled with the `-for-pack <ident>' flag to the OCaml
compiler.
  This function returns the list of all the targets that it defines the
rules for (including the `$(name)$(EXT_LIB)' file when `NATIVE_ENABLED'
is set).
  The following code builds the `libfoo.cmx' package from the files
`package.cmx' and `bar.cmx' (if `NATIVE_ENABLED' is set), and
`package.cmo' from `foo.cmo' and `bar.cmo' (if `BYTE_ENABLED' is set).
<<
  OCamlPackage(package, foo bar)
>>
  

 OCamlLibraryCopy
-----------------

  The `OCamlLibraryCopy' function copies a library to an install
location.
  `OCamlLibraryCopy(<tag>, <libdir>, <libname>, <interface-files>)'
  The `<interface-files>' specify additional interface files to be
copied if the `INSTALL_INTERFACES' variable is true.

 OCamlLibraryInstall
--------------------

  The `OCamlLibraryInstall' function builds a library and copies it to
an install location in one step.
  `OCamlLibraryInstall(<tag>, <libdir>, <libname>, <files>)'

 OCamlProgram
-------------

  The `OCamlProgram' function builds an OCaml program. It returns the
array with all the targets for which it have defined the rules
(`$(name)$(EXE)' and `$(name).run' and/or `$(name).opt', depending on
the `NATIVE_ENABLED' and `BYTE_ENABLED' variables).
  `OCamlProgram(<name>, <files>)'
  Additional variables used: 
  
 OCAML_LIBS 11.7.3*Note Subsection 11-7-3::  Additional libraries
   passed to the linker, without suffix. These files  become
   dependencies of the target program. 
 OCAML_OTHER_LIBS 11.7.3*Note Subsection 11-7-3::  Additional
   libraries passed to the linker, without suffix. These  files do not
   become dependencies of the target program. 
 OCAML_CLIBS 11.7.3*Note Subsection 11-7-3::  C libraries to pass to
   the linker. 
 OCAML_BYTE_LINK_FLAGS 11.7.2*Note Subsection 11-7-2:: 
   Flags to pass to the bytecode linker. 
 OCAML_NATIVE_LINK_FLAGS 11.7.2*Note Subsection 11-7-2:: 
   Flags to pass to the native code linker. 
 OCAML_LINK_FLAGS 11.7.2*Note Subsection 11-7-2::  Flags to pass
   to both linkers. 


 OCamlProgramCopy
-----------------

  The `OCamlProgramCopy' function copies an OCaml program to an install
location.
  `OCamlProgramCopy(<tag>, <bindir>, <name>)'
  Additional variables used: 
  
 NATIVE_ENABLED  If `NATIVE_ENABLED'
   11.7.1*Note Subsection 11-7-1:: is set, the native-code
   executable  is copied; otherwise the byte-code executable is copied. 


 OCamlProgramInstall
--------------------

  The `OCamlProgramInstall' function builds a programs and copies it to
an install location in one step.
  `OCamlProgramInstall(<tag>, <bindir>, <name>, <files>)' 

Node: Section 11-8,	Next: Subsection 11-8-1,	Prev: Section 11-7,	Up: Chapter 11
  

11.8   Building LaTeX programs
*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=

  
* Menu:

* Subsection 11-8-1::	Configuration variables


Node: Subsection 11-8-1,	Next: Section 11-9,	Prev: Section 11-8,	Up: Section 11-8
  

11.8.1   Configuration variables
================================
  
  The following variables can be modified in your project.

 LATEX
------
 The LaTeX command
(default `latex').

 TETEX2_ENABLED
---------------
 Flag
indicating whether to use advanced LaTeX options present in TeTeX v.2
(default value is determined the first time omake reads `LaTeX.src' and
depends on the version of LaTeX you have installed).

 LATEXFLAGS
-----------
 The LaTeX flags
(defaults depend on the `TETEX2_ENABLED' variable)

 BIBTEX
-------
 The BibTeX command
(default `bibtex').

 MAKEINDEX
----------
 The command to
build an index (default `makeindex').

 DVIPS
------
 The `.dvi' to
PostScript converter (default `dvips').

 DVIPSFLAGS
-----------
 Flags to pass to
`dvips' (default `-t letter').

 DVIPDFM
--------
 The `.dvi' to
`.pdf' converter (default `dvipdfm').

 DVIPDFMFLAGS
-------------
 Flags to pass
to `dvipdfm' (default `-p letter').

 PDFLATEX
---------
 The `.latex' to
`.pdf' converter (default `pdflatex').

 PDFLATEXFLAGS
--------------
 Flags to pass
to pdflatex (default is empty).

 USEPDFLATEX
------------
 Flag indicating
whether to use pdflatex instead of dvipdfm to generate the `.pdf'
document (default `false').

 LaTeXDocument
--------------

  The `LaTeXDocument' produces a LaTeX document.
  `LaTeXDocument(<name>, <texfiles>)'
  The document `<name>' and `<texfiles>' are listed without suffixes.
This function returns the filenames for the generated `.ps' and `.pdf'
files.
  Additional variables used:

 TEXINPUTS
----------
 The LaTeX search
path (an array of directories, default is  taken from the `TEXINPUTS'
environment variable).

 TEXDEPS
--------
 Additional files
this document depends on.

 TeXGeneratedFiles
------------------


 LocalTeXGeneratedFiles
-----------------------
 
<<
  TeXGeneratedFiles(files)
  LocalTeXGeneratedFiles(files)
>>
  
  The `TeXGeneratedFiles' and `LocalTeXGeneratedFiles' functions specify
files that need to be generated before any LaTeXfiles are scanned for
dependencies. For example, if `config.tex' and `inputs.tex' are both
generated files, specify: 
<<
      TeXGeneratedFiles(config.tex inputs.tex)
>>
  
  The `TeXGeneratedFiles' function is global --- its arguments will be
generated before any TeX files anywhere in the project are scanned for
dependencies. The `LocalTeXGeneratedFiles' function follows the normal
scoping rules of OMake.
  

 LaTeXDocumentCopy
------------------

  The `LaTeXDocumentCopy' copies the document to an install location.
  `LaTeXDocumentCopy(<tag>, <libdir>, <installname>, <docname>)'
  This function copies just the `.pdf' and `.ps' files.

 LaTeXDocumentInstall
---------------------

  The `LaTeXDocumentInstall' builds a document and copies it to an
install location in one step.
  `LaTeXDocumentInstall(<tag>, <libdir>, <installname>, <docname>,
<files>)' 

Node: Section 11-9,	Next: Chapter 12,	Prev: Section 11-8,	Up: Chapter 11
  

11.9   Examining the dependency graph
*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*



 dependencies
-------------


 dependencies-all
-----------------

<<
     $(dependencies targets) : File Array
     $(dependencies-all targets) : File Array
     $(dependencies-proper targets) : File Array
        targets : File Array
     raises RuntimeException
>>
  
  The `dependencies' function returns the set of immediate dependencies
of the given targets. This function can only be used within a rule body
and all the arguments to the `dependency' function must also be
dependencies of this rule. This restriction ensures that all the
dependencies are known when this function is executed.
  The `dependencies-all' function is similar, but it expands the
dependencies recursively, returning all of the dependencies of a target,
not just the immediate ones.
  The `dependencies-proper' function returns all recursive dependencies,
except the dependencies that are leaf targets. A leaf target is a target
that has no dependencies and no build commands; a leaf target
corresponds to a source file in the current project.
  In all three functions, files that are not part of the current project
are silently discarded.
  One purpose of the `dependencies-proper' function is for ``clean''
targets. For example, one way to delete all intermediate files in a
build is with a rule that uses the `dependencies-proper'. Note however,
that the rule requires building the project before it can be deleted.
For a shorter form, see the `filter-proper-targets' function.
<<
      .PHONY: clean
  
      APP = ...     # the name of the target application
      clean: $(APP)
         rm $(dependencies-proper $(APP))
>>
  
  

 target
-------
 
<<
     $(target targets) : Rule Array
        targets : File Sequence
     raises RuntimeException
>>
  
  The `target' function returns the Target object associated with each
of the targets. See the `Target' object for more information.

 rule
-----

  The `rule' function is called whenever a build rule is defined. It is
unlikely that you will need to redefine this function, except in very
exceptional cases.
<<
     rule(multiple, target, pattern, sources, options, body) : Rule
        multiple : String
        target   : Sequence
        pattern  : Sequence
        sources  : Sequence
        options  : Array
        body     : Body
>>
  
  The `rule' function is called when a rule is evaluated.
  
  
 multiple  A Boolean value indicating whether the rule was defined  with
   a double colon `::'. 
 target  The sequence of target names. 
 pattern  The sequence of patterns. This sequence will be empty  for
   two-part rules. 
 sources  The sequence of dependencies. 
 options  An array of options. Each option is represented  as a
   two-element array with an option name, and the option value. 
 body  The body expression of the rule. 
  
  Consider the following rule.
<<
     target: pattern: sources :name1: option1 :name2: option2
        expr1
        expr2
>>
  
  This expression represents the following function call, where square
brackets are used to indicate arrays.
<<
     rule(false, target, pattern, sources,
          [[:name1:, option1], [:name2:, option2]]
          [expr1; expr2])
>>
   

Node: Chapter 12,	Next: Section 12-1,	Prev: Chapter 11,	Up: Top
  

Chapter 12     The OSH shell
****************************
    
  OMake also includes a standalone command-line interpreter osh that can
be used as an interactive shell. The shell uses the same syntax, and
provides the same features on all platforms omake supports, including
Win32.
* Menu:

* Section 12-1::	Startup
* Section 12-2::	Aliases
* Section 12-3::	Interactive syntax


Node: Section 12-1,	Next: Section 12-2,	Prev: Chapter 12,	Up: Chapter 12
  

12.1   Startup
*=*=*=*=*=*=*=

  
  On startup, osh reads the file `~/.oshrc' if it exists. The syntax of
this file is the same as an OMakefile. The following additional
variables are significant.
  

 prompt
-------
 The `prompt'
variable specifies the command-line prompt. It can be a simple string.
<<
      prompt = osh>
>>
  
  Or you may choose to define it as a function of no arguments.
<<
      prompt() =
          return $"<$(USER):$(HOST) $(homename $(CWD))>"
>>
  
  An example of the latter prompt is as follows.
<<
      <jyh:kenai.yapper.org ~>cd links/omake
      <jyh:kenai.yapper.org ~/links/omake>
>>
  
  

 ignoreeof
----------
  If the
`ignoreeof' is `true', then `osh' will not exit on  a terminal
end-of-file (usually `^D' on Unix systems).

Node: Section 12-2,	Next: Section 12-3,	Prev: Section 12-1,	Up: Chapter 12
  

12.2   Aliases
*=*=*=*=*=*=*=

   
  Command aliases are defined by adding functions to the `Shell.'
object. The following alias adds the `-AF' option to the `ls' command.
<<
      Shell. +=
         ls(argv) =
            "ls" -AF $(argv)
>>
  
  Quoted commands do not undergo alias expansion. The quotation `"ls"'
prevents the alias from being recursive.

Node: Section 12-3,	Next: Appendix A,	Prev: Section 12-2,	Up: Chapter 12
  

12.3   Interactive syntax
*=*=*=*=*=*=*=*=*=*=*=*=*

  
  The interactive syntax in `osh' is the same as the syntax of an
`OMakefile', with one exception in regard to indentation. The line
before an indented block must have a colon at the end of the line. A
block is terminated with a `.' on a line by itself, or `^D'. In the
following example, the first line `if true' has no body, because there
is no colon.
<<
     # The following if has no body
     osh>if true
     # The following if has a body
     osh>if true:
     if>       if true:
     if>          println(Hello world)
     if>          .
     Hello world
>>
  
  Note that `osh' makes some effort to modify the prompt while in an
indented body, and it auto-indents the text.
  The colon signifier is also allowed in files, although it is not
required.
   

Node: Appendix A,	Next: Section A-1,	Prev: Chapter 12,	Up: Top
  

Appendix A     Synopsis
***********************
    
  omake  [-k]  [-j <count>]  [-n]  [-s] [-S]  [-p]  [-P]  [-w]  [-t] 
[-u]  [-U]  [-R]  [--project]  [--progress] [--no-progress] 
[--print-status] [--no-print-status]  [--print-exit] [--no-print-exit] 
[--print-dependencies]  [--show-dependencies < target>] 
[--force-dotomake]  [--dotomake < dir>]  [--flush-includes] 
[--configure]  [--install]  [--install-all]  [--install-force] 
[--version]  filename...  [var-definition...]
* Menu:

* Section A-1::	Command-line options


Node: Section A-1,	Next: Appendix B,	Prev: Appendix A,	Up: Appendix A
  

A.1   Command-line options
*=*=*=*=*=*=*=*=*=*=*=*=*=

  
  
  
 -k  Do not abort when a build command fails; continue to build as much
   of the project as possible.
 
 -n  Print the commands that would be executed, but do no execute them.
   This can be used to see what would happen if the project were to be
   built.
 
 -s  Do not print commands as they are executed (be ``silent'').
 
 -S  Do not print commands as they are executed unless they produce
   output.
 
 --progress  Print a progress indicator. This is normally used with the
   -s or -S options.
 
 --no-progress  Do not print a progress indicator (default).
 
 --print-exit  Print termination codes when commands complete.
 
 --no-print-exit  Do not print termination codes when commands complete
   (default).
 
 -w  Print directory information in make format as commands are
   executed. This is mainly useful for editors that expect make-style
   directory information for determining the location of errors.
 
 -p  Watch the filesystem for changes, and continue the build until it
   succeeds. If this option is specified, omake will restart the build
   whenever source files are modified.
 
 -P  Watch the filesystem for changes forever. If this option is
   specified, omake will restart the build whenever source files are
   modified.
 
 -R  Ignore the current directory and build the project from its root
   directory. When omake is run in a subdirectory of a project, it
   normally builds files within the current directory and its
   subdirectories. If the -R option is specified, the build is performed
   as if omake were run in the project root.
 
 -t  Update the omake database to force the project to be considered
   up-to-date.
 
 -U  Do not trust cached build information. This will force the entire
   project to be rebuilt.
 
 --depend  Do not trust cached dependency information. This will force
   files to be rescanned for dependency information.
 
 --configure  Re-run `static.\' sections of the included omake files,
   instead of trusting the cached results.
 
 [--force-dotomake]  Always use the `$HOME/.omake' for the `.omc' cache
   files.
 
 [--dotomake < dir>]  Use the specified directory instead of the
   `$HOME/.omake' for the placement of the `.omc' cache files.
 
 -j count  Run multiple build commands in parallel. The count specifies
   a bound on the number of commands to run simultaneously. In addition,
   the count may specify servers for remote execution of commands in the
   form `server=count'. For example, the option `-j
   2:small.host.org=1:large.host.org=4' would specify that up to 2 jobs
   can be executed locally, 1 on the server `small.host.org' and 4 on
   `large.host.org'. Each remote server must use the same filesystem
   location for the project.
 Remote execution is currently an experimental feature. Remote
   filesystems like NFS do not provide adequate file consistency for
   this to work.
 
 --print-dependencies  Print dependency information for the targets on
   the command line.
 
 --show-dependencies  target  Print dependency information if the
   `target' is built.
 
 --install  Install default files OMakefile and OMakeroot into the
   current  directory. You would typically do this to start a project in
   the current directory.
 
 --install-all  In addition to installing files OMakefile and OMakeroot,
    install default OMakefiles into each subdirectory of the current
   directory.  cvs(1) rules are used for filtering the subdirectory
   list. For example, OMakefiles  are not copied into directories called
   `CVS', `RCCS', etc.
 
 --install-force  Normally, omake will prompt before it overwrites any 
   existing OMakefile. If this option is given, all files are forcibly
   overwritten  without prompting.
 
 var-definition  omake variables can also be defined on the command 
   line in the form `name=value'. For example, the `CFLAGS' variable
   might be defined  on the command line with the argument
   `CFLAGS="-Wall -g"'. 
  
  In addition, omake supports a number of debugging flags on the command
line. Run `omake --help' to get a summary of these flags.
   

Node: Appendix B,	Next: Section B-1,	Prev: Appendix A,	Up: Top
  

Appendix B     OMake grammar
****************************
    
* Menu:

* Section B-1::	OMake lexical conventions
* Section B-2::	The OMake grammar
* Section B-3::	Dollar modifiers


Node: Section B-1,	Next: Subsection B-1-1,	Prev: Appendix B,	Up: Appendix B
  

B.1   OMake lexical conventions
*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*

  
  The OMake language is based on the language for GNU/BSD make, where
there are few lexical conventions. Strictly speaking, there are no
keywords, and few special symbols.
* Menu:

* Subsection B-1-1::	Comments
* Subsection B-1-2::	Special characters
* Subsection B-1-3::	Identifiers
* Subsection B-1-4::	Command identifiers
* Subsection B-1-5::	Variable references
* Subsection B-1-6::	String constants


Node: Subsection B-1-1,	Next: Subsection B-1-2,	Prev: Section B-1,	Up: Section B-1
  

B.1.1   Comments
================
  
  Comments begin with the `#' character and continue to the end-of-line.
Text within a comment is unrestricted.
  Examples.
<<
     # This is a comment
     # This $comment contains a quote " character
>>
  

Node: Subsection B-1-2,	Next: Subsection B-1-3,	Prev: Subsection B-1-1,	Up: Section B-1
  

B.1.2   Special characters
==========================
  
  The following characters are special in some contexts.
<<
     $    (    )    ,    .   =    :    "    '    `    \    #
>>
  
  
  
 - `$' is used to denote a variable reference, or function application. 
 - Parentheses `)', `(' are argument deliminters. 
 - The command `,' is an argument separator. 
 - The period symbol `.' is a name separator. 
 - The equality symbol `=' denotes a definition. 
 - The colon symbol `:' is used to denote rules, and (optionally) to
   indicate  that an expression is followed by an indented body. 
 - The quotation symbols `"' and `'' delimit character strings. 
 - The symbol `#' is the first character of a constant. 
 - The escape symbol `\' is special only when followed by another
   special  character. In this case, the special status of the second
   character is removed,  and the sequence denotes the second character.
   Otherwise, the `\' is not special.
 Examples:
 
      
    - `\$': the `$' character (as a normal character).  
    - `\#': the `#' character (as a normal character).  
    - `\\': the `\' character (as a normal character).  
    - `c\:\Windows\moo\#boo': the string `c:\Windows\moo#boo'.  
  
  

Node: Subsection B-1-3,	Next: Subsection B-1-4,	Prev: Subsection B-1-2,	Up: Section B-1
  

B.1.3   Identifiers
===================
  
  Identifiers (variable names) are drawn from the ASCII alphanumeric
characters as well as `_', `-', `~', `@'. Case is significant; the
following identifiers are distinct: `FOO', `Foo', `foo'. The identifier
may begin with any of the valid characters, including digits.
  Using `egrep' notation, the regular expression for identifiers is
defined as follows.
<<
      identifier ::= [-@~_A-Za-z0-9]+
>>
  
  The following are legal identifiers.
<<
      Xyz    hello_world    seventy@nine
      79-32  Gnus~Gnats     CFLAGS
>>
  
  The following are not legal identifiers.
<<
      x+y    hello&world
>>
  

Node: Subsection B-1-4,	Next: Subsection B-1-5,	Prev: Subsection B-1-3,	Up: Section B-1
  

B.1.4   Command identifiers
===========================
  
  The following words have special significance when they occur as the
first word of a program line. They are not otherwise special.
<<
      case     catch  class    declare    default
      do       else   elseif   export     extends
      finally  if     import   include    match
      open     raise  return   section    switch
      try      value  when     while
>>
  

Node: Subsection B-1-5,	Next: Subsection B-1-6,	Prev: Subsection B-1-4,	Up: Section B-1
  

B.1.5   Variable references
===========================
  
  A variable reference is denoted with the `$' special character
followed by an identifier. If the identifier name has more than one
character, it must be enclosed in parentheses. The parenthesized version
is most common. The following are legal variable references.
<<
      $(Xyz)    $(hello_world)   $(seventy@nine)
      $(79-32)  $(Gnus~Gnats)    $(CFLAGS)
>>
  
  Single-character references also include several additional
identifiers, including `&*<^?]['. The following are legal
single-character references.
<<
     $@   $&   $*   $<   $^   $+   $?   $[   $]
     $A   $_   $a   $b   $x   $1   $2   $3
>>
  
  Note that a non-parenthesized variable reference is limited to a
single character, even if it is followed by additional legal identifier
charqcters. Suppose the value of the `$x' variable is 17. The following
examples illustrate evaluation.
<<
      $x           evaluates to    17
      foo$xbar     evaluates to    foo17bar
      foo$(x)bar   evaluates to    foo17bar
>>
  
  The special sequence `$$' represents the character literal `$'. That
is, the two-character sequences `\$' and `$$' are normally equalivalent.

Node: Subsection B-1-6,	Next: Section B-2,	Prev: Subsection B-1-5,	Up: Section B-1
  

B.1.6   String constants
========================
  
  Literal strings are defined with matching string delimiters. A left
string delimiter begins with the dollar-sign `$', and a non-zero number
of single-quote or double-quote characters. The string is terminated
with a matching sequence of quotation symbols. The delimiter quotation
may not be mixed; it must contain only single-quote characters, or
double-quote characters. The following are legal strings.
<<
      $'Hello world'
      $"""printf("Hello world\n")"""
      $''''
  Large "block" of
  text # spanning ''multiple'' lines''''
>>
  
  The string delimiters are not included in the string constant. In the
single-quote form, the contents of the string are interpreted
verbatim--there are no special characters.
  The double-quote form permits expression evaluation within the string,
denoted with the `$' symbol. The following are some examples.
<<
      X = Hello
      Y = $""$X world""             # Hello world
      Z = $'''$X world'''           # $X world
      I = 3
      W = $"6 > $(add $I, 2)"       # 6 > 5
>>
  
  Note that quotation symbols without a leading `$' are not treated
specially by OMake. The quotation symbols is included in the sequence.
<<
      osh>println('Hello world')
      'Hello world'
      osh>println($'Hello world')
      Hello world
      osh>X = Hello
      - : "Hello" : Sequence
      osh>println('$X world')
      Hello world
>>
  

Node: Section B-2,	Next: Subsection B-2-1,	Prev: Section B-1,	Up: Appendix B
  

B.2   The OMake grammar
*=*=*=*=*=*=*=*=*=*=*=*

  
  OMake programs are constructed from expressions and statements.
Generally, an input program consists of a sequence of statements, each
of which consists of one or more lines. Indentation is significant--if a
statement consists of more than one line, the second and remaining lines
(called the body) are usually indented relative to the first line.
* Menu:

* Subsection B-2-1::	Expressions
* Subsection B-2-2::	Statements and programs


Node: Subsection B-2-1,	Next: Subsection B-2-2,	Prev: Section B-2,	Up: Section B-2
  

B.2.1   Expressions
===================
  
  The following table lists the syntax for expressions.
   expr ::=                                             
            (empty)                                     
            -- Text (see note)                          
         |  text                                        
         |  string-literal                              
            -- Applications                             
         |  dollar `<char>'                             
         |  dollar `(' pathid args `)'                  
            -- Concatenation                            
         |  expr expr                                   
                                                        
 dollar ::= `$' | `$`' | `$,'                           
 pathid ::=                                             
            id                                          
         |  pathid `.' id                               
                                                        
    arg ::= expr -- excluding special characters `)(,') 
   args ::= (empty) | arg, ..., arg                     
  
  An expression is a sequence composed of text, string-literals,
variables references and function applications. Text is any sequence of
non-special characters.
  

 Inline applications
--------------------
  
  An application is the application of a function to zero-or-more
arguments. Inline applications begin with one of the ``dollar''
sequences `$', `$`', or `$,'. The application itself is specified as a
single character (in which case it is a variable reference), or it is a
parenthesized list including a function identifier pathid, and
zero-or-more comma-separated arguments args. The arguments are
themselves a variant of the expressions where the special character
`)(,' are not allowed (though any of these may be made non-special with
the `\' escape character). The following are some examples of valid
expressions.
  
  
 - `xyz abc'
 The text sequence ```xyz abc'''
 
 - `xyz$wabc'
 A text sequence containing a reference to the variable `w'.
 
 - `$(addsuffix .c, $(FILES))'
 An application of the function `addsuffix', with first argument `.c',
   and second argument `$(FILES)'.
 
 - `$(a.b.c 12)'
 This is a method call. The variable `a' must evaluate to an object with
   a field `b', which must be an object with a method `c'. This method
   is called with argument `12'. 
  
  The additional dollar sequences specify evaluation order, `$`' (lazy)
and `$,' (eager), as discussed in the section on dollar modifiers
B.3*Note Section B-3::.

Node: Subsection B-2-2,	Next: Section B-3,	Prev: Subsection B-2-1,	Up: Section B-2
  

B.2.2   Statements and programs
===============================
  
  The following table lists the syntax of statements and programs.
         params ::= (empty) | id, ..., id                               
        
                                                                        
        
         target ::= expr -- excluding special character `:'             
        
                                                                        
        
        program ::= stmt `<eol>' ... `<eol>' stmt                       
        
                                                                        
        
           stmt ::=                                                     
        
                    -- Special forms                                    
        
                 |  command expr optcolon-body                          
        
                 |  command ( args ) optcolon-body                      
        
                 |  catch id ( id ) optcolon-body                       
        
                 |  class id ... id                                     
        
                                                                        
        
                    -- Variable definitions                             
        
                 |  pathid +^?= expr                                    
        
                 |  pathid {+}= `<eol>' indented-body                   
        
                 |  pathid`[]' {+}= expr                                
        
                 |  pathid`[]' {+}= `<eol>' indented-exprs              
        
                                                                        
        
                    -- Functions                                        
        
                 |  pathid(args) optcolon-body                          
        
                 |  pathid(params) = `<eol>' indented-body              
        
                                                                        
        
                    -- Objects                                          
        
                 |  pathid `.' {+}= `<eol>' indented-body               
        
                                                                        
        
                    -- Rules                                            
        
                 |  target : target rule-options `<eol>' indented-body  
        
                 |  target :: target rule-options `<eol>' indented-body 
        
                 |  target : target : target rule-options `<eol>'
indented-body  
                 |  target :: target : target rule-options `<eol>'
indented-body 
                                                                        
        
                    -- Shell commands                                   
        
                 |  expr                                                
        
                                                                        
        
  indented-body ::= (empty)                                             
        
                 |  indented-stmt `<eol>' ... `<eol>' indented-stmt     
        
                                                                        
        
 indented-exprs ::= (empty)                                             
        
                 |  indented-expr `<eol>' ... `<eol>' indented-expr     
        
                                                                        
        
  optcolon-body ::= (empty)                                             
        
                 |  `<eol>' indented-body                               
        
                 |  : `<eol>' indented-body                             
        
                                                                        
        
    rule-option ::= :id: target                                         
        
   rule-options ::= (empty)                                             
        
                 |  rule-options rule-option                            
        
  
  

 Special forms
--------------
  
  The special forms include the following.
  Conditionals (see the section on conditionals
4.9*Note Section 4-9::). The `if' command should be
followed by an expression that represents the condition, and an indented
body. The conditional may be followed by `elseif' and `else' blocks.
<<
      if expr
          indented-body
      elseif expr
          indented-body
      ...
      else
          indented-body
>>
  
  matching (see the section on matching 4.10*Note Section 4-10::).
The `switch' and `match' commands perform pattern-matching. All cases
are optional. Each case may include `when' clauses that specify
additional matching conditions.
<<
      match(expr)
      case expr
         indented-body
      when expr
         indented-body
      ...
      case expr
         indented-body
      default
         indented-body
>>
  
  Exceptions (see the `try' function 7.2*Note Section 7-2::). The `try'
command introduces an exception handler. Each `name' is the name of a
class. All cases, including `catch', `default', and `finally' are
optional. The `catch' and `default' clauses contain optional `when'
clauses.
<<
      try
          indented-body
      catch name1(id1)
          indented-body
      when expr
          indented-body
      ...
      catch nameN(idN)
          indented-body
      default
          indented-body
      finally
          indented-body
>>
  
  The `raise' command is used to raise an exception.
<<
      raise expr
>>
  
  section (see the `section' description
4.8*Note Section 4-8::). The `section' command introduces a new
scope.
<<
      section
          indented-body
>>
  
  include, open (see the `include' description
4.7*Note Section 4-7::). The `include' command performs file
inclusion. The expression should evaluate to a file name.
  The `open' form is like include, but it performs the inclusion only if
the inclusion has not already been performed. The `open' form is usually
used to include library files. [jyh-- this behavior will change in
subsequent revisions.]
<<
      include expr
      open expr
>>
  
  return (see the description of functions
4.5*Note Section 4-5::). The `return' command terminates
execution and returns a value from a function.
<<
      return expr
>>
  
  value (see the description of functions
4.5*Note Section 4-5::). The `value' command is an identity.
Syntactically, it is used to coerce a n expression to a statement.
<<
      value expr
>>
  
  export (see the section on scoping 4.8*Note Section 4-8::).
The `export' command exports a environment from a nested block. If no
identifiers are specified, the entire environment is exported.
Otherwise, the export is limited to the specified identifiers.
<<
      export id ... id
>>
  
  while (see the `while' description 7.3*Note Section 7-3::). The
`while' command introduces a `while' loop.
<<
      while expr
          indented-body
>>
  
  class, extends (see the section on objects
4.11*Note Section 4-11::). The `class' command specifies an
identifier for an object. The `extends' command specifies a parent
object.
<<
      class id
      extends expr
>>
  
  

 Variable definitions
---------------------
  
  See the section on variables 4.1*Note Section 4-1::. The
simplest variable definition has the following syntax. The `=' form is a
new definition. The += form appends the value to an existing definition.
<<
      id = expr
      id += expr
  
      osh> X = 1
      - : "1" : Sequence
      osh> X += 7
      - : "1" " " "7" : Sequence
>>
  
  A multi-line form is allowed, where the value is computed by an
indented body.
<<
      id {+}=
          indented-body
  
      osh> X =
               Y = HOME
               println(Y is $Y)
               getenv($Y)
      Y is HOME
      - : "/home/jyh" : Sequence
>>
  
  The name may be qualified qith one of the `public', `prtected', or
`private' modifiers. Public variables are dynamically scoped. Protected
variables are fields in the current object. Private variables are
statically scoped.
  [jyh: revision 0.9.9 introduces modular namespaces; the meaning of
these qualifiers is slightly changed.]
<<
      public.X = $(addsuffix .c, 1 2 3)
      protected.Y = $(getenv HOME)
      private.Z = $"Hello world"
>>
  
  

 Applications and function definitions
--------------------------------------
  
  See the section on functions 4.5*Note Section 4-5::. A
function-application statement is specified as a function name, followed
a parenthesized list of comma-separated arguments.
<<
      osh> println($"Hello world")
  
      osh> FILES = 1 2 3
      - : 1 2 3
      osh> addsuffix(.c, $(FILES))
      - : 1.c 2.c 3.c
  
      # The following forms are equivalent
      osh> value $(println $"Hello world")
      osh> value $(addsuffix .c, $(FILES))
      - : 1.c 2.c 3.c
>>
  
  If the function application has a body, the body is passed (lazily) to
the function as its first argument. [jyh: in revision 0.9.8 support is
incomplete.] When using `osh', the application must be followed by a
colon `:' to indicate that the application has a body.
<<
      # In its 3-argument form, the foreach function takes
      # a body, a variable, and an array.  The body is evaluated
      # for each element of the array, with the variable bound to
      # the element value.
      #
      # The colon is required only for interactive sessions.
      osh> foreach(x, 1 2 3):
              add($x, 1)
      - : 2 3 4
>>
  
  Functions are defined in a similar form, where the parameter list is
specified as a comma-separated list of identifiers, and the body of the
function is indented.
<<
      osh> f(i, j) =
              add($i, $j)
      - : <fun 2>
      osh> f(3, 7)
      - : 10 : Int
>>
  
  

 Objects
--------
  
  See the section on objects 4.11*Note Section 4-11::. Objects
are defined as an identifier with a terminal period. The body of the
object is indented.
<<
      Obj. =
          class Obj
  
          X = 1
          Y = $(sub $X, 12)
          new(i, j) =
             X = $i
             Y = $j
             value $(this)
          F() =
             add($X, $Y)
          println($Y)
>>
  
  The body of the object has the usual form of an indented body, but new
variable definitions are added to the object, not the global
environment. The object definition above defines an object with (at
least) the fields `X' and `Y', and methods `new' and `F'. The name of
the object is defined with the `class' command as `Obj'.
  The `Obj' itself has fields `X = 1' and `Y = -11'. The `new' method
has the typical form of a constructor-style method, where the fields of
the object are initialized to new values, and the new object returned
(`$(this)' refers to the current object).
  The `F' method returns the sum of the two fields `X' and `Y'.
  When used in an object definition, the += form adds the new
definitions to an existing object.
<<
     pair. =
        x = 1
        y = 2
  
     pair. +=
        y = $(add $y, 3)
     # pair now has fields (x = 1, and y = 5)
>>
  
  The `extends' form specifies inheritance. Multiple inheritance is
allowed. At evaluation time, the `extends' directive performs inclusion
of the entire parent object.
<<
     pair. =
        x = 1
        y = 2
  
     depth. =
        z = 3
        zoom(dz) =
           z = $(add $z, $(dz))
           return $(this)
  
     triple. =
        extends $(pair)
        extends $(depth)
  
        crazy() =
           zoom($(mul $x, $y))
>>
  
  In this example, the `triple' object has three fields x, y, and z; and
two methods `zoom' and `crazy'.
  

 Rules
------
  
  See the chapter on rules 6*Note Chapter 6::. A rule has the
following parts. 
  
 1. A sequence of targets; 
 2. one or two colons; 
 3. a sequence of dependencies and rule options; 
 4. and an indented body. 
  
  The targets are the files to be built, and the dependencies are the
files it depends on. If two colons are specified, it indicates that
there may be multiple rules to build the given targets; otherwise only
one rule is allowed.
  If the target contains a `%' character, the rule is called implicit,
and is considered whenever a file matching that pattern is to be built.
For example, the following rule specifies a default rule for compiling
OCaml files.
<<
      %.cmo: %.ml %.mli
         $(OCAMLC) -c $<
>>
  
  This rule would be consulted as a default way of building any file
with a `.cmo' suffix. The dependencies list is also constructed based on
the pattern match. For example, if this rule were used to build a file
`foo.cmo', then the dependency list would be `foo.ml foo.mli'.
  There is also a three-part version of a rule, where the rule
specification has three parts.
<<
      targets : pattern : dependencies rule-options
         indented-body
>>
  
  In this case, the pattern must contain a single `%' character. However
this is considered to be a sequence of explicit rules, where each target
is matched against the pattern, and a new rule is computed based on the
pattern match. For example, the following rule specifies how to build
the explicit targets `a.cmo' and `b.cmo'.
<<
      a.cmo b.cmo: %.cmo: %.ml %.mli
         $(OCAMLC) -c $<
>>
  
  This example is equivalent to the following two-rule sequence.
<<
      a.cmo: a.ml a.mli
         $(OCAMLC) -c $<
      b.cmo: b.ml b.mli
         $(OCAMLC) -c $<
>>
  
  There are several special targets, including the following.
  
  
 - `.PHONY' : declare a ``phony'' target. That is, the target does not
   correspond to a file. 
 - `.ORDER' : declare a rule for dependency ordering. 
 - `.INCLUDE' : define a rule to generate a file for textual inclusion. 
 - `.SUBDIRS' : specify subdirectories that are part of the project. 
 - `.SCANNER' : define a rule for dependency scanning. 
  
  There are several rule options.
  
  
 - `:optional: dependencies' the subsequent dependencies are optional,
   it is acceptable if they do not exist. 
 - `:exists: dependencies' the subsequent dependencies must exist, but
   changes to not affect whether this rule is considered out-of-date. 
 - `:effects: targets' the subsequent files are side-effects of the
   rule. That is, they may be created and/or modified while the rule is
   executing. Rules with overlapping side-effects are never executed in
   parallel. 
 - `:scanner: name' the subsequent name is the name of the `.SCANNER'
   rule for the target to be built. 
 - `:value: expr' the `expr' is a ``value'' dependency. The rule is
   considered out-of-date whenever the value of the `expr' changes. 
  
  Several variables are defined during rule evaluation.
  
  
 - `$*' : the name of the target with the outermost suffix removed. 
 - `$>' : the name of the target with all suffixes removed. 
 - `$@' : the name of the target. 
 - `$^' : the explicit file dependencies, sorted alphabetically, with
   duplicates removed. 
 - `$'+ : all explicit file dependencies, with order preserved. 
 - `$<' : the first explicit file dependency. 
 - `$&' : the free values of the rule (often used in `:value:'
   dependencies). 
  
  

 Shell commands
---------------
  
  See the chapter on shell commands 9*Note Chapter 9::.
  While it is possible to give a precise specification of shell
commands, the informal description is simpler. Any non-empty statement
where each prefix is not one of the other statements, is considered to
be a shell command. Here are some examples.
<<
      ls                                 -- shell command
      echo Hello world > /dev/null       -- shell command
      echo(Hello world)                  -- function application
      echo(Hello world) > /dev/null      -- syntax error
      echo Hello: world                  -- rule
      X=1 getenv X                       -- variable definition
      env X=1 getenv X                   -- shell command
      if true                            -- special form
      \if true                           -- shell command
      "if" true                          -- shell command
>>
  
