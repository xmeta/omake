OMAKE-BUILD-EXAMPLES(1)          Build Tools           OMAKE-BUILD-EXAMPLES(1)



NAME
       omake  is  a flexible build system designed for building a wide variety
       of projects.  This document describes the language concepts and syntax.
       For an overview of omake, see the omake(1) man page.


BUILD EXAMPLES
       Let's  explain the OMake build model a bit, especially since it differs
       significantly from GNU make.  One issue that dominates this  discussion
       is  that  OMake  is  based  on  global project analysis. That means you
       define a configuration for the entire project, and you run one instance
       of omake.

       For  single-directory projects this doesn't mean much. For multi-direc-
       tory projects it means a lot.  With GNU make, you would usually  invoke
       the  make  program  recursivelt  for each directory in the project. For
       example, suppose you had a project with some  project  root  directory,
       containing a directory of sources src, which in turn contains subdirec-
       tories lib and main.  So your project looks like  this  nice  piece  of
       ASCII art.

           my_project/
           |--> Makefile
           `--> src/
                |---> Makefile
                |---> lib/
                |     |---> Makefile
                |     `---> source files...
                `---> main/
                      |---> Makefile
                      `---> source files...


       Typically,  with  GNU  make,  you  would  start  an instance of make in
       my_project/; this would in term start an instance of make in  the  src/
       directory;  and this would start new instances in lib/ and main/. Basi-
       cally, you count up the number of Makefiles in the project, and that is
       the number of instances of make processes that will be created.

       The number of processes is no big deal with today's machines (sometimes
       contrary the the author's opinion, we no longer live in the 1970s). The
       problem  with the scheme was that each make process had a separate con-
       figuration, and it took a lot of work to make sure that everything  was
       consistent.  Furthermore, suppose the programmer runs make in the main/
       directory, but the lib/ is out-of-date. In this case, make  would  hap-
       pily  crank away, perhaps trying to rebuild files in lib/, perhaps just
       giving up.

       With OMake this changes entirely. Well, not entirely. The source struc-
       ture is quite similar, we merely add some Os to the ASCII art.

           my_project/
           |--> OMakeroot   (or Root.om)
           |--> OMakefile
           `--> src/
                |---> OMakefile
                |---> lib/
                |     |---> OMakefile
                |     `---> source files...
                `---> main/
                      |---> OMakefile
                      `---> source files...


       The   role  of  each  <dir>/OMakefile  plays  the  same  role  as  each
       <dir>/Makefile: it describes how to build the source  files  in  <dir>.
       The OMakefile retains much of syntax and structure of the Makefile, but
       in most cases it is much simpler.

       One minor difference is the presence of the OMakeroot  in  the  project
       root.  The  main  purpose of this file is to indicate where the project
       root is in the first place (in case omake is invoked from  a  subdirec-
       tory).  The  OMakeroot  serves  as  the bootstrap file; omake starts by
       reading this file first. Otherwise, the syntax and evaluation of OMake-
       root is no different from any other OMakefile.

       The  big  difference  is that OMake performs a global analysis. Here is
       what happens when omake starts.

       1.     omake locates that OMakeroot file, and reads it.

       2.     Each OMakefile points to its subdirectory OMakefiles  using  the
              .SUBDIRS target.  For example, my_project/OMakefile has a rule,

           .SUBDIRS: src


       and the my_project/src/OMakefile has a rule,

           .SUBDIRS: lib main


       omake  uses  these  rules  to  read and evaluate every OMakefile in the
       project.  Reading and evaluation is fast. This part of the  process  is
       cheap.


       3.     Now  that  the  entire  configuration  is read, omake determines
              which files are  out-of-date  (using  a  global  analysis),  and
              starts  the  build  process. This may take a while, depending on
              what exactly needs to be done.

       There are several advantages to this model. First,  since  analysis  is
       global,  it  is  much  easier to ensure that the build configuration is
       consistent--after all, there is only one configuration.  Another  bene-
       fit  is  that the build configuration is inherited, and can be re-used,
       down the hierarchy. Typically, the root OMakefile defines some standard
       boilerplate  and configuration, and this is inherited by subdirectories
       that tweak and modify it (but do not need to restate it entirely).  The
       disadvantage  of  course  is space, since this is global analysis after
       all.  In practice rarely seems to be a concern;  omake  takes  up  much
       less space than your web browser even on large projects.

       Some notes to the power-GNU-make user.

       *      OMakefiles  are a lot like Makefiles. The syntax is similar, and
              there many of the builtin functions are  similar.  However,  the
              two  build  systems are not the same. Some evil features (in the
              authors' opinions) have been dropped in OMake, and some new fea-
              tures have been added.


       *      OMake  works the same way on all platforms, including Win32. The
              standard configuration does the right thing,  but  if  you  care
              about  porting your code to multiple platforms, and you use some
              tricky features, you may need to condition parts of  your  build
              config on the $(OSTYPE) variable.


       *      A  minor issue is that OMake dependency analysis is based on MD5
              file digests. That is, dependencies are based on file  contents,
              not  file  modification  times.   Say  goodbye to false rebuilds
              based on spurius timestamp changes and mismatches between  local
              time and fileserver time.


   OMAKEROOT VS. OMAKEFILE
       Before  we begin with examples, let's ask the first question, ``What is
       the difference between the project root OMakeroot  and  OMakefile?''  A
       short answer is, there is no difference, but you must have an OMakeroot
       file (or Root.om file).

       However, the normal style is  that  OMakeroot  is  boilerplate  and  is
       more-or-less  the same for all projects. The OMakefile is where you put
       all your project-specific stuff.

       To get started, you don't have to do this yourself. In most  cases  you
       just perform the following step in your project root directory.


       *      Run omake --install in your project root.

       This will create the initial OMakeroot and OMakefile files that you can
       edit to get started.


   AN EXAMPLE C PROJECT
       To begin, let's start with a simple example. Let's say that we  have  a
       full directory tree, containing the following files.

           my_project/
           |--> OMakeroot
           |--> OMakefile
           `--> src/
                |---> OMakefile
                |---> lib/
                |     |---> OMakefile
                |     |---> ouch.c
                |     |---> ouch.h
                |     `---> bandaid.c
                `---> main/
                      |---> OMakefile
                      |---> horsefly.c
                      |---> horsefly.h
                      `---> main.c


       Here is an example listing.

       my_project/OMakeroot:
           # Include the standard configuration for C applications
           open build/C

           # Process the command-line vars
           DefineCommandVars()

           # Include the OMakefile in this directory.
           .SUBDIRS: .

       my_project/OMakefile:
           # Set up the standard configuration
           CFLAGS += -g

           # Include the src subdirectory
           .SUBDIRS: src

       my_project/src/OMakefile:
           # Add any extra options you like
           CFLAGS += -O2

           # Include the subdirectories
           .SUBDIRS: lib main

       my_project/src/lib/OMakefile:
           # Build the library as a static library.
           # This builds libbug.a on Unix/OSX, or libbug.lib on Win32.
           # Note that the source files are listed _without_ suffix.
           StaticCLibrary(libbug, ouch bandaid)

       my_project/src/main/OMakefile:
           # Some files include the .h files in ../lib
           INCLUDES += ../lib

           # Indicate which libraries we want to link against.
           # The suffix depends on the platform.  The canonical
           # suffix is defined in $(EXT_LIB).
           LIBS[] +=
               ../lib/libbug$(EXT_LIB)

           # Build the program.
           # Builds horsefly.exe on Win32, and horsefly on Unix.
           # The first argument is the name of the executable.
           # The second argument is an array of object files (without suffix)
           # that are part of the program.
           CProgram(horsefly, horsefly)

           # Build the program by default (in case omake is called
           # without any arguments).  EXE is defined as .exe on Win32,
           # otherwise it is empty.
           .DEFAULT: horsefly$(EXE)


       Most of the configuration here is defined in the file build/C.om (which
       is part of the OMake distribution). This file takes care of  a  lot  of
       work, including:

       *      Defining   the  StaticCLibrary  and  CProgram  functions,  which
              describe the canonical way to build C libraries and programs.

       *      Defining a mechanism for scanning each of the source programs to
              discover dependencies.  That is, it defines .SCANNER rules for C
              source files.

       Variables are inherited down the hierarchy, so for example,  the  value
       of CFLAGS in src/main/OMakefile is ``-g -O2''.


   AN EXAMPLE OCAML PROJECT
       Let's  repeat  the  example,  assuming we are using OCaml instead of C.
       This time, the directory tree looks like this.

           my_project/
           |--> OMakeroot
           |--> OMakefile
           `--> src/
                |---> OMakefile
                |---> lib/
                |     |---> OMakefile
                |     |---> ouch.ml
                |     |---> ouch.mli
                |     `---> bandaid.ml
                `---> main/
                      |---> OMakefile
                      |---> horsefly.ml
                      |---> horsefly.mli
                      `---> main.c


       The listing is only a bit different.

       my_project/OMakeroot:
           # Include the standard configuration for OCaml applications
           open build/OCaml

           # Process the command-line vars
           DefineCommandVars()

           # Include the OMakefile in this directory.
           .SUBDIRS: .

       my_project/OMakefile:
           # Set up the standard configuration
           OCAMLFLAGS += -Wa

           # Do we want to use the bytecode compiler,
           # or the native-code one?  Let's use both for
           # this example.
           NATIVE_ENABLED = true
           BYTE_ENABLED = true

           # Include the src subdirectory
           .SUBDIRS: src

       my_project/src/OMakefile:
           # Include the subdirectories
           .SUBDIRS: lib main

       my_project/src/lib/OMakefile:
           # Let's do aggressive inlining on native code
           OCAMLOPTFLAGS += -inline 10

           # Build the library as a static library.
           # This builds libbug.a on Unix/OSX, or libbug.lib on Win32.
           # Note that the source files are listed _without_ suffix.
           OCamlLibrary(libbug, ouch bandaid)

       my_project/src/main/OMakefile:
           # These files depend on the interfaces in ../lib
           OCAMLINCLUDES += ../lib

           # Indicate which libraries we want to link against.
           # The suffix does not depend on the platform.
           OCAML_LIBS[] +=
               ../lib/libbug

           # Build the program.
           # Builds horsefly.exe on Win32, and horsefly on Unix.
           # The first argument is the name of the executable.
           # The second argument is an array of object files (without suffix)
           # that are part of the program.
           OCamlProgram(horsefly, horsefly)

           # Build the program by default (in case omake is called
           # without any arguments).  EXE is defined as .exe on Win32,
           # otherwise it is empty.
           .DEFAULT: horsefly$(EXE)


       In this case, most of the configuration here is  defined  in  the  file
       build/OCaml.om.    In   this   particular   configuration,   files   in
       my_project/src/lib are compiled aggressively with  the  option  -inline
       10, but files in my_project/src/lib are compiled normally.


REFERENCES
   SEE ALSO
       omake(1),    omake-quickstart(1),    omake-options(1),   omake-root(1),
       omake-language(1),   omake-shell(1),   omake-rules(1),   omake-base(1),
       omake-system(1), omake-pervasives(1), osh(1), make(1)


   VERSION
       Version: 0.9.6.9 of April 11, 2006.


   LICENSE AND COPYRIGHT
       (C)2003-2006, Mojave Group, Caltech

       This program is free software; you can redistribute it and/or modify it
       under the terms of the GNU General Public License as published  by  the
       Free  Software Foundation; either version 2 of the License, or (at your
       option) any later version.

       This program is distributed in the hope that it  will  be  useful,  but
       WITHOUT  ANY  WARRANTY;  without  even  the  implied  warranty  of MER-
       CHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the  GNU  General
       Public License for more details.

       You should have received a copy of the GNU General Public License along
       with this program; if not, write to the Free Software Foundation, Inc.,
       675 Mass Ave, Cambridge, MA 02139, USA.


   AUTHOR
       Jason Hickey et. al..br Caltech 256-80
       Pasadena, CA 91125, USA
       Email: omake-devel@metaprl.org
       WWW: http://www.cs.caltech.edu/~jyh




Build Tools                     April 11, 2006         OMAKE-BUILD-EXAMPLES(1)
