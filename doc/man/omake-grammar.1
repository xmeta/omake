'\" t
.\" Manual page created with latex2man
.\" NOTE: This file is generated, DO NOT EDIT.
.de Vb
.ft CW
.nf
..
.de Ve
.ft R

.fi
..
.TH "OMAKE\-GRAMMAR" "1" "April 11, 2006" "Build Tools " "Build Tools "
.SH NAME

omake
is a flexible build system designed for building a wide variety of projects.
This document describes the language concepts and syntax.
For an overview of omake,
see the
.\"omake.html
omake(1)
man page.
.PP
.SH OMAKE LEXICAL CONVENTIONS

.PP
The OMake language is based on the language for GNU/BSD make, where there are few lexical
conventions. Strictly speaking, there are no keywords, and few special symbols.
.PP
.SS COMMENTS
.PP
Comments begin with the # character and continue to the end\-of\-line.
Text within a comment is unrestricted.
.PP
Examples.
.PP
.Vb
   # This is a comment
   # This $comment contains a quote " character
.Ve
.PP
.SS SPECIAL CHARACTERS
.PP
The following characters are special in some contexts.
.PP
.Vb
   $    (    )    ,    .   =    :    "    '    `    \\    #
.Ve
.PP
.TP
.B *
$ is used to denote a variable reference, or function application.
.TP
.B *
Parentheses ), ( are argument deliminters.
.TP
.B *
The command , is an argument separator.
.TP
.B *
The period symbol \&. is a name separator.
.TP
.B *
The equality symbol = denotes a definition.
.TP
.B *
The colon symbol : is used to denote rules, and (optionally) to indicate
that an expression is followed by an indented body.
.TP
.B *
The quotation symbols " and ' delimit character strings.
.TP
.B *
The symbol # is the first character of a constant.
.TP
.B *
The escape symbol \\ is special \fIonly when\fP followed by another special
character. In this case, the special status of the second character is removed,
and the sequence denotes the second character. Otherwise, the \\ is not special.
.PP
Examples:
.PP
.RS
.TP
.B *
\\$: the $ character (as a normal character).
.TP
.B *
\\#: the # character (as a normal character).
.TP
.B *
\\\\: the \\ character (as a normal character).
.TP
.B *
c\\:\\Windows\\moo\\#boo: the string c:\\Windows\\moo#boo\&.
.RE
.RS
.PP
.RE
.PP
.SS IDENTIFIERS
.PP
Identifiers (variable names) are drawn from the ASCII alphanumeric characters as well as _,
\-, ~, @\&. Case is significant; the following identifiers are distinct:
FOO, Foo, foo\&. The identifier may begin with any of the valid characters,
including digits.
.PP
Using egrep notation, the regular expression for identifiers is defined as follows.
.PP
.Vb
    identifier ::= [\-@~_A\-Za\-z0\-9]+
.Ve
.PP
The following are legal identifiers.
.PP
.Vb
    Xyz    hello_world    seventy@nine
    79\-32  Gnus~Gnats     CFLAGS
.Ve
.PP
The following are not legal identifiers.
.PP
.Vb
    x+y    hello&world
.Ve
.PP
.SS COMMAND IDENTIFIERS
.PP
The following words have special significance when they occur as the \fIfirst\fP
word
of a program line. They are not otherwise special.
.PP
.Vb
    case     catch  class    declare    default
    do       else   elseif   export     extends
    finally  if     import   include    match
    open     raise  return   section    switch
    try      value  when     while
.Ve
.PP
.SS VARIABLE REFERENCES
.PP
A variable reference is denoted with the $ special character followed by an identifier. If
the identifier name has more than one character, it must be enclosed in parentheses. The
parenthesized version is most common. The following are legal variable references.
.PP
.Vb
    $(Xyz)    $(hello_world)   $(seventy@nine)
    $(79\-32)  $(Gnus~Gnats)    $(CFLAGS)
.Ve
.PP
Single\-character references also include several additional identifiers, including &*<^?][\&.
The following are legal single\-character references.
.PP
.Vb
   $@   $&   $*   $<   $^   $+   $?   $[   $]
   $A   $_   $a   $b   $x   $1   $2   $3
.Ve
.PP
Note that a non\-parenthesized variable reference is limited to a single character, even if it is
followed by additional legal identifier charqcters. Suppose the value of the $x variable is
17. The following examples illustrate evaluation.
.PP
.Vb
    $x           evaluates to    17
    foo$xbar     evaluates to    foo17bar
    foo$(x)bar   evaluates to    foo17bar
.Ve
.PP
The special sequence $$ represents the character literal $\&. That is, the
two\-character sequences \\$ and $$ are normally equalivalent.
.PP
.SS STRING CONSTANTS
.PP
Literal strings are defined with matching string delimiters. A left string delimiter begins with
the dollar\-sign $, and a non\-zero number of single\-quote or double\-quote characters. The
string is terminated with a matching sequence of quotation symbols. The delimiter quotation may not
be mixed; it must contain only single\-quote characters, or double\-quote characters. The following
are legal strings.
.PP
[jyh: there is a bug in the formatter where single\-quote pairs are being converted to double\-quotes.
I\&'ve added \\ symbols in these cases to prevent that. This should be considered to be an artifact of
typesetting\-\-the \\ characters \fImust not\fP
be included in code.]
.PP
.Vb
    $'Hello world'
    $"""printf("Hello world\\n")"""
    $'\\'\\'\\'
Large "block" of
text # spanning ''multiple'' lines'\\'\\'\\'
.Ve
.PP
The string delimiters are \fInot\fP
included in the string constant. In the single\-quote form,
the contents of the string are interpreted verbatim\-\-there are no special characters.
.PP
The double\-quote form permits expression evaluation within the string, denoted with the $ symbol.
The following are some examples.
.PP
.Vb
    X = Hello
    Y = $""$X world""             # Hello world
    Z = $'\\'\\'$X world'\\'\\'       # $X world
    I = 3
    W = $"6 > $(add $I, 2)"       # 6 > 5
.Ve
.PP
Note that quotation symbols without a leading $ are not treated specially by OMake. The
quotation symbols is included in the sequence.
.PP
.Vb
    osh>println('Hello world')
    'Hello world'
    osh>println($'Hello world')
    Hello world
    osh>X = Hello
    \- : "Hello" : Sequence
    osh>println('$X world')
    Hello world
.Ve
.PP
.SH THE OMAKE GRAMMAR

.PP
OMake programs are constructed from expressions and statements. Generally, an input program
consists of a sequence of statements, each of which consists of one or more lines. Indentation is
significant\-\-if a statement consists of more than one line, the second and remaining lines (called
the \fIbody\fP)
are usually indented relative to the first line.
.PP
.SS EXPRESSIONS
.PP
The following table lists the syntax for expressions.
.PP
.TS H
l l l .
\fIexpr\fP
	 ::=
	 	 \fI(empty)\fP
	 	 \-\- Text (see note)
	 | 	 \fItext\fP
	 | 	 \fIstring\-literal\fP
	 	 \-\- Applications
	 | 	 \fIdollar\fP
<char>
	 | 	 \fIdollar\fP
( \fIpathid\fP
\fIargs\fP
)
	 	 \-\- Concatenation
	 | 	 \fIexpr\fP
\fIexpr\fP
\fIdollar\fP
	 ::= 	 $ | $` | $,
\fIpathid\fP
	 ::=
	 	 \fIid\fP
	 | 	 \fIpathid\fP
\&. \fIid\fP
\fIarg\fP
	 ::= 	 \fIexpr\fP
\-\- excluding special characters )(,)
\fIargs\fP
	 ::= 	 \fI(empty)\fP
| \fIarg\fP,
\&.\&.\&., \fIarg\fP
.TE
.PP
An \fIexpression\fP
is a sequence composed of text, string\-literals, variables references and
function applications. Text is any sequence of non\-special characters.
.PP
.SS Inline applications
.PP
An \fIapplication\fP
is the application of a function to zero\-or\-more arguments. Inline
applications begin with one of the ``dollar\&'' sequences $, $`, or $,\&. The
application itself is specified as a single character (in which case it is a variable reference), or
it is a parenthesized list including a function identifier \fIpathid\fP,
and zero\-or\-more
comma\-separated arguments \fIargs\fP\&.
The arguments are themselves a variant of the expressions
where the special character )(, are not allowed (though any of these may be made non\-special
with the \\ escape character). The following are some examples of valid expressions.
.PP
.RE
.TP
.B *
xyz abc
.PP
The text sequence ``xyz abc\&''
.PP
.TP
.B *
xyz$wabc
.PP
A text sequence containing a reference to the variable w\&.
.PP
.TP
.B *
$(addsuffix .c, $(FILES))
.PP
An application of the function addsuffix, with first argument \&.c, and second argument $(FILES)\&.
.PP
.TP
.B *
$(a.b.c 12)
.PP
This is a method call. The variable a must evaluate to an object with a field b,
which must be an object with a method c\&. This method is called with argument 12\&.
.PP
The additional dollar sequences specify evaluation order, $` (lazy) and $, (eager), as
discussed in
.\"#dollar
the section on dollar modifiers\&.
.PP
.SS STATEMENTS AND PROGRAMS
.PP
The following table lists the syntax of statements and programs.
.PP
.TS H
l l l .
\fIparams\fP
	 ::= 	 \fI(empty)\fP
| \fIid\fP,
\&.\&.\&., \fIid\fP
\fItarget\fP
	 ::= 	 \fIexpr\fP
\-\- excluding special character :
\fIprogram\fP
	 ::= 	 \fIstmt\fP
<eol> \&.\&.\&. <eol> \fIstmt\fP
\fIstmt\fP
	 ::=
	 	 \-\- Special forms
	 | 	 command
\fIexpr\fP
\fIoptcolon\-body\fP
	 | 	 command
( \fIargs\fP
) \fIoptcolon\-body\fP
	 | 	 catch
\fIid\fP
( \fIid\fP
) \fIoptcolon\-body\fP
	 | 	 class
\fIid\fP
\&.\&.\&. \fIid\fP
	 	 \-\- Variable definitions
	 | 	 \fIpathid\fP
{+}= \fIexpr\fP
	 | 	 \fIpathid\fP
{+}= <eol> \fIindented\-body\fP
	 | 	 \fIpathid\fP
[] {+}= \fIexpr\fP
	 | 	 \fIpathid\fP
[] {+}= <eol> \fIindented\-exprs\fP
	 	 \-\- Functions
	 | 	 \fIpathid\fP(\fIargs\fP)
\fIoptcolon\-body\fP
	 | 	 \fIpathid\fP(\fIparams\fP)
= <eol> \fIindented\-body\fP
	 	 \-\- Objects
	 | 	 \fIpathid\fP
\&. {+}= <eol> \fIindented\-body\fP
	 	 \-\- Rules
	 | 	 \fItarget\fP
:
\fItarget\fP
\fIrule\-options\fP
<eol> \fIindented\-body\fP
	 | 	 \fItarget\fP
::
\fItarget\fP
\fIrule\-options\fP
<eol> \fIindented\-body\fP
	 | 	 \fItarget\fP
:
\fItarget\fP
:
\fItarget\fP
\fIrule\-options\fP
<eol> \fIindented\-body\fP
	 | 	 \fItarget\fP
::
\fItarget\fP
:
\fItarget\fP
\fIrule\-options\fP
<eol> \fIindented\-body\fP
	 	 \-\- Shell commands
	 | 	 \fIexpr\fP
\fIindented\-body\fP
	 ::= 	 \fI(empty)\fP
	 | 	 \fIindented\-stmt\fP
<eol> \&.\&.\&. <eol> \fIindented\-stmt\fP
\fIindented\-exprs\fP
	 ::= 	 \fI(empty)\fP
	 | 	 \fIindented\-expr\fP
<eol> \&.\&.\&. <eol> \fIindented\-expr\fP
\fIoptcolon\-body\fP
	 ::= 	 \fI(empty)\fP
	 | 	 <eol> \fIindented\-body\fP
	 | 	 :
<eol> \fIindented\-body\fP
\fIrule\-option\fP
	 ::= 	 \fI:id:\fP
\fItarget\fP
\fIrule\-options\fP
	 ::= 	 \fI(empty)\fP
	 | 	 \fIrule\-options\fP
\fIrule\-option\fP
.TE
.PP
.SS Special forms
.PP
The special forms include the following.
.PP
\fBConditionals\fP
(see
.\"omake\-language.html#conditionals
Conditionals).
The if command
should be followed by an expression that represents the condition, and an indented body. The
conditional may be followed by elseif and else blocks.
.PP
.Vb
    if expr
        indented\-body
    elseif expr
        indented\-body
    ...
    else
        indented\-body
.Ve
.PP
\fBmatching\fP
(see
.\"omake\-language.html#matching
Matching).
The switch and
match commands perform pattern\-matching. All cases are optional. Each case may include
when clauses that specify additional matching conditions.
.PP
.Vb
    match(expr)
    case expr
       indented\-body
    when expr
       indented\-body
    ...
    case expr
       indented\-body
    default
       indented\-body
.Ve
.PP
\fBExceptions\fP
(see
.\"omake\-language.html#exceptions
Exceptions).
The try command
introduces an exception handler. Each name is the name of a class. All cases, including
catch, default, and finally are optional. The catch and default
clauses contain optional when clauses.
.PP
.Vb
    try
        indented\-body
    catch name1(id1)
        indented\-body
    when expr
        indented\-body
    ...
    catch nameN(idN)
        indented\-body
    default
        indented\-body
    finally
        indented\-body
.Ve
.PP
The raise command is used to raise an exception.
.PP
.Vb
    raise expr
.Ve
.PP
\fBsection\fP
(see
.\"omake\-language.html#section
Sections).
The section command
introduces a new scope.
.PP
.Vb
    section
        indented\-body
.Ve
.PP
\fBinclude, open\fP
(see
.\"omake\-language.html#include
Include).
The include command
performs file inclusion. The expression should evaluate to a file name.
.PP
The open form is like include, but it performs the inclusion only if the inclusion has not
already been performed. The open form is usually used to include library files. [jyh\-\- this
behavior will change in subsequent revisions.]
.PP
.Vb
    include expr
    open expr
.Ve
.PP
\fBreturn\fP
(see
.\"omake\-language.html#functions
Return).
The return command
terminates execution and returns a value from a function.
.PP
.Vb
    return expr
.Ve
.PP
\fBvalue\fP
(see
.\"omake\-language#functions
Value).
The value command is an identity.
Syntactically, it is used to coerce a n expression to a statement.
.PP
.Vb
    value expr
.Ve
.PP
\fBexport\fP
(See
.\"omake\-language.html#export
Export).
The export command exports
a environment from a nested block. If no identifiers are specified, the entire environment is exported.
Otherwise, the export is limited to the specified identifiers.
.PP
.Vb
    export id ... id
.Ve
.PP
\fBwhile\fP
(See
.\"omake\-base.html#while
While).
The while command introduces a while loop.
.PP
.Vb
    while expr
        indented\-body
.Ve
.PP
\fBclass, extends\fP
(See
.\"omake\-language.html#objects
Objects).
The class command
specifies an identifier for an object. The extends command specifies a parent object.
.PP
.Vb
    class id
    extends expr
.Ve
.PP
.SS Variable definitions
.PP
See
.\"omake\-language.html#variables
Variables\&.
The simplest variable definition has the
following syntax. The = form is a new definition. The += form appends the value to
an existing definition.
.PP
.Vb
    id = expr
    id += expr

    osh> X = 1
    \- : "1" : Sequence
    osh> X += 7
    \- : "1" " " "7" : Sequence
.Ve
.PP
A multi\-line form is allowed, where the value is computed by an indented body.
.PP
.Vb
    id {+}=
        indented\-body

    osh> X =
             Y = HOME
             println(Y is $Y)
             getenv($Y)
    Y is HOME
    \- : "/home/jyh" : Sequence
.Ve
.PP
The name may be qualified qith one of the public, prtected, or private
modifiers. Public variables are dynamically scoped. Protected variables are fields in the current
object. Private variables are statically scoped.
.PP
[jyh: revision 0.9.9 introduces modular namespaces; the meaning of these qualifiers is slightly changed.]
.PP
.Vb
    public.X = $(addsuffix .c, 1 2 3)
    protected.Y = $(getenv HOME)
    private.Z = $"Hello world"
.Ve
.PP
.SS Applications and function definitions
.PP
See
.\"omake\-language.html#functions
Functions\&.
A function\-application statement is specified as a
function name, followed a parenthesized list of comma\-separated arguments.
.PP
.Vb
    osh> println($"Hello world")

    osh> FILES = 1 2 3
    \- : 1 2 3
    osh> addsuffix(.c, $(FILES))
    \- : 1.c 2.c 3.c

    # The following forms are equivalent
    osh> value $(println $"Hello world")
    osh> value $(addsuffix .c, $(FILES))
    \- : 1.c 2.c 3.c
.Ve
.PP
If the function application has a body, the body is passed (lazily) to the function as its first
argument. [jyh: in revision 0.9.8 support is incomplete.] When using osh, the application
must be followed by a colon : to indicate that the application has a body.
.PP
.Vb
    # In its 3\-argument form, the foreach function takes
    # a body, a variable, and an array.  The body is evaluated
    # for each element of the array, with the variable bound to
    # the element value.
    #
    # The colon is required only for interactive sessions.
    osh> foreach(x, 1 2 3):
            add($x, 1)
    \- : 2 3 4
.Ve
.PP
Functions are defined in a similar form, where the parameter list is specified as a comma\-separated
list of identifiers, and the body of the function is indented.
.PP
.Vb
    osh> f(i, j) =
            add($i, $j)
    \- : <fun 2>
    osh> f(3, 7)
    \- : 10 : Int
.Ve
.PP
.SS Objects
.PP
See
.\"omake\-language.html#objects
Objects\&.
Objects are defined as an identifier with a
terminal period. The body of the object is indented.
.PP
.Vb
    Obj. =
        class Obj

        X = 1
        Y = $(sub $X, 12)
        new(i, j) =
           X = $i
           Y = $j
           value $(this)
        F() =
           add($X, $Y)
        println($Y)
.Ve
.PP
The body of the object has the usual form of an indented body, but new variable definitions are
added to the object, not the global environment. The object definition above defines an object with
(at least) the fields X and Y, and methods new and F\&. The name of the
object is defined with the class command as Obj\&.
.PP
The Obj itself has fields X = 1 and Y = \-11\&. The new method has the
typical form of a constructor\-style method, where the fields of the object are initialized to new
values, and the new object returned ($(this) refers to the current object).
.PP
The F method returns the sum of the two fields X and Y\&.
.PP
When used in an object definition, the += form adds the new definitions to an existing object.
.PP
.Vb
   pair. =
      x = 1
      y = 2

   pair. +=
      y = $(add $y, 3)
   # pair now has fields (x = 1, and y = 5)
.Ve
.PP
The extends form specifies inheritance. Multiple inheritance is allowed. At evaluation
time, the extends directive performs inclusion of the entire parent object.
.PP
.Vb
   pair. =
      x = 1
      y = 2

   depth. =
      z = 3
      zoom(dz) =
         z = $(add $z, $(dz))
         return $(this)

   triple. =
      extends $(pair)
      extends $(depth)

      crazy() =
         zoom($(mul $x, $y))
.Ve
.PP
In this example, the triple object has three fields x, y, and z; and two methods zoom
and crazy\&.
.PP
.SS Rules
.PP
See
.\"omake\-rules.html#rules
Rules\&.
A rule has the following parts.
.TP
1.
A sequence of targets;
.TP
2.
one or two colons;
.TP
3.
a sequence of \fIdependencies\fP and \fIrule options\fP;
.TP
4.
and an indented body.
.PP
The targets are the files to be built, and the dependencies are the files it depends on. If two
colons are specified, it indicates that there may be multiple rules to build the given targets;
otherwise only one rule is allowed.
.PP
If the target contains a % character, the rule is called \fIimplicit\fP,
and is considered
whenever a file matching that pattern is to be built. For example, the following rule specifies a
default rule for compiling OCaml files.
.PP
.Vb
    %.cmo: %.ml %.mli
       $(OCAMLC) \-c $<
.Ve
.PP
This rule would be consulted as a default way of building any file with a \&.cmo suffix. The
dependencies list is also constructed based on the pattern match. For example, if this rule were
used to build a file foo.cmo, then the dependency list would be foo.ml foo.mli\&.
.PP
There is also a three\-part version of a rule, where the rule specification has three parts.
.PP
.Vb
    targets : pattern : dependencies rule\-options
       indented\-body
.Ve
.PP
In this case, the pattern \fImust\fP
contain a single % character. However this is
considered to be a sequence of \fIexplicit\fP
rules, where each target is matched against the
pattern, and a new rule is computed based on the pattern match. For example, the following rule
specifies how to build the explicit targets a.cmo and b.cmo\&.
.PP
.Vb
    a.cmo b.cmo: %.cmo: %.ml %.mli
       $(OCAMLC) \-c $<
.Ve
.PP
This example is equivalent to the following two\-rule sequence.
.PP
.Vb
    a.cmo: a.ml a.mli
       $(OCAMLC) \-c $<
    b.cmo: b.ml b.mli
       $(OCAMLC) \-c $<
.Ve
.PP
There are several special targets, including the following.
.PP
.TP
.B *
\&.PHONY : declare a ``phony\&'' target. That is, the target does not correspond to a file.
.TP
.B *
\&.ORDER : declare a rule for dependency ordering.
.TP
.B *
\&.INCLUDE : define a rule to generate a file for textual inclusion.
.TP
.B *
\&.SUBDIRS : specify subdirectories that are part of the project.
.TP
.B *
\&.SCANNER : define a rule for dependency scanning.
.PP
There are several rule options.
.PP
.TP
.B *
:optional: dependencies the subsequent dependencies are optional, it is acceptable if they do not exist.
.TP
.B *
:exists: dependencies the subsequent dependencies must exist, but changes to not affect
whether this rule is considered out\-of\-date.
.TP
.B *
:effects: targets the subsequent files are side\-effects of the rule. That is, they may be
created and/or modified while the rule is executing. Rules with overlapping side\-effects are never
executed in parallel.
.TP
.B *
:scanner: name the subsequent name is the name of the \&.SCANNER rule for the target to be built.
.TP
.B *
:value: expr the expr is a ``value\&'' dependency. The rule is considered
out\-of\-date whenever the value of the expr changes.
.PP
Several variables are defined during rule evaluation.
.PP
.TP
.B *
$* : the name of the target with the outermost suffix removed.
.TP
.B *
$> : the name of the target with all suffixes removed.
.TP
.B *
$@ : the name of the target.
.TP
.B *
$^ : the explicit file dependencies, sorted alphabetically, with duplicates removed.
.TP
.B *
$+ : all explicit file dependencies, with order preserved.
.TP
.B *
$< : the first explicit file dependency.
.TP
.B *
$& : the free values of the rule (often used in :value: dependencies).
.PP
.SS Shell commands
.PP
See
.\"omake\-shell.html#shell
Shell\&.
.PP
While it is possible to give a precise specification of shell commands, the informal description is
simpler. Any non\-empty statement where each prefix is \fInot\fP
one of the other statements, is
considered to be a shell command. Here are some examples.
.PP
.Vb
    ls                                 \-\- shell command
    echo Hello world > /dev/null       \-\- shell command
    echo(Hello world)                  \-\- function application
    echo(Hello world) > /dev/null      \-\- syntax error
    echo Hello: world                  \-\- rule
    X=1 getenv X                       \-\- variable definition
    env X=1 getenv X                   \-\- shell command
    if true                            \-\- special form
    \\if true                           \-\- shell command
    "if" true                          \-\- shell command
.Ve
.PP
.\"dollar

.SH DOLLAR MODIFIERS

.PP
Inline applications have a function and zero\-or\-more arguments. Evaluation is normally strict: when
an application is evaluated, the function identifier is evaluated to a function, the arguments are
then evaluated and the function is called with the evaluated arguments.
.PP
The additional ``dollar\&'' sequences specify additional control over evaluation. The token $`
defines a ``lazy\&'' application, where evaluation is delayed until a value is required. The
$, sequence performs an ``eager\&'' application within a lazy context.
.PP
To illustrate, consider the expression $(addsuffix .c, $(FILES))\&. The addsuffix
function appends its first argument to each value in its second argument. The following osh
interaction demonstrates the normal bahavior.
.PP
.Vb
osh> FILES[] = a b c
\- : <array a b c>
osh> X = $(addsuffix .c, $(FILES))
\- : <array ...>
osh> FILES[] = 1 2 3 # redefine FILES
\- : <array 1 2 3>
osh> println($"$X")  # force the evaluation and print
a.c b.c c.c
.Ve
.PP
When the lazy operator $` is used instead, evaluation is delayed until it is printed. In the
following sample, the value for X has changed to the $(apply ..) form, but otherwise
the result is unchanged because it it printed immediately.
.PP
.Vb
osh> FILES[] = a b c
\- : <array a b c>
osh> SUF = .c
\- : ".c"
osh> X = $`(addsuffix $(SUF), $(FILES))
\- : $(apply global.addsuffix ...)
osh> println($"$X")  # force the evaluation and print
a.c b.c c.c
.Ve
.PP
However, consider what happens if we redefine the FILES variable after the definition for
X\&. In the following sample, the result changes because evaluation occurs \fIafter\fP
the
values for FILES has been redefined.
.PP
.Vb
osh> FILES[] = a b c
\- : <array a b c>
osh> SUF = .c
\- : ".c"
osh> X = $`(addsuffix $(SUF), $(FILES))
\- : $(apply global.addsuffix ...)
osh> SUF = .x
osh> FILES[] = 1 2 3
osh> println($"$X")  # force the evaluation and print
1.x 2.x 3.x
.Ve
.PP
In some cases, more explicit control is desired over evaluation. For example, we may wish to
evaluate SUF early, but allow for changes to the FILES variable. The $,(SUF)
expression forces early evaluation.
.PP
.Vb
osh> FILES[] = a b c
\- : <array a b c>
osh> SUF = .c
\- : ".c"
osh> X = $`(addsuffix $,(SUF), $(FILES))
\- : $(apply global.addsuffix ...)
osh> SUF = .x
osh> FILES[] = 1 2 3
osh> println($"$X")  # force the evaluation and print
1.c 2.c 3.c
.Ve
.PP
.SH REFERENCES

.PP
.SS SEE ALSO
.PP
.\"omake.html
omake(1),
.\"omake\-quickstart.html
omake\-quickstart(1),
.\"omake\-options.html
omake\-options(1),
.\"omake\-root.html
omake\-root(1),
.\"omake\-language.html
omake\-language(1),
.\"omake\-shell.html
omake\-shell(1),
.\"omake\-rules.html
omake\-rules(1),
.\"omake\-base.html
omake\-base(1),
.\"omake\-system.html
omake\-system(1),
.\"omake\-pervasives.html
omake\-pervasives(1),
.\"osh.html
osh(1),
\fImake\fP(1)
.PP
.SS VERSION
.PP
Version: 0.9.6.9 of April 11, 2006\&.
.PP
.SS LICENSE AND COPYRIGHT
.PP
(C)2003\-2006, Mojave Group, Caltech
.PP
This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.
.PP
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.
.PP
You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
.PP
.SS AUTHOR
.PP
Jason Hickey \fIet. al.\fP.br
Caltech 256\-80
.br
Pasadena, CA 91125, USA
.br
Email: \fBomake\-devel@metaprl.org\fP
.br
WWW: \fBhttp://www.cs.caltech.edu/~jyh\fP
.PP
.\" NOTE: This file is generated, DO NOT EDIT.
