OMAKE-LANGUAGE-EXAMPLES(1)       Build Tools        OMAKE-LANGUAGE-EXAMPLES(1)



NAME
       omake  is  a flexible build system designed for building a wide variety
       of projects.  This document describes the language concepts and syntax.
       For an overview of omake, see the omake(1) man page.


LANGUAGE EXAMPLES
       In  this  section,  we'll explore the core language through a series of
       examples (examples of the build system are the topic of Section Build).

       For  most of these examples, we'll use the osh command interpreter. For
       simplicity, the values printed by osh have been abbreviated.


   STRINGS AND ARRAYS
       The basic OMake values are strings, sequences, and  arrays  of  values.
       Sequences  are  like  arrays  of  values  separated  by whitespace; the
       sequences are split on demand by functions that expect arrays.

          osh> X = 1 2
          - : "1 2" : Sequence
          osh> addsuffix(.c, $X)
          - : <array 1.c 2.c> : Array


       Sometimes you want to define an array explicitly. For this, use the  []
       brackets after the variable name, and list each array entry on a single
       indented line.

          osh> A[] =
                  Hello world
                  $(getenv HOME)
          - : <array "Hello world" "/home/jyh"> : Array


       One central property of arrays is that whitespace in  the  elements  is
       significant.  This can be useful, especially for filenames that contain
       whitespace.

          # List the current files in the directory
           osh> ls -Q
           "fee"  "fi"  "foo"  "fum"
           osh> NAME[] =
                   Hello world
           - : <array "Hello world"> : Array
           osh> touch $(NAME)
           osh> ls -Q
           "fee"  "fi"  "foo"  "fum"  "Hello world"



   FILES AND DIRECTORIES
       OMake projects usually span multiple directories, and  different  parts
       of  the  project  execute commands in different directories. There is a
       need to define a location-independent name for a file or directory.

       This is done with the $(file <names>) and $(dir <names>) functions.

          osh> mkdir tmp
          osh> F = $(file fee)
          osh> section:
                   cd tmp
                   echo $F
          ../fee
          osh> echo $F
          fee


       Note the use of a section: to limit the scope of the  cd  command.  The
       section  temporarily changes to the tmp directory where the name of the
       file is ../fee. Once the section completes, we are still in the current
       directory, where the name of the file is fee.

       One common way to use the file functions is to define proper file names
       in your project OMakefile, so that references within the various  parts
       of the project will refer to the same file.

           osh> cat OMakefile
           ROOT = $(dir .)
           TMP  = $(dir tmp)
           BIN  = $(dir bin)
           ...



   ITERATION, MAPPING, AND FOREACH
       Most builtin functions operate transparently on arrays.

           osh> addprefix(-D, DEBUG WIN32)
           - : -DDEBUG -DWIN32 : Array
           osh> mapprefix(-I, /etc /tmp)
           - : -I /etc -I /tmp : Array
           osh> uppercase(fee fi foo fum)
           - : FEE FI FOO FUM : Array


       The  mapprefix  and  addprefix  functions  are  slightly different (the
       addsuffix and mapsuffix functions are similar). The addprefix adds  the
       prefex  to  each array element. The mapprefix doubles the length of the
       array, adding the prefix as a new array  element  before  each  of  the
       original elements.

       Even  though  most  functions  work on arrays, there are times when you
       will want to do it yourself.  The foreach function is the  way  to  go.
       The  foreach  function  has two forms, but the form with a body is most
       useful. The function takes two arguments and a body. The  second  argu-
       ment  is  an  array, and the first is a variable. The body is evaluated
       once for each element of the array, where the variable is bound to  the
       element.  Let's  define a function to add 1 to each element of an array
       of numbers.

          osh> add1(l) =
                   foreach(i, $l):
                       add($i, 1)
          osh> add1(7 21 75)
          - : 8 22 76 : Array


       Sometimes you have an array of filenames, and you want to define a spe-
       cial rule for each of them.  Rules are not special, you can define them
       anywhere a statement is expected. Say we want to write  a  function  to
       process each file, and place the result in the TMP directory.

          TMP = $(dir tmp)
          ...
          my-special-rule(files) =
             foreach(name, $(files))
                tmp/$(name): $(name)
                   process $< > $@



   LAZY EXPRESSIONS
       Lazy  expressions  are  expressions  that are not evaluated until their
       result is needed. Some people, including this author, frown on  overuse
       of lazy expressions, mainly because it is difficult to know when evalu-
       ation actually happens. However, there are cases where they pay off.

       One example comes from option processing. Consider the specification of
       ``include''  directories  on  the  command line for a C compiler. If we
       want to include files from /home/jyh/include and ../foo, we specify  it
       on the command line with the options -I/home/jyh/include -I../foo.

       Suppose we want to define a generic rule for building C files. We could
       define a INCLUDES array to specify the directories to be included,  and
       then define a generic implicit rule in our root OMakefile.

           # Generic way to compile C files.
           CFLAGS = -g
           INCLUDES[] =
           %.o: %.c
              $(CC) $(CFLAGS) $(INCLUDES) -c $<

           # The src directory builds my_widget+ from 4 source files.
           # It reads include files from the include directory.
           .SUBDIRS: src
               FILES = fee fi foo fum
               OFILES = $(addsuffix .o, $(FILES))
               INCLUDES[] += -I../include
               my_widget: $(OFILES)
                  $(CC) $(CFLAGS) -o $@ $(OFILES)


       But  this  is not quite right. The problem is that INCLUDES is an array
       of options, not directories.  If we later wanted to recover the  direc-
       tories,  we  would have to strip the leading -I prefix, which is a has-
       sle. Furthermore, we aren't using proper names for the directories. The
       solution  here  is to use a lazy expression. We'll define INCLUDES as a
       directory array, and a new variable PREFIXED_INCLUDES that adds the  -I
       prefix.  The  PREFIXED_INCLUDES  is  computed lazily, ensuring that the
       value uses the most recent value of the INCLUDES variable.

           # Generic way to compile C files.
           CFLAGS = -g
           INCLUDES[] =
           PREFIXED_INCLUDES[] = $`(addprefix -I, $(INCLUDES))
           %.o: %.c
              $(CC) $(CFLAGS) $(PREFIXED_INCLUDES) -c $<

           # For this example, we define a proper name for the include directory
           STDINCLUDE = $(dir include)

           # The src directory builds my_widget+ from 4 source files.
           # It reads include files from the include directory.
           .SUBDIRS: src
               FILES = fee fi foo fum
               OFILES = $(addsuffix .o, $(FILES))
               INCLUDES[] += $(STDINCLUDE)
               my_widget: $(OFILES)
                  $(CC) $(CFLAGS) -o $@ $(OFILES)


       Note that there is a close connection between  lazy  values  and  func-
       tions.  In  the  example  above,  we  could  equivalently  define  PRE-
       FIXED_INCLUDES as a function with zero arguments.

           PREFIXED_INCLUDES() =
               addprefix(-I, $(INCLUDES))



   SCOPING AND EXPORTS
       The OMake language is functional (apart from IO  and  shell  commands).
       This  comes  in two parts: functions are first-class, and variables are
       immutable (there is no assignment operator). The  latter  property  may
       seem  strange  to  users used to GNU make, but it is actually a central
       point of OMake. Since variables can't be modified, it is impossible (or
       at least hard) for one part of the project to interfere with another.

       To  be sure, pure functional programming can be awkward. In OMake, each
       new indentation level introduces a new scope, and  new  definitions  in
       that  scope  are  lost when the scope ends. If OMake were overly strict
       about scoping, we would wind up with a lot of convoluted code.

          osh> X = 1
          osh> setenv(BOO, 12)
          osh> if $(equal $(OSTYPE), Win32)
                   setenv(BOO, 17)
                   X = 2
          osh> println($X $(getenv BOO))
          1 12


       The export command presents a way out. It takes care of ``exporting'' a
       value  (or  the  entire variable environment) from an inner scope to an
       outer one.

          osh> X = 1
          osh> setenv(BOO, 12)
          osh> if $(equal $(OSTYPE), Win32)
                   setenv(BOO, 17)
                   X = 2
                   export
          osh> println($X $(getenv BOO))
          2 17


       Exports are especially useful in loop to export values from one  itera-
       tion of a loop to the next.

          # Ok, let's try to add up the elements of the array
          osh>sum(l) =
                  total = 0
                  foreach(i, $l)
                      total = $(add $(total), $i)
                  value $(total)
          osh>sum(1 2 3)
          - : 0 : Int

          # Oops!
          osh>sum(l) =
                  total = 0
                  foreach(i, $l)
                      total = $(add $(total), $i)
                      export
                  value $(total)
          osh>sum(1 2 3)
          - : 6 : Int


       A while loop is another form of loop, with an auto-export.

           osh>i = 0
           osh>total = 0
           osh>while $(lt $i, 10)
                   total = $(add $(total), $i)
                   i = $(add $i, 1)
                   export
           osh>println($(total))
           45



   SHELL ALIASES
       Sometimes  you  may want to define an alias, an OMake command that mas-
       querades as a real shell command. You can do this by adding your  func-
       tion as a method to the Shell object.

       For an example, suppose we define builtin awk function to print out all
       the comments in a file.

           osh>cat comment.om
           # Comment function
           comments(filename) =
               awk($(filename))
               case $'^#'
                   println($0)
           # File finished
           osh>include comment
           osh>comments(comment.om)
           # Comment function
           # File finished


       To add it as an alias, add the method (using += to preserve the  exist-
       ing entries in the Shell).

          osh>Shell. +=
                  printcom(argv) =
                      comments($(nth 0, $(argv)))
          osh>printcom comment.om > output.txt
          osh>cat output.txt
          # Comment function
          # File finished


       A  shell  command  is  passed  an array of argument argv. This does not
       include the name of the alias.


   INPUT/OUTPUT REDIRECTION ON THE CHEAP
       As it turns out, scoping also provides a nice alternate way to  perform
       redirection. Suppose you have already written a lot of code that prints
       to the standard output channel, but now you decide you want to redirect
       it. One way to do it is using the alias method of the previous example:
       define your function as an alias, and then  use  shell  redirection  to
       place the output where you want.

       There  is  an  alternate method that is easier in some cases. The vari-
       ables stdin, stdout, and stderr define the standard  I/O  channels.  To
       redirect  output,  redefine  these variables as you see fit. Of course,
       you would normally do this in a nested scope, so that the  outer  chan-
       nels are not affected.

           osh>f() =
                   println(Hello world)
           osh>f()
           Hello world
           osh>section:
                   stdout = $(fopen output.txt, w)
                   f()
                   close($(stdout))
           osh>cat output.txt
           Hello world


       This  also works for shell commands. If you like to gamble, you can try
       the following example.

           osh>f() =
                   println(Hello world)
           osh>f()
           Hello world
           osh>section:
                   stdout = $(fopen output.txt, w)
                   f()
                   cat output.txt
                   close($(stdout))
           osh>cat output.txt
           Hello world
           Hello world



REFERENCES
   SEE ALSO
       omake(1),   omake-quickstart(1),    omake-options(1),    omake-root(1),
       omake-language(1),   omake-shell(1),   omake-rules(1),   omake-base(1),
       omake-system(1), omake-pervasives(1), osh(1), make(1)


   VERSION
       Version: 0.9.6.9 of April 11, 2006.


   LICENSE AND COPYRIGHT
       (C)2003-2006, Mojave Group, Caltech

       This program is free software; you can redistribute it and/or modify it
       under  the  terms of the GNU General Public License as published by the
       Free Software Foundation; either version 2 of the License, or (at  your
       option) any later version.

       This  program  is  distributed  in the hope that it will be useful, but
       WITHOUT ANY  WARRANTY;  without  even  the  implied  warranty  of  MER-
       CHANTABILITY  or  FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
       Public License for more details.

       You should have received a copy of the GNU General Public License along
       with this program; if not, write to the Free Software Foundation, Inc.,
       675 Mass Ave, Cambridge, MA 02139, USA.


   AUTHOR
       Jason Hickey et. al..br Caltech 256-80
       Pasadena, CA 91125, USA
       Email: omake-devel@metaprl.org
       WWW: http://www.cs.caltech.edu/~jyh




Build Tools                     April 11, 2006      OMAKE-LANGUAGE-EXAMPLES(1)
