'\" t
.\" Manual page created with latex2man
.\" NOTE: This file is generated, DO NOT EDIT.
.de Vb
.ft CW
.nf
..
.de Ve
.ft R

.fi
..
.TH "OMAKE\-RULES" "1" "April 11, 2006" "Build Tools " "Build Tools "
.SH NAME

omake
is a flexible build system designed for building a wide variety of projects.
This document describes the syntax and semantics of rule definitions, which specify
commands to build files in a project.
For an overview of omake,
see the
.\"omake.html
omake(1)
man page.
.PP
.SH RULES

.PP
Rules are used by OMake to specify how to build files. At its simplest, a rule has the following
form.
.PP
.Vb
    <target>: <dependencies>
        <commands>
.Ve
.PP
The <target> is the name of a file to be built. The <dependencies> are a list of
files that are needed before the <target> can be built. The <commands> are a list of
indented lines specifying commands to build the target. For example, the following rule specifies
how to compile a file hello.c\&.
.PP
.Vb
    hello.o: hello.c
        $(CC) $(CFLAGS) \-c \-o hello.o hello.c
.Ve
.PP
This rule states that the hello.o
file depends on the hello.c
file. If the
hello.c
file has changed, the command $(CC) $(CFLAGS) \-c \-o hello.o hello.c is to
be executed to update the target file hello.o\&.
.PP
A rule can have an arbitrary number of commands. The individual command lines are executed
independently by the command shell. The commands do not have to begin with a tab, but they must be
indented from the dependency line.
.PP
In addition to normal variables, the following special variables may be used in the body of a rule.
.PP
.TP
.B *
$*: the target name, without a suffix.
.TP
.B *
$@: the target name.
.TP
.B *
$^: a list of the sources, in alphabetical order, with
duplicates removed.
.TP
.B *
$+: all the sources, in the original order.
.TP
.B *
$<: the first source.
.PP
For example, the above hello.c rule may be simplified as follows.
.PP
.Vb
    hello.o: hello.c
        $(CC) $(CFLAGS) \-c \-o $@ $<
.Ve
.PP
Unlike normal values, the variables in a rule body are expanded lazily, and binding is dynamic. The
following function definition illustrates some of the issues.
.PP
.Vb
    CLibrary(name, files) =
        OFILES = $(addsuffix .o, $(files))

        $(name).a: $(OFILES)
            $(AR) cq $@ $(OFILES)
.Ve
.PP
This function defines a rule to build a program called $(name) from a list of \&.o
files. The files in the argument are specified without a suffix, so the first line of the function
definition defines a variable OFILES that adds the \&.o suffix to each of the file
names. The next step defines a rule to build a target library $(name).a from the
$(OFILES) files. The expression $(AR) is evaluated when the function is called, and
the value of the variable AR is taken from the caller\&'s scope (see also the section on
Scoping).
.PP
.SS IMPLICIT RULES
.PP
Rules may also be implicit. That is, the files may be specified by wildcard patterns.
The wildcard character is %\&. For example, the following rule specifies a default
rule for building \&.o files.
.PP
.Vb
    %.o: %.c
        $(CC) $(CFLAGS) \-c \-o $@ $*.c
.Ve
.PP
This rule is a template for building an arbitrary \&.o file from
a \&.c file.
.PP
By default, implicit rules are only used for the targets in the current
directory. However subdirectories included via the \&.SUBDIRS rules
inherit all the implicit rules that are in scope (see also the section on
Scoping).
.PP
.SS BOUNDED IMPLICIT RULES
.PP
Implicit rules may specify the set of files they apply to. The following syntax is used.
.PP
.Vb
    <targets>: <pattern>: <dependencies>
        <commands>
.Ve
.PP
For example, the following rule applies only to the files a.o and b.o\&.
.PP
.Vb
   a.o b.o: %.o: %.c
        $(CC) $(CFLAGS) \-DSPECIAL \-c $*.c
.Ve
.PP
.SS SECTION
.PP
Frequently, the commands in a rule body are expressions to be evaluated by the shell. omake
also allows expressions to be evaluated by omake
itself.
.PP
The syntax of these ``computed rules\&'' uses the section expression. The following rule uses
the omake
IO functions to produce the target hello.c\&.
.PP
.Vb
    hello.c:
        section
            FP = fopen(hello.c, w)
            fprintln($(FP), $""#include <stdio.h> int main() { printf("Hello world\\n"); }"")
            close($(FP))
.Ve
.PP
This example uses the quotation $""..."" to quote the text being printed. These quotes are
not included in the output file. The fopen, fprintln, and close functions
perform file IO as discussed in the IO section.
.PP
In addition, commands that are function calls, or special expressions, are interpreted correctly.
Since the fprintln function can take a file directly, the above rule can be abbreviated as
follows.
.PP
.Vb
    hello.c:
       fprintln($@, $""#include <stdio.h> int main() { printf("Hello world\\n"); }"")
.Ve
.PP
.SS SECTION RULE
.PP
Rules can also be computed using the section rule form, where a rule body is expected instead
of an expression. In the following rule, the file a.c is copied onto the hello.c file
if it exists, otherwise hello.c is created from the file default.c\&.
.PP
.Vb
    hello.c:
        section rule
           if $(target\-exists a.c)
              hello.c: a.c
                 cat a.c > hello.c
           else
              hello.c: default.c
                 cp default.c hello.c
.Ve
.PP
.SH SPECIAL DEPENDENCIES

.PP
.SS :EXISTS:
.PP
In some cases, the contents of a dependency do not matter, only whether the file exists or not. In
this case, the :exists: qualifier can be used for the dependency.
.PP
.Vb
    foo.c: a.c :exists: .flag
       if $(test \-e .flag)
           $(CP) a.c $@
.Ve
.PP
.SS :EFFECTS:
.PP
Some commands produce files by side\-effect. For example, the
\fIlatex\fP(1)
command produces a \&.aux file as a side\-effect of
producing a \&.dvi file. In this case, the :effects:
qualifier can be used to list the side\-effect explicitly.
omake
is careful to avoid simultaneously running programs that
have overlapping side\-effects.
.PP
.Vb
    paper.dvi: paper.tex :effects: paper.aux
        latex paper
.Ve
.PP
.SS :VALUE:
The :value: dependency is used to specify that the rule execution depends on the value of an
expression. For example, the following rule
.PP
.Vb
    a: b c :value: $(X)
        ...
.Ve
.PP
specifies that ``a\&'' should be recompiled if the value of $(X) changes
(X does not have to be a filename). This is intended to allow greater
control over dependencies.
.PP
In addition, it can be used instead of other kinds of dependencies. For example,
the following rule:
.PP
.Vb
    a: b :exists: c
        commands
.Ve
.PP
is the same as
.PP
.Vb
    a: b :value: $(target\-exists c)
        commands
.Ve
.PP
Notes:
.TP
.B *
The values are arbitrary (they are not limited to variables)
.TP
.B *
The values are evaluated at rule expansion time, so expressions
containing variables like $@, $^, etc are legal.
.PP
.SH \&.SCANNER RULES

.PP
Scanner rules define a way to specify automatic dependency scanning. A \&.SCANNER rule has the
following form.
.PP
.Vb
    .SCANNER: target: dependencies
        commands
.Ve
.PP
The rule is used to compute additional dependencies that might be defined in the source files for
the specified target. The scanner produces dependencies for the specified target (which may be a
pattern) by running the commands, which \fImust\fP
produce output that is compatible with omake.
For example, on GNU systems the gcc \-MM foo.c produces dependencies for the file foo.c
(based on #include information).
.PP
We can use this to specify a scanner for C files that adds the scanned dependencies for the
\&.o file. The following scanner specifies that dependencies for a file, say foo.o can
be computed by running gcc \-MM foo.c\&. Furthermore, foo.c is a dependency, so the
scanner should be recomputed whenever the foo.c file changes.
.PP
.Vb
    .SCANNER: %.o: %.c
        gcc \-MM $<
.Ve
.PP
Let\&'s suppose that the command gcc \-MM foo.c prints the following line.
.PP
.Vb
    foo.o: foo.h /usr/include/stdio.h
.Ve
.PP
The result is that the files foo.h and /usr/include/stdio.h are considered to be
dependencies of foo.o\-\-\-that is, foo.o should be rebuilt if either of these files
changes.
.PP
This works, to an extent. One nice feature is that the scanner will be re\-run whenever the
foo.c file changes. However, one problem is that dependencies in C are \fIrecursive\fP\&.
That is, if the file foo.h is modified, it might include other files, establishing further
dependencies. What we need is to re\-run the scanner if foo.h changes too.
.PP
We can do this with a \fIvalue\fP
dependency. The variable $& is defined as the dependency
results from any previous scan. We can add these as dependencies using the digest function,
which computes an MD5 digest of the files.
.PP
.Vb
    .SCANNER: %.o: %.c :value: $(digest $&)
        gcc \-MM $<
.Ve
.PP
Now, when the file foo.h changes, its digest will also change, and the scanner will be re\-run
because of the value dependency (since $& will include foo.h).
.PP
This still is not quite right. The problem is that the C compiler uses a \fIsearch\-path\fP
for
include files. There may be several versions of the file foo.h, and the one that is chosen
depends on the include path. What we need is to base the dependencies on the search path.
.PP
The $(digest\-in\-path\-optional ...) function computes the digest based on a search path,
giving us a solution that works.
.PP
.Vb
    .SCANNER: %.o: %.c :value: $(digest\-in\-path\-optional $(INCLUDES), $&)
       gcc \-MM $(addprefix \-I, $(INCLUDES)) $<
.Ve
.PP
.SS NAMED SCANNERS, AND THE :SCANNER: TARGET
.PP
Sometimes it may be useful to specify explicitly which scanner should be used in a rule. For
example, we might compile \&.c files with different options, or (heaven help us) we may be
using both gcc and the Microsoft Visual C++ compiler cl\&. In general, the target of a
\&.SCANNER is not tied to a particular target, and we may name it as we like.
.PP
.Vb
    .SCANNER: scan\-gcc\-%.c: %.c :value: $(digest\-in\-path\-optional $(INCLUDES), $&)
        gcc \-MM $(addprefix \-I, $(INCLUDES)) $<

    .SCANNER: scan\-cl\-%.c: %.c :value: $(digest\-in\-path\-optional $(INCLUDES), $&)
        cl \-\-scan\-dependencies\-or\-something $(addprefix /I, $(INCLUDES)) $<
.Ve
.PP
The next step is to define explicit scanner dependencies. The :scanner: dependency is used
for this. In this case, the scanner dependencies are specified explicitly.
.PP
.Vb
    $(GCC_FILES): %.o: %.c :scanner: scan\-gcc\-%c
        gcc ...

    $(CL_FILES): %.obj: %.c :scanner: scan\-cl\-%c
        cl ...
.Ve
.PP
Explicit :scanner: scanner specification may also be used to state that a single
\&.SCANNER rule should be used to generate dependencies for more than one target. For example,
.PP
.Vb
    .SCANNER: scan\-all\-c: $(GCC_FILES) :value: $(digest\-in\-path\-optional $(INCLUDES), $&)
        gcc \-MM $(addprefix \-I, $(INCLUDES)) $(GCC_FILES)

    $(GCC_FILES): %.o: %.c :scanner: scan\-all\-c
        ...
.Ve
.PP
The above has the advantage of only running gcc
once and a disadvantage that when a single
source file changes, all the files will end up being re\-scanned.
.PP
.SS NOTES
.PP
In most cases, you won\&'t need to define scanners of your own. The standard installation includes
default scanners (both explicitly and implicitly named ones) for C, OCaml, and LaTeX files.
.PP
The SCANNER_MODE variable controls the usage of implicit scanner dependencies. See
.\"omake\-root.html#SCANNERMODE
the documentation
for the SCANNER_MODE variable in
\fIomake\-root\fP(1)
for detail.
.PP
The explicit :scanner: dependencies reduce the chances of scanner mis\-specifications. In
large complicated projects it might be a good idea to set SCANNER_MODE to error and
use only the named \&.SCANNER rules and explicit :scanner: specifications.
.PP
.SH OTHER SPECIAL TARGETS

.PP
There are several other special targets that define special actions to be take by omake\&.
.PP
.SS \&.DEFAULT
.PP
The \&.DEFAULT target specifies a target to be built by default
if omake
is run without explicit targets. The following rule
instructs omake
to build the program hello by default
.PP
.Vb
   .DEFAULT: hello
.Ve
.PP
.SS \&.SUBDIRS
.PP
The \&.SUBDIRS target is used to specify a set of subdirectories
that are part of the project. Each subdirectory should have its own
OMakefile,
which is evaluated in the context of the current
environment.
.PP
.Vb
   .SUBDIRS: src doc tests
.Ve
.PP
This rule specifies that the OMakefiles in each of the src, doc, and
tests directories should be read.
.PP
In some cases, especially when the OMakefiles are very similar in a large number of
subdirectories, it is inconvenient to have a separate OMakefile for each directory. If the
\&.SUBDIRS rule has a body, the body is used instead of the OMakefile\&.
.PP
.Vb
   .SUBDIRS: src1 src2 src3
      println(Subdirectory $(CWD))
      .DEFAULT: lib.a
.Ve
.PP
In this case, the src1, src2, and src3 files do not need OMakefiles.
Furthermore, if one exists, it is ignored. The following includes the file if it exists.
.PP
.Vb
   .SUBDIRS: src1 src2 src3
       if $(file\-exists OMakefile)
          include OMakefile
       .DEFAULT: lib.a
.Ve
.PP
.SS \&.INCLUDE
.PP
The \&.INCLUDE target is like the include directive, but it specifies a rule to build
the file if it does not exist.
.PP
.Vb
   .INCLUDE: config
       echo "CONFIG_READ = true" > config

    echo CONFIG_READ is $(CONFIG_READ)
.Ve
.PP
You may also specify dependencies to an \&.INCLUDE rule.
.PP
.Vb
   .INCLUDE: config: config.defaults
      cp config.defaults config
.Ve
.PP
A word of caution is in order here. The usual policy is used for determining when the rule is
out\-of\-date. The rule is executed if any of the following hold.
.PP
.TP
.B *
the target does not exist,
.TP
.B *
the rule has never been executed before,
.TP
.B *
any of the following have changed since the last time the rule was executed,
.RS
.TP
.B *
the target,
.TP
.B *
the dependencies,
.TP
.B *
the commands\-text.
.RE
.RS
.PP
.RE
.PP
In some of the cases, this will mean that the rule is executed even if the target file already
exists. If the target is a file that you expect to edit by hand (and therefore you don\&'t want to
overwrite it), you should make the rule evaluation conditional on whether the target already exists.
.PP
.Vb
   .INCLUDE: config: config.defaults
       # Don't overwrite my carefully hand\-edited file
       if $(not $(file\-exists config))
          cp config.defaults config
.Ve
.PP
.SS \&.PHONY
.PP
A ``phony\&'' target is a target that is not a real file, but exists to collect a set of dependencies.
Phony targets are specified with the \&.PHONY rule. In the following example, the
install target does not correspond to a file, but it corresponds to some commands that should
be run whenever the install target is built (for example, by running omake install).
.PP
.Vb
   .PHONY: install

   install: myprogram.exe
      cp myprogram.exe /usr/bin
.Ve
.PP
.SH RULE SCOPING

.PP
As we have mentioned before, omake
is a \fIscoped\fP
language. This provides great
flexibility\-\-\-different parts of the project can define different configurations without interfering
with one another (for example, one part of the project might be compiled with CFLAGS=\-O3 and
another with CFLAGS=\-g).
.PP
But how is the scope for a target file selected? Suppose we are building a file dir/foo.o\&.
omake
uses the following rules to determine the scope.
.PP
.RE
.TP
.B *
First, if there is an \fIexplicit\fP rule for building
dir/foo.o (a rule with no
wildcards), the context for that rule determines the scope for building the target.
.TP
.B *
Otherwise, the directory dir/ must be part of the project. This normally means that a
configuration file dir/OMakefile exists (although, see the \&.SUBDIRS section for
another way to specify the OMakefile). In this case, the scope of the target is the scope at
the end of the dir/OMakefile\&.
.PP
To illustrate rule scoping, let\&'s go back to the example of a ``Hello world\&'' program with two
files. Here is an example OMakefile (the two definitions of CFLAGS are for
illustration).
.PP
.Vb
    # The executable is compiled with debugging
    CFLAGS = \-g
    hello: hello_code.o hello_lib.o
       $(CC) $(CFLAGS) \-o $@ $+

    # Redefine CFLAGS
    CFLAGS += \-O3
.Ve
.PP
In this project, the target hello is \fIexplicit\fP\&.
The scope of the hello target
is the line beginning with hello:, where the value of CFLAGS is \-g\&. The other
two targets, hello_code.o and hello_lib.o do not appear as explicit targets, so their
scope is at the end of the OMakefile, where the CFLAGS variable is defined to be
\-g \-O3\&. That is, hello will be linked with CFLAGS=\-g and the \&.o files
will be compiled with CFLAGS=\-g \-O3\&.
.PP
We can change this behavior for any of the targets by specifying them as explicit targets. For
example, suppose we wish to compile hello_lib.o with a preprocessor variable LIBRARY\&.
.PP
.Vb
    # The executable is compiled with debugging
    CFLAGS = \-g
    hello: hello_code.o hello_lib.o
       $(CC) $(CFLAGS) \-o $@ $+

    # Compile hello_lib.o with CFLAGS = \-g \-DLIBRARY
    section
        CFLAGS += \-DLIBRARY
        hello_lib.o:

    # Redefine CFLAGS
    CFLAGS += \-O3
.Ve
.PP
In this case, hello_lib.o is also mentioned as an explicit target, in a scope where
CFLAGS=\-g \-DLIBRARY\&. Since no rule body is specified, it is compiled using the usual
implicit rule for building \&.o files (in a context where CFLAGS=\-g \-DLIBRARY).
.PP
.SS SCOPING OF IMPLICIT RULES
.PP
Implicit rules (rules containing wildcard patterns) are \fInot\fP
global, they follow the normal
scoping convention. This allows different parts of a project to have different sets of implicit
rules. If we like, we can modify the example above to provide a new implicit rule for building
hello_lib.o\&.
.PP
.Vb
    # The executable is compiled with debugging
    CFLAGS = \-g
    hello: hello_code.o hello_lib.o
       $(CC) $(CFLAGS) \-o $@ $+

    # Compile hello_lib.o with CFLAGS = \-g \-DLIBRARY
    section
        %.o: %.c
            $(CC) $(CFLAGS) \-DLIBRARY \-c $<
        hello_lib.o:

    # Redefine CFLAGS
    CFLAGS += \-O3
.Ve
.PP
In this case, the target hello_lib.o is built in a scope with a new implicit rule for
building %.o files. The implicit rule adds the \-DLIBRARY option. This implicit rule
is defined only for the target hello_lib.o; the target hello_code.o is built as
normal.
.PP
.SS SCOPING OF .SCANNER RULES
.PP
Scanner rules are scoped the same way as normal rules. If the \&.SCANNER rule is explicit
(containing no wildcard patterns), then the scope of the scan target is the same as the the rule.
If the \&.SCANNER rule is implicit, then the environment is taken from the :scanner:
dependency.
.PP
.Vb
    # The executable is compiled with debugging
    CFLAGS = \-g
    hello: hello_code.o hello_lib.o
       $(CC) $(CFLAGS) \-o $@ $+

    # scanner for .c files
    .SCANNER: scan\-c\-%.c: %.c
       $(CC) $(CFLAGS) \-MM $<

    # Compile hello_lib.o with CFLAGS = \-g \-DLIBRARY
    section
        CFLAGS += \-DLIBRARY
        hello_lib.o: hello_lib.c :scanner: scan\-c\-hello_lib.c
           $(CC) $(CFLAGS) \-c $<

    # Compile hello_code.c with CFLAGS = \-g \-O3
    section
        CFLAGS += \-O3
        hello_code.o: hello_code.c :scanner: scan\-c\-hello_code.c
           $(CC) $(CFLAGS) \-c $<
.Ve
.PP
Again, this is for illustration\-\-\-it is unlikely you would need to write a complicated configuration
like this! In this case, the \&.SCANNER rule specifies that the C\-compiler should be called
with the \-MM flag to compute dependencies. For the target hello_lib.o, the scanner
is called with CFLAGS=\-g \-DLIBRARY, and for hello_code.o it is called with
CFLAGS=\-g \-O3\&.
.PP
.SS SCOPING FOR .PHONY TARGETS
.PP
Phony targets (targets that do not correspond to files) are defined with a \&.PHONY: rule.
Phony targets are scoped as usual. The following illustrates a common mistake, where the
\&.PHONY target is declared \fIafter\fP
it is used.
.PP
.Vb
    # This example is broken!
    all: hello

    hello: hello_code.o hello_lib.o
        $(CC) $(CFLAGS) \-o $@ $+

    .PHONY: all
.Ve
.PP
This doesn\&'t work as expected because the \&.PHONY declaration occurs too late. The proper way
to write this example is to place the \&.PHONY declaration first.
.PP
.Vb
    # Phony targets must be declared before being used
    .PHONY: all

    all: hello

    hello: hello_code.o hello_lib.o
        $(CC) $(CFLAGS) \-o $@ $+
.Ve
.PP
Phony targets are passed to subdirectories. As a practical matter, it is wise to declare all
\&.PHONY targets in your root OMakefile, before any \&.SUBDIRS\&. This will ensure
that 1) they are considered as phony targets in each of the sbdirectories, and 2) you can build them
from the project root.
.PP
.Vb
    .PHONY: all install clean

    .SUBDIRS: src lib clib
.Ve
.PP
.SH REFERENCES

.PP
.SS SEE ALSO
.PP
.\"omake.html
omake(1),
.\"omake\-quickstart.html
omake\-quickstart(1),
.\"omake\-options.html
omake\-options(1),
.\"omake\-root.html
omake\-root(1),
.\"omake\-language.html
omake\-language(1),
.\"omake\-shell.html
omake\-shell(1),
.\"omake\-rules.html
omake\-rules(1),
.\"omake\-base.html
omake\-base(1),
.\"omake\-system.html
omake\-system(1),
.\"omake\-pervasives.html
omake\-pervasives(1),
.\"osh.html
osh(1),
\fImake\fP(1)
.PP
.SS VERSION
.PP
Version: 0.9.6.9 of April 11, 2006\&.
.PP
.SS LICENSE AND COPYRIGHT
.PP
(C)2003\-2006, Mojave Group, Caltech
.PP
This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.
.PP
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.
.PP
You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
.PP
.SS AUTHOR
.PP
Jason Hickey \fIet. al.\fP.br
Caltech 256\-80
.br
Pasadena, CA 91125, USA
.br
Email: \fBomake\-devel@metaprl.org\fP
.br
WWW: \fBhttp://www.cs.caltech.edu/~jyh\fP
.PP
.\" NOTE: This file is generated, DO NOT EDIT.
