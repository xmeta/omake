'\" t
.\" Manual page created with latex2man
.\" NOTE: This file is generated, DO NOT EDIT.
.de Vb
.ft CW
.nf
..
.de Ve
.ft R

.fi
..
.TH "OMAKE\-SYSTEM" "1" "April 11, 2006" "Build Tools " "Build Tools "
.SH NAME

omake
is a flexible build system designed for building a wide variety of projects.
This document describes the functions for interacting with the operating system,
including commands for input/output, and system commands for information about
the filesystem.
For an overview of omake,
see the
.\"omake.html
omake(1)
man page.
.PP
.SH IO FUNCTIONS

.SS STANDARD CHANNELS
.PP
The following variables define the standard channels.
.PP
.TP
stdin
.PP
.Vb
stdin : InChannel
.Ve
.PP
The standard input channel, open for reading.
.PP
.TP
stdout
.Vb
stdout : OutChannel
.Ve
.PP
The standard output channel, open for writing.
.PP
.TP
stderr
.Vb
stderr : OutChannel
.Ve
.PP
The standard error channel, open for writing.
.PP
.SS FOPEN
.PP
The fopen function opens a file for reading or writing.
.PP
.Vb
   $(fopen file, mode) : Channel
      file : File
      mode : String
.Ve
.PP
The file is the name of the file to be opened.
The mode is a combination of the following characters.
.TP
r
Open the file for reading; it is an error if the file does not exist.
.TP
w
Open the file for writing; the file is created if it does not exist.
.TP
a
Open the file in append mode; the file is created if it does not exist.
.TP
+
Open the file for both reading an writing.
.TP
t
Open the file in text mode (default).
.TP
b
Open the file in binary mode.
.TP
n
Open the file in nonblocking mode.
.TP
x
Fail if the file already exists.
.PP
Binary mode is not significant on Unix systems, where
text and binary modes are equivalent.
.SS CLOSE
.PP
.Vb
    $(close channel...)
       channel : Channel
.Ve
.PP
The close function closes a file that was previously opened
with fopen\&.
.SS READ
.PP
.Vb
   $(read channel, amount) : String
      channel : InChannel
      amount  : Int
   raises RuntimeException
.Ve
.PP
The read function reads up to amount
bytes from an input channel, and returns
the data that was read. If an end\-of\-file condition is reached,
the function raises a RuntimeException exception.
.SS WRITE
.PP
.Vb
   $(write channel, buffer, offset, amount) : String
      channel : OutChannel
      buffer  : String
      offset  : Int
      amount  : Int
   $(write channel, buffer) : String
      channel : OutChannel
      buffer  : String
   raises RuntimeException
.Ve
.PP
In the 4\-argument form, the write function writes
bytes to the output channel channel from the buffer,
starting at position offset\&. Up to amount bytes
are written. The function returns the number of bytes that were
written.
.PP
The 3\-argument form is similar, but the offset is 0.
.PP
In the 2\-argument form, the offset is 0, and the amount
if the length of the buffer\&.
.PP
If an end\-of\-file condition is reached,
the function raises a RuntimeException exception.
.SS LSEEK
.PP
.Vb
    $(lseek channel, offset, whence) : Int
       channel : Channel
       offset  : Int
       whence  : String
    raises RuntimeException
.Ve
.PP
The lseek function repositions the offset of the
channel channel according to the whence directive, as
follows:
.PP
.TP
SEEK_SET
The offset is set to offset\&.
.TP
SEEK_CUR
The offset is set to its current position plus offset bytes.
.TP
SEEK_END
The offset is set to the size of the file plus offset bytes.
.PP
The lseek function returns the new position in the file.
.SS REWIND
.PP
.Vb
   rewind(channel...)
      channel : Channel
.Ve
.PP
The rewind function set the current file position to the
beginning of the file.
.SS TELL
.PP
.Vb
    $(tell channel...) : Int...
       channel : Channel
    raises RuntimeException
.Ve
.PP
The tell function returns the current position of the channel\&.
.SS FLUSH
.PP
.Vb
   $(flush channel...)
      channel : OutChannel
.Ve
.PP
The flush function can be used only on files that are open for writing.
It flushes all pending data to the file.
.SS DUP
.PP
.Vb
    $(dup channel) : Channel
       channel : Channel
    raises RuntimeException
.Ve
.PP
The dup function returns a new channel referencing the
same file as the argument.
.SS DUP2
.PP
.Vb
   dup2(channel1, channel2)
      channel1 : Channel
      channel2 : Channel
   raises RuntimeException
.Ve
.PP
The dup2 function causes channel2 to refer to the same
file as channel1\&.
.SS SET\-NONBLOCK
.PP
.Vb
   set\-nonblock\-mode(mode, channel...)
      channel : Channel
      mode : String
.Ve
.PP
The set\-nonblock\-mode function sets the nonblocking flag on the
given channel. When IO is performed on the channel, and the operation
cannot be completed immediately, the operations raises a RuntimeException\&.
.SS SET\-CLOSE\-ON\-EXEC\-MODE
.PP
.Vb
   set\-close\-on\-exec\-mode(mode, channel...)
      channel : Channel
      mode : String
   raises RuntimeException
.Ve
.PP
The set\-close\-on\-exec\-mode function sets the close\-on\-exec
flags for the given channels. If the close\-on\-exec flag is set, the channel
is not inherited by child processes. Otherwise it is.
.SS PIPE
.PP
.Vb
   $(pipe) : Pipe
   raises RuntimeException
.Ve
.PP
The pipe function creates a Pipe object, which has two
fields. The read field is a channel that is opened for
reading, and the write field is a channel that is opened
for writing.
.SS MKFIFO
.PP
.Vb
   mkfifo(mode, node...)
      mode : Int
      node : Node
.Ve
.PP
The mkfifo function creates a named pipe.
.SS SELECT
.PP
.Vb
   $(select rfd..., wfd..., wfd..., timeout) : Select
      rfd : InChannel
      wfd : OutChannel
      efd : Channel
      timeout : float
   raises RuntimeException
.Ve
.PP
The select function polls for possible IO on a set of channels.
The rfd are a sequence of channels for reading, wfd are a
sequence of channels for writing, and efd are a sequence of
channels to poll for error conditions. The timeout specifies
the maximum amount of time to wait for events.
.PP
On successful return, select returns a Select object,
which has the following fields:
.TP
read
An array of channels available for reading.
.TP
write
An array of channels available for writing.
.TP
error
An array of channels on which an error has occurred.
.PP
.SS LOCKF
.PP
.Vb
    lockf(channel, command, len)
       channel : Channel
       command : String
       len : Int
    raises RuntimeException
.Ve
.PP
The lockf function places a lock on a region of the channel.
The region starts at the current position and extends for len
bytes.
.PP
The possible values for command are the following.
.TP
F_ULOCK
Unlock a region.
.TP
F_LOCK
Lock a region for writing; block if already locked.
.TP
F_TLOCK
Lock a region for writing; fail if already locked.
.TP
F_TEST
Test a region for other locks.
.TP
F_RLOCK
Lock a region for reading; block if already locked.
.TP
F_TRLOCK
Lock a region for reading; fail is already locked.
.PP
.SS INETADDR
.PP
The InetAddr object describes an Internet address.
It contains the following fields.
.PP
.TP
addr
String: the Internet address.
.TP
port
Int: the port number.
.PP
.SS HOST
.PP
A Host object contains the following fields.
.PP
.TP
name
String: the name of the host.
.TP
aliases
String Array: other names by which the host is known.
.TP
addrtype
String: the preferred socket domain.
.TP
addrs
InetAddr Array: an array of Internet addresses belonging to the host.
.PP
.SS GETHOSTBYNAME
.PP
.Vb
   $(gethostbyname host...) : Host...
      host : String
   raises RuntimeException
.Ve
.PP
The gethostbyname function returns a Host object
for the specified host. The host may specify a domain name
or an Internet address.
.PP
.SS PROTOCOL
.PP
The Protocol object represents a protocol entry.
It has the following fields.
.PP
.TP
name
String: the canonical name of the protocol.
.TP
aliases
String Array: aliases for the protocol.
.TP
proto
Int: the protocol number.
.PP
.SS GETPROTOBYNAME
.PP
.Vb
   $(getprotobyname name...) : Protocol...
      name : Int or String
   raises RuntimeException
.Ve
.PP
The getprotobyname function returns a Protocol object for the
specified protocol. The name may be a protocol name, or a
protocol number.
.SS SERVICE
.PP
The Service object represents a network service.
It has the following fields.
.PP
.TP
name
String: the name of the service.
.TP
aliases
String Array: aliases for the service.
.TP
port
Int: the port number of the service.
.TP
proto
Protocol: the protocol for the service.
.PP
.SS GETSERVBYNAME
.PP
.Vb
   $(getservbyname service...) : Service...
      service : String or Int
   raises RuntimeException
.Ve
.PP
The getservbyname function gets the information for a network service.
The service may be specified as a service name or number.
.SS SOCKET
.PP
.Vb
   $(socket domain, type, protocol) : Channel
      domain : String
      type : String
      protocol : String
   raises RuntimeException
.Ve
.PP
The socket function creates an unbound socket.
.PP
The possible values for the arguments are as follows.
.PP
The domain may have the following values.
.TP
PF_UNIX or unix
Unix domain, available only on Unix systems.
.TP
PF_INET or inet
Internet domain, IPv4.
.TP
PF_INET6 or inet6
Internet domain, IPv6.
.PP
The type may have the following values.
.TP
SOCK_STREAM or stream
Stream socket.
.TP
SOCK_DGRAM or dgram
Datagram socket.
.TP
SOCK_RAW or raw
Raw socket.
.TP
SOCK_SEQPACKET or seqpacket
Sequenced packets socket
.PP
The protocol is an Int or String that specifies
a protocol in the protocols database.
.SS BIND
.PP
.Vb
   bind(socket, host, port)
      socket : InOutChannel
      host : String
      port : Int
   bind(socket, file)
      socket : InOutChannel
      file : File
   raise RuntimeException
.Ve
.PP
The bind function binds a socket to an address.
.PP
The 3\-argument form specifies an Internet connection, the host specifies a host name
or IP address, and the port is a port number.
.PP
The 2\-argument form is for Unix sockets. The file specifies the filename
for the address.
.SS LISTEN
.PP
.Vb
   listen(socket, requests)
      socket : InOutChannel
      requests : Int
   raises RuntimeException
.Ve
.PP
The listen function sets up the socket for receiving up to requests number
of pending connection requests.
.SS ACCEPT
.PP
.Vb
   $(accept socket) : InOutChannel
      socket : InOutChannel
   raises RuntimeException
.Ve
.PP
The accept function accepts a connection on a socket.
.SS CONNECT
.PP
.Vb
    connect(socket, addr, port)
       socket : InOutChannel
       addr : String
       port : int
    connect(socket, name)
       socket : InOutChannel
       name : File
    raise RuntimeException
.Ve
.PP
The connect function connects a socket to a remote address.
.PP
The 3\-argument form specifies an Internet connection.
The addr argument is the Internet address of the remote host,
specified as a domain name or IP address. The port argument
is the port number.
.PP
The 2\-argument form is for Unix sockets. The name argument
is the filename of the socket.
.SS GETCHAR
.PP
.Vb
    $(getc) : String
    $(getc file) : String
       file : InChannel or File
    raises RuntimeException
.Ve
.PP
The getc function returns the next character of a file.
If the argument is not specified, stdin is used as input.
If the end of file has been reached, the function returns false\&.
.SS GETS
.PP
.Vb
   $(gets) : String
   $(gets channel) : String
      channel : InChannel or File
   raises RuntimeException
.Ve
.PP
The gets function returns the next line from a file.
The function returns the empty string if the end of file has been reached.
The line terminator is removed.
.SS FGETS
.PP
.Vb
   $(fgets) : String
   $(fgets channel) : String
      channel : InChannel or File
   raises RuntimeException
.Ve
.PP
The fgets function returns the next line from a file that has been
opened for reading with fopen\&. The function returns the empty string
if the end of file has been reached. The returned string is returned as
literal data. The line terminator is not removed.
.SS PRINTING FUNCTIONS
.PP
Output is printed with the print and println functions.
The println function adds a terminating newline to the value being
printed, the print function does not.
.PP
.Vb
    fprint(<file>, <string>)
    print(<string>)
    eprint(<string>)
    fprintln(<file>, <string>)
    println(<string>)
    eprintln(<string>)
.Ve
.PP
The fprint functions print to a file that has been previously opened with
fopen\&. The print functions print to the standard output channel, and
the eprint functions print to the standard error channel.
.SS VALUE PRINTING FUNCTIONS
.PP
Values can be printed with the printv and printvln functions.
The printvln function adds a terminating newline to the value being
printed, the printv function does not.
.PP
.Vb
    fprintv(<file>, <string>)
    printv(<string>)
    eprintv(<string>)
    fprintvln(<file>, <string>)
    printvln(<string>)
    eprintvln(<string>)
.Ve
.PP
The fprintv functions print to a file that has been previously opened with
fopen\&. The printv functions print to the standard output channel, and
the eprintv functions print to the standard error channel.
.SH HIGHER\-LEVEL IO FUNCTIONS

.PP
.SS REGULAR EXPRESSIONS
.PP
Many of the higher\-level functions use regular expressions.
Regular expressions are defined by strings with syntax nearly identical
to \fIawk\fP(1)\&.
.PP
Strings may contain the following character constants.
.PP
.TP
.B *
\\\\ : a literal backslash.
.TP
.B *
\\a : the alert character ^G\&.
.TP
.B *
\\b : the backspace character ^H\&.
.TP
.B *
\\f : the formfeed character ^L\&.
.TP
.B *
: the newline character ^J\&.
.TP
.B *
\\r : the carriage return character ^M\&.
.TP
.B *
\\t : the tab character ^I\&.
.TP
.B *
\\v : the vertical tab character.
.TP
.B *
\\xhh... : the character represented by the string
of hexadecimal digits h\&. All valid hexadecimal digits
following the sequence are considered to be part of the sequence.
.TP
.B *
\\ddd : the character represented by 1, 2, or 3 octal
digits.
.PP
Regular expressions are defined using the special characters \&.\\^$[(){}*?+.
.PP
.TP
.B *
c : matches the literal character c if c is not
a special character.
.TP
.B *
\\c : matches the literal character c, even if c
is a special character.
.TP
.B *
\&. : matches any character, including newline.
.TP
.B *
^ : matches the beginning of a line.
.TP
.B *
$ : matches the end of line.
.TP
.B *
[abc...] : matches any of the characters abc...
.TP
.B *
[^abc...] : matches any character except abc...
.TP
.B *
r1|r2 : matches either r1 or r2\&.
.TP
.B *
r1r2 : matches r1 and then r2\&.
.TP
.B *
r+ : matches one or more occurrences of r\&.
.TP
.B *
r* : matches zero or more occurrences of r\&.
.TP
.B *
r? : matches zero or one occurrence of r\&.
.TP
.B *
(r) : parentheses are used for grouping; matches r\&.
.TP
.B *
\\(r\\) : also defines grouping, but the expression matched
within the parentheses is available to the output processor
through one of the variables $1, $2, \&.\&.\&.
.TP
.B *
r{n} : matches exactly n occurrences of r\&.
.TP
.B *
r{n,} : matches n or more occurrences of r\&.
.TP
.B *
r{n,m} : matches at least n occurrences of r,
and no more than m occurrences.
.TP
.B *
\\y: matches the empty string at either the beginning or
end of a word.
.TP
.B *
\\B: matches the empty string within a word.
.TP
.B *
\\<: matches the empty string at the beginning of a word.
.TP
.B *
\\>: matches the empty string at the end of a word.
.TP
.B *
\\w: matches any character in a word.
.TP
.B *
\\W: matches any character that does not occur within a word.
.TP
.B *
\\`: matches the empty string at the beginning of a file.
.TP
.B *
\\': matches the empty string at the end of a file.
.PP
Character classes can be used to specify character sequences
abstractly. Some of these sequences can change depending on your LOCALE.
.PP
.TP
.B *
[:alnum:] Alphanumeric characters.
.TP
.B *
[:alpha:] Alphabetic characters.
.TP
.B *
[:lower:] Lowercase alphabetic characters.
.TP
.B *
[:upper:] Uppercase alphabetic characters.
.TP
.B *
[:cntrl:] Control characters.
.TP
.B *
[:digit:] Numeric characters.
.TP
.B *
[:xdigit:] Numeric and hexadecimal characters.
.TP
.B *
[:graph:] Characters that are printable and visible.
.TP
.B *
[:print:] Characters that are printable, whether they are visible or not.
.TP
.B *
[:punct:] Punctuation characters.
.TP
.B *
[:blank:] Space or tab characters.
.TP
.B *
[:space:] Whitespace characters.
.PP
.SS CAT
.PP
.Vb
    cat(files) : Sequence
       files : File or InChannel Sequence
.Ve
.PP
The cat function concatenates the output from multiple files
and returns it as a string.
.SS GREP
.PP
.Vb
   grep(pattern) : String  # input from stdin, default options
      pattern : String
   grep(pattern, files) : String  # default options
      pattern : String
      files   : File Sequence
   grep(options, pattern, files) : String
     options : String
     pattern : String
     files   : File Sequence
.Ve
.PP
The grep function searches for occurrences of a regular
expression pattern in a set of files, and prints lines that match.
This is like a highly\-simplified version of \fIgrep\fP(1)\&.
.PP
The options are:
.TP
q
If specified, the output from grep is not displayed.
.TP
n
If specified, output lines include the filename.
.PP
The pattern is a regular expression.
.PP
If successful (grep found a match), the function returns true\&.
Otherwise, it returns false\&.
.SS SCAN
.PP
.Vb
   scan(input\-files)
   case string1
      body1
   case string2
      body2
   ...
   default
      bodyd
.Ve
.PP
The scan function provides input processing in command\-line form.
The function takes file/filename arguments. If called with no
arguments, the input is taken from stdin\&. If arguments are provided,
each specifies an InChannel, or the name of a file for input.
Output is always to stdout\&.
.PP
The scan function operates by reading the input one line at a time,
and processing it according to the following algorithm.
.PP
For each line,
the record is first split into fields, and
the fields are bound to the variables $1, $2, ...\&. The variable
$0 is defined to be the entire line, and $* is an array
of all the field values. The $(NF) variable is defined to be the number
of fields.
.PP
Next, a case expression is selected. If string_i matches the token $1,
then body_i is evaluated. If the body ends in an export, the state
is passed to the next clause. Otherwise the value is discarded.
.PP
For example, here is an scan function that acts as a simple command processor.
.PP
.Vb
    calc() =
       i = 0
       scan(script.in)
       case print
          println($i)
       case inc
          i = $(add $i, 1)
          export
       case dec
          i = $(sub $i, 1)
          export
       case addconst
          i = $(add $i, $2)
          export
       default
          eprintln($"Unknown command: $1")
.Ve
.PP
The scan function also supports several options.
.PP
.Vb
    scan(options, files)
    ...
.Ve
.PP
.TP
A
Parse each line as an argument list, where arguments
may be quoted. For example, the following line has three words,
``ls\&'',
``\-l\&'',
``Program Files\&''\&.
.PP
.Vb
       ls \-l "Program Files"
.Ve
.TP
O
Parse each line using white space as the separator, using the
usual OMake algorithm for string parsing. This is the default.
.TP
x
Once each line is split, reduce each word using the
hex representation. This is the usual hex representation used
in URL specifiers, so the string ``Program Files\&'' may be
alternately represented in the form Program%20Files or
Program+Files.
.PP
Note, if you want to redirect the output to a file, the easiest way is to
redefine the stdout variable. The stdout variable is scoped the
same way as other variables, so this definition does not affect the meaning of
stdout outside the calc function.
.PP
.Vb
    calc() =
        stdout = $(fopen script.out, w)
        scan(script.in)
           ...
        close(stdout)
.Ve
.SS AWK
.PP
.Vb
   awk(input\-files)
   case pattern1:
      body1
   case pattern2:
      body2
   ...
   default:
      bodyd
.Ve
.PP
The awk function provides input processing similar to \fIawk\fP(1),
but more limited. The function takes filename arguments. If called with no
arguments, the input is taken from stdin\&. If arguments are provided,
each specifies an InChannel, or the name of a file for input.
Output is always to stdout\&.
.PP
The variables RS and FS define record and field separators
as regular expressions.
The default value of RS is the regular expression \\r|
|\\r
\&.
The default value of FS is the regular expression [ \\t]+.
.PP
The awk function operates by reading the input one record at a time,
and processing it according to the following algorithm.
.PP
For each line,
the record is first split into fields using the field separator FS, and
the fields are bound to the variables $1, $2, ...\&. The variable
$0 is defined to be the entire line, and $* is an array
of all the field values. The $(NF) variable is defined to be the number
of fields.
.PP
Next, the cases are evaluated in order.
For each case, if the regular expression pattern_i matches the record $0,
then body_i is evaluated. If the body ends in an export, the state
is passed to the next clause. Otherwise the value is discarded. If the regular
expression contains \\(r\\) expression, those expression override the
fields $1, $2, ...\&.
.PP
For example, here is an awk function to print the text between two
delimiters \\begin{<name>} and \\end{<name>}, where the <name>
must belong to a set passed as an argument to the filter function.
.PP
.Vb
    filter(names) =
       print = false

       awk(Awk.in)
       case $"^\\\\end\\{\\([:alpha:]+\\)\\}"
          if $(mem $1, $(names))
             print = false
             export
          export
       default
          if $(print)
             println($0)
       case $"^\\\\begin\\{\\([:alpha:]+\\)\\}"
          print = $(mem $1, $(names))
          export
.Ve
.PP
Note, if you want to redirect the output to a file, the easiest way is to
redefine the stdout variable. The stdout variable is scoped the
same way as other variables, so this definition does not affect the meaning of
stdout outside the filter function.
.PP
.Vb
    filter(names) =
        stdout = $(fopen file.out, w)
        awk(Awk.in)
           ...
        close(stdout)
.Ve
.SS FSUBST
.PP
.Vb
   fsubst(files)
   case pattern1 [options]
      body1
   case pattern2 [options]
      body2
   ...
   default
      bodyd
.Ve
.PP
The fsubst function provides a \fIsed\fP(1)\-like
substitution
function. Similar to awk, if fsubst is called with no
arguments, the input is taken from stdin\&. If arguments are provided,
each specifies an InChannel, or the name of a file for input.
.PP
The RS variable defines a regular expression that determines a record separator,
The default value of RS is the regular expression \\r|
|\\r
\&.
.PP
The fsubst function reads the file one record at a time.
.PP
For each record, the cases are evaluated in order. Each case defines
a substitution from a substring matching the pattern to
replacement text defined by the body.
.PP
Currently, there is only one option: g\&.
If specified, each clause specifies a global replacement,
and all instances of the pattern define a substitution.
Otherwise, the substitution is applied only once.
.PP
Output can be redirected by redefining the stdout variable.
.PP
For example, the following program replaces all occurrences of
an expression word. with its capitalized form.
.PP
.Vb
    section
       stdout = $(fopen Subst.out, w)
       fsubst(Subst.in)
       case $"\\<\\([[:alnum:]]+\\)\\." g
          value $(capitalize $1).
       close(stdout)
.Ve
.SS LEXER
.PP
The Lexer object defines a facility for lexical analysis, similar to the
\fIlex\fP(1)
and \fIflex\fP(1)
programs.
.PP
In omake,
lexical analyzers can be constructed dynamically by extending
the Lexer class. A lexer definition consists of a set of directives specified
with method calls, and set of clauses specified as rules.
.PP
For example, consider the following lexer definition, which is intended
for lexical analysis of simple arithmetic expressions for a desktop
calculator.
.PP
.Vb
   lexer1. =
      extends $(Lexer)

      other: .
         eprintln(Illegal character: $* )
         lex()

      white: $"[[:space:]]+"
         lex()

      op: $"[\-+*/()]"
         switch $*
         case +
            Token.unit($(loc), plus)
         case \-
            Token.unit($(loc), minus)
         case *
            Token.unit($(loc), mul)
         case /
            Token.unit($(loc), div)
         case $"("
            Token.unit($(loc), lparen)
         case $")"
            Token.unit($(loc), rparen)

      number: $"[[:digit:]]+"
         Token.pair($(loc), exp, $(int $* ))

      eof: $"\\'"
         Token.unit($(loc), eof)
.Ve
.PP
This program defines an object lexer1 the extends the Lexer
object, which defines lexing environment.
.PP
The remainder of the definition consists of a set of clauses,
each with a method name before the colon; a regular expression
after the colon; and in this case, a body. The body is optional,
if it is not specified, the method with the given name should
already exist in the lexer definition.
.PP
\fINB\fP
The clause that matches the \fIlongest\fP
prefix of the input
is selected. If two clauses match the same input prefix, then the \fIlast\fP
one is selected. This is unlike most standard lexers, but makes more sense
for extensible grammars.
.PP
The first clause matches any input that is not matched by the other clauses.
In this case, an error message is printed for any unknown character, and
the input is skipped. Note that this clause is selected only if no other
clause matches.
.PP
The second clause is responsible for ignoring white space.
If whitespace is found, it is ignored, and the lexer is called
recursively.
.PP
The third clause is responsible for the arithmetic operators.
It makes use of the Token object, which defines three
fields: a loc field that represents the source location;
a name; and a value\&.
.PP
The lexer defines the loc variable to be the location
of the current lexeme in each of the method bodies, so we can use
that value to create the tokens.
.PP
The Token.unit($(loc), name)
method constructs a new Token object with the given name,
and a default value.
.PP
The number clause matches nonnegative integer constants.
The Token.pair($(loc), name, value) constructs a token with the
given name and value.
.PP
Lexer object operate on InChannel objects.
The method lexer1.lex\-channel(channel) reads the next
token from the channel argument.
.PP
.SS LEXER MATCHING
.PP
During lexical analysis, clauses are selected by longest match.
That is, the clause that matches the longest sequence of input
characters is chosen for evaluation. If no clause matches, the
lexer raises a RuntimeException\&. If more than one clause
matches the same amount of input, the first one is chosen
for evaluation.
.PP
.SS EXTENDING LEXER DEFINITIONS
.PP
Suppose we wish to augment the lexer example so that it ignores
comments. We will define comments as any text that begins with
the string (*, ends with *), and comments may
be nested.
.PP
One convenient way to do this is to define a separate lexer
just to skip comments.
.PP
.Vb
   lex\-comment. =
      extends $(Lexer)

      level = 0

      other: .
         lex()

      term: $"[*][)]"
         if $(not $(eq $(level), 0))
            level = $(sub $(level), 1)
            lex()

      next: $"[(][*]"
         level = $(add $(level), 1)
         lex()

      eof: $"\\'"
         eprintln(Unterminated comment)
.Ve
.PP
This lexer contains a field level that keeps track of the nesting
level. On encountering a (* string, it increments the level,
and for *), it decrements the level if nonzero, and continues.
.PP
Next, we need to modify our previous lexer to skip comments.
We can do this by extending the lexer object lexer1
that we just created.
.PP
.Vb
   lexer1. +=
      comment: $"[(][*]"
         lex\-comment.lex\-channel($(channel))
         lex()
.Ve
.PP
The body for the comment clause calls the lex\-comment lexer when
a comment is encountered, and continues lexing when that lexer returns.
.PP
.SS THREADING THE LEXER OBJECT
.PP
Clause bodies may also end with an export directive. In this case
the lexer object itself is used as the returned token. If used with
the Parser object below, the lexer should define the loc, name
and value fields in each export clause. Each time
the Parser calls the lexer, it calls it with the lexer returned
from the previous lex invocation.
.SS PARSER
.PP
The Parser object provides a facility for syntactic analysis based
on context\-free grammars.
.PP
Parser objects are specified as a sequence of directives,
specified with method calls; and productions, specified as rules.
.PP
For example, let\&'s finish building the desktop calculator started
in the Lexer example.
.PP
.Vb
   parser1. =
      extends $(Parser)

      #
      # Use the main lexer
      #
      lexer = $(lexer1)

      #
      # Precedences, in ascending order
      #
      left(plus minus)
      left(mul div)
      right(uminus)

      #
      # A program
      #
      start(prog)

      prog: exp eof
         return $1

      #
      # Simple arithmetic expressions
      #
      exp: minus exp :prec: uminus
         neg($2)

      exp: exp plus exp
         add($1, $3)

      exp: exp minus exp
         sub($1, $3)

      exp: exp mul exp
         mul($1, $3)

      exp: exp div exp
         div($1, $3)

      exp: lparen exp rparen
         return $2
.Ve
.PP
Parsers are defined as extensions of the Parser class.
A Parser object must have a lexer field. The lexer
is not required to be a Lexer object, but it must provide
a lexer.lex() method that returns a token object with
name and value fields. For this example, we use the
lexer1 object that we defined previously.
.PP
The next step is to define precedences for the terminal symbols.
The precedences are defined with the left, right,
and nonassoc methods in order of increasing precedence.
.PP
The grammar must have at least one start symbol, declared with
the start method.
.PP
Next, the productions in the grammar are listed as rules.
The name of the production is listed before the colon, and
a sequence of variables is listed to the right of the colon.
The body is a semantic action to be evaluated when the production
is recognized as part of the input.
.PP
In this example, these are the productions for the arithmetic
expressions recognized by the desktop calculator. The semantic
action performs the calculation. The variables $1, $2, ...
correspond to the values associated with each of the variables
on the right\-hand\-side of the production.
.PP
.SS CALLING THE PARSER
.PP
The parser is called with the $(parser1.parse\-channel start, channel)
or $(parser1.parse\-file start, file) functions. The start
argument is the start symbol, and the channel or file
is the input to the parser.
.PP
.SS PARSING CONTROL
.PP
The parser generator generates a pushdown automation based on LALR(1)
tables. As usual, if the grammar is ambiguous, this may generate shift/reduce
or reduce/reduce conflicts. These conflicts are printed to standard
output when the automaton is generated.
.PP
By default, the automaton is not constructed until the parser is
first used.
.PP
The build(debug) method forces the construction of the automaton.
While not required, it is wise to finish each complete parser with
a call to the build(debug) method. If the debug variable
is set, this also prints with parser table together with any conflicts.
.PP
The loc variable is defined within action bodies, and represents
the input range for all tokens on the right\-hand\-side of the production.
.PP
.SS EXTENDING PARSERS
.PP
Parsers may also be extended by inheritance.
For example, let\&'s extend the grammar so that it also recognizes
the << and >> shift operations.
.PP
First, we extend the lexer so that it recognizes these tokens.
This time, we choose to leave lexer1 intact, instead of
using the += operator.
.PP
.Vb
   lexer2. =
      extends $(lexer1)

      lsl: $"<<"
         Token.unit($(loc), lsl)

      asr: $">>"
         Token.unit($(loc), asr)
.Ve
.PP
Next, we extend the parser to handle these new operators.
We intend that the bitwise operators have lower precedence
than the other arithmetic operators. The two\-argument form
of the left method accomplishes this.
.PP
.Vb
   parser2. =
      extends $(parser1)

      left(plus, lsl lsr asr)

      lexer = $(lexer2)

      exp: exp lsl exp
         lsl($1, $3)

      exp: exp asr exp
         asr($1, $3)
.Ve
.PP
In this case, we use the new lexer lexer2, and we add productions
for the new shift operations.
.SS GETTIMEOFDAY
.PP
.Vb
   $(gettimeofday) : Float
.Ve
.PP
The gettimeofday function returns the time of day in seconds
since January 1, 1970.
.SH SHELL FUNCTIONS

.SS ECHO
.PP
The echo function prints a string.
.PP
$(echo <args>)
echo <args>
.SS JOBS
.PP
The jobs function prints a list of jobs.
.PP
jobs
.SS CD
.PP
The cd function changes the current directory.
.PP
.Vb
    cd(dir)
       dir : Dir
.Ve
.PP
The cd function also supports a 2\-argument form:
.PP
.Vb
    $(cd dir, e)
       dir : Dir
       e : expression
.Ve
.PP
In the two\-argument form, expression e is evaluated
in the directory dir\&. The current directory is not
changed otherwise.
.PP
The behavior of the cd function can be changed with the
CDPATH variable, which specifies a search path for
directories. This is normally useful only in the osh
command interpreter.
.PP
.Vb
    CDPATH : Dir Sequence
.Ve
.PP
For example, the following will change directory to the first
directory \&./foo, ~/dir1/foo, ~/dir2/foo\&.
.PP
.Vb
    CDPATH[] =
       .
       $(HOME)/dir1
       $(HOME)/dir2
    cd foo
.Ve
.PP
.SS BG
.PP
The bg function places a job in the background.
.PP
bg <pid...>
.SS FG
.PP
The fg function brings a job to the foreground.
.PP
fg <pid...>
.SS STOP
.PP
The stop function suspends a job.
.PP
stop <pid...>
.SS WAIT
.PP
The wait function waits for a job to finish.
If no process identifiers are given, the shell waits for
all jobs to complete.
.PP
wait <pid...>
.SS KILL
.PP
The kill function signals a job.
.PP
kill [signal] <pid...>
.SS HISTORY
.PP
.Vb
    $(history\-index) : Int
    $(history) : String Sequence
    history\-file : File
    history\-length : Int
.Ve
.PP
The history variables manage the command\-line history in osh\&.
They have no effect
in omake\&.
.PP
The history\-index variable is the current index into the command\-line history.
The history variable is the current command\-line history.
.PP
The history\-file variable can be redefined if you want the command\-line history
to be saved. The default value is ~/.omake/osh_history\&.
.PP
The history\-length variable can be redefined to specify the maximum number of
lines in the history that you want saved. The default value is 100\&.
.SH REFERENCES

.PP
.SS SEE ALSO
.PP
.\"omake.html
omake(1),
.\"omake\-quickstart.html
omake\-quickstart(1),
.\"omake\-options.html
omake\-options(1),
.\"omake\-root.html
omake\-root(1),
.\"omake\-language.html
omake\-language(1),
.\"omake\-shell.html
omake\-shell(1),
.\"omake\-rules.html
omake\-rules(1),
.\"omake\-base.html
omake\-base(1),
.\"omake\-system.html
omake\-system(1),
.\"omake\-pervasives.html
omake\-pervasives(1),
.\"osh.html
osh(1),
\fImake\fP(1)
.PP
.SS VERSION
.PP
Version: 0.9.6.9 of April 11, 2006\&.
.PP
.SS LICENSE AND COPYRIGHT
.PP
(C)2003\-2006, Mojave Group, Caltech
.PP
This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.
.PP
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.
.PP
You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
.PP
.SS AUTHOR
.PP
Jason Hickey \fIet. al.\fP.br
Caltech 256\-80
.br
Pasadena, CA 91125, USA
.br
Email: \fBomake\-devel@metaprl.org\fP
.br
WWW: \fBhttp://www.cs.caltech.edu/~jyh\fP
.PP
.\" NOTE: This file is generated, DO NOT EDIT.
