%
%
%
\section{Build examples}

Let's explain the OMake build model a bit, especially since it differs significantly from GNU make.
One issue that dominates this discussion is that OMake is based on global project analysis.  That
means you define a configuration for the \emph{entire} project, and you run \emph{one} instance of omake.

For single-directory projects this doesn't mean much.  For multi-directory projects it means a lot.
With GNU make, you would usually invoke the \verb+make+ program recursivelt for each directory in
the project.  For example, suppose you had a project with some project root directory, containing a
directory of sources \verb+src+, which in turn contains subdirectories \verb+lib+ and \verb+main+.
So your project looks like this nice piece of ASCII art.

\begin{verbatim}
    my_project/
    |--> Makefile
    `--> src/
         |---> Makefile
         |---> lib/
         |     |---> Makefile
         |     `---> source files...
         `---> main/
               |---> Makefile
               `---> source files...
\end{verbatim}
                    
Typically, with GNU make, you would start an instance of \verb+make+ in \verb+my_project/+; this
would in term start an instance of \verb+make+ in the \verb+src/+ directory; and this would start
new instances in \verb+lib/+ and \verb+main/+.  Basically, you count up the number of
\verb+Makefile+s in the project, and that is the number of instances of \verb+make+ processes that
will be created.

The number of processes is no big deal with today's machines (sometimes contrary the the author's opinion, we
no longer live in the 1970s).  The problem with the scheme was that each \verb+make+ process had a
separate configuration, and it took a lot of work to make sure that everything was consistent.
Furthermore, suppose the programmer runs \verb+make+ in the \verb+main/+ directory, but the
\verb+lib/+ is out-of-date.  In this case, \verb+make+ would happily crank away, perhaps trying to
rebuild files in \verb+lib/+, perhaps just giving up.

With OMake this changes entirely.  Well, not entirely.  The source structure is quite similar, we
merely add some Os to the ASCII art.

\begin{verbatim}
    my_project/
    |--> OMakeroot   (or Root.om)
    |--> OMakefile
    `--> src/
         |---> OMakefile
         |---> lib/
         |     |---> OMakefile
         |     `---> source files...
         `---> main/
               |---> OMakefile
               `---> source files...
\end{verbatim}

The role of each \verb+<dir>/OMakefile+ plays the same role as each \verb+<dir>/Makefile+: it
describes how to build the source files in \verb+<dir>+.  The OMakefile retains much of syntax and
structure of the Makefile, but in most cases it is much simpler.

One minor difference is the presence of the OMakeroot in the project root.  The main purpose of this
file is to indicate where the project root \emph{is} in the first place (in case \verb+omake+ is
invoked from a subdirectory).  The \verb+OMakeroot+ serves as the bootstrap file; omake starts by
reading this file first.  Otherwise, the syntax and evaluation of \verb+OMakeroot+ is no different
from any other \verb+OMakefile+.

The \emph{big} difference is that OMake performs a \emph{global} analysis.  Here is what happens when \verb+omake+ starts.
\begin{enumerate}
\item omake locates that OMakeroot file, and reads it.
\item Each OMakefile points to its subdirectory OMakefiles using the .SUBDIRS target.
For example, \verb+my_project/OMakefile+ has a rule,

\begin{verbatim}
    .SUBDIRS: src
\end{verbatim}

and the \verb+my_project/src/OMakefile+ has a rule,

\begin{verbatim}
    .SUBDIRS: lib main
\end{verbatim}

\verb+omake+ uses these rules to read and evaluate every \verb+OMakefile+ in the project.
Reading and evaluation is fast.  This part of the process is cheap.

\item Now that the entire configuration is read, \verb+omake+ determines which files are out-of-date
(using a global analysis), and starts the build process.  This may take a while, depending on what
exactly needs to be done.
\end{enumerate}

There are several advantages to this model.  First, since analysis is global, it is much easier to
ensure that the build configuration is consistent--after all, there is only one configuration.
Another benefit is that the build configuration is inherited, and can be re-used, down the
hierarchy.  Typically, the root \verb+OMakefile+ defines some standard boilerplate and
configuration, and this is inherited by subdirectories that tweak and modify it (but do not need to
restate it entirely).  The disadvantage of course is space, since this is global analysis after all.
In practice rarely seems to be a concern; omake takes up much less space than your web browser even
on large projects.

Some notes to the power-GNU-make user.
\begin{itemize}
\item OMakefiles are a lot like Makefiles.  The syntax is similar, and there many of the builtin
functions are similar.  However, the two build systems are not the same.  Some evil features (in the authors'
opinions) have been dropped in OMake, and some new features have been added.

\item OMake works the same way on all platforms, including Win32.  The standard configuration does
the right thing, but if you care about porting your code to multiple platforms, and you use some
tricky features, you may need to condition parts of your build config on the \verb+$(OSTYPE)+
variable.

\item A minor issue is that OMake dependency analysis is based on MD5 file digests.  That is,
dependencies are based on file \emph{contents}, not file \emph{modification times}.  Say goodbye to
false rebuilds based on spurius timestamp changes and mismatches between local time and fileserver
time.
\end{itemize}

\subsection{OMakeroot vs. OMakefile}

Before we begin with examples, let's ask the first question, ``What is the difference between the
project root OMakeroot and OMakefile?''  A short answer is, there is no difference, but you must
have an OMakeroot file (or Root.om file).

However, the normal style is that OMakeroot is boilerplate and is more-or-less the same for all
projects.  The OMakefile is where you put all your project-specific stuff.

To get started, you don't have to do this yourself.  In most cases you just perform the following
step in your project root directory.

\begin{itemize}
\item Run \verb+omake --install+ in your project root.
\end{itemize}

This will create the initial OMakeroot and OMakefile files that you can edit to get started.

\subsection{An example C project}

To begin, let's start with a simple example.  Let's say that we have a full directory tree,
containing the following files.

\begin{verbatim}
    my_project/
    |--> OMakeroot
    |--> OMakefile
    `--> src/
         |---> OMakefile
         |---> lib/
         |     |---> OMakefile
         |     |---> ouch.c
         |     |---> ouch.h
         |     `---> bandaid.c
         `---> main/
               |---> OMakefile
               |---> horsefly.c
               |---> horsefly.h
               `---> main.c
\end{verbatim}

Here is an example listing.

\begin{verbatim}
my_project/OMakeroot:
    # Include the standard configuration for C applications
    open build/C
    
    # Process the command-line vars
    DefineCommandVars()
    
    # Include the OMakefile in this directory.
    .SUBDIRS: .

my_project/OMakefile:
    # Set up the standard configuration
    CFLAGS += -g

    # Include the src subdirectory
    .SUBDIRS: src

my_project/src/OMakefile:
    # Add any extra options you like
    CFLAGS += -O2

    # Include the subdirectories
    .SUBDIRS: lib main

my_project/src/lib/OMakefile:
    # Build the library as a static library.
    # This builds libbug.a on Unix/OSX, or libbug.lib on Win32.
    # Note that the source files are listed _without_ suffix.
    StaticCLibrary(libbug, ouch bandaid)

my_project/src/main/OMakefile:
    # Some files include the .h files in ../lib
    INCLUDES += ../lib

    # Indicate which libraries we want to link against.
    # The suffix depends on the platform.  The canonical
    # suffix is defined in $(EXT_LIB).
    LIBS[] +=
        ../lib/libbug$(EXT_LIB)

    # Build the program.
    # Builds horsefly.exe on Win32, and horsefly on Unix.
    # The first argument is the name of the executable.
    # The second argument is an array of object files (without suffix)
    # that are part of the program.
    CProgram(horsefly, horsefly)

    # Build the program by default (in case omake is called
    # without any arguments).  EXE is defined as .exe on Win32,
    # otherwise it is empty.
    .DEFAULT: horsefly$(EXE)
\end{verbatim}

Most of the configuration here is defined in the file \verb+build/C.om+ (which is part of the OMake
distribution).  This file takes care of a lot of work, including:
\begin{itemize}
\item Defining the \verb+StaticCLibrary+ and \verb+CProgram+ functions, which describe the canonical
way to build C libraries and programs.
\item Defining a mechanism for \emph{scanning} each of the source programs to discover dependencies.
That is, it defines .SCANNER rules for C source files.
\end{itemize}

Variables are inherited down the hierarchy, so for example, the value of CFLAGS in
src/main/OMakefile is ``\verb+-g -O2+''.

\subsection{An example OCaml project}

Let's repeat the example, assuming we are using OCaml instead of C.
This time, the directory tree looks like this.

\begin{verbatim}
    my_project/
    |--> OMakeroot
    |--> OMakefile
    `--> src/
         |---> OMakefile
         |---> lib/
         |     |---> OMakefile
         |     |---> ouch.ml
         |     |---> ouch.mli
         |     `---> bandaid.ml
         `---> main/
               |---> OMakefile
               |---> horsefly.ml
               |---> horsefly.mli
               `---> main.c
\end{verbatim}

The listing is only a bit different.

\begin{verbatim}
my_project/OMakeroot:
    # Include the standard configuration for OCaml applications
    open build/OCaml
    
    # Process the command-line vars
    DefineCommandVars()
    
    # Include the OMakefile in this directory.
    .SUBDIRS: .

my_project/OMakefile:
    # Set up the standard configuration
    OCAMLFLAGS += -Wa

    # Do we want to use the bytecode compiler,
    # or the native-code one?  Let's use both for
    # this example.
    NATIVE_ENABLED = true
    BYTE_ENABLED = true

    # Include the src subdirectory
    .SUBDIRS: src

my_project/src/OMakefile:
    # Include the subdirectories
    .SUBDIRS: lib main

my_project/src/lib/OMakefile:
    # Let's do aggressive inlining on native code
    OCAMLOPTFLAGS += -inline 10

    # Build the library as a static library.
    # This builds libbug.a on Unix/OSX, or libbug.lib on Win32.
    # Note that the source files are listed _without_ suffix.
    OCamlLibrary(libbug, ouch bandaid)

my_project/src/main/OMakefile:
    # These files depend on the interfaces in ../lib
    OCAMLINCLUDES += ../lib

    # Indicate which libraries we want to link against.
    # The suffix does not depend on the platform.
    OCAML_LIBS[] +=
        ../lib/libbug

    # Build the program.
    # Builds horsefly.exe on Win32, and horsefly on Unix.
    # The first argument is the name of the executable.
    # The second argument is an array of object files (without suffix)
    # that are part of the program.
    OCamlProgram(horsefly, horsefly)

    # Build the program by default (in case omake is called
    # without any arguments).  EXE is defined as .exe on Win32,
    # otherwise it is empty.
    .DEFAULT: horsefly$(EXE)
\end{verbatim}

In this case, most of the configuration here is defined in the file \verb+build/OCaml.om+.  In this
particular configuration, files in \verb+my_project/src/lib+ are compiled aggressively with the
option \verb+-inline 10+, but files in \verb+my_project/src/lib+ are compiled normally.

   
% -*-
% Local Variables:
% Mode: LaTeX
% fill-column: 100
% TeX-master: "paper"
% TeX-command-default: "LaTeX/dvips Interactive"
% End:
% -*-
