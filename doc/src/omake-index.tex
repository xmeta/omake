%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Short description
%
\chapter{Description}
\label{chapter:omake}
\cutname{omake.html}

\Prog{omake} is designed for building projects that might have source files in several directories.
Projects are normally specified using an \File{OMakefile} in each of the project directories, and an
\File{OMakeroot} file in the root directory of the project.  The \File{OMakeroot} file specifies
general build rules, and the \File{OMakefile}s specify the build parameters specific to each of the
subdirectories.  When \Prog{omake} runs, it walks the configuration tree, evaluating rules from all
of the \File{OMakefile}s.  The project is then built from the entire collection of build rules.

\section{Automatic dependency analysis}

Dependency analysis has always been problematic with the \Cmd{make}{1} program.  \Prog{omake}
addresses this by adding the \verb+.SCANNER+ target, which specifies a command to produce
dependencies.  For example, the following rule

\begin{verbatim}
    .SCANNER: %.o: %.c
        $(CC) $(INCLUDE) -MM $<
\end{verbatim}

is the standard way to generate dependencies for \verb+.c+ files.  \Prog{omake} will automatically
run the scanner when it needs to determine dependencies for a file.

\section{Content-based dependency analysis}

Dependency analysis in omake uses MD5 digests to determine whether files have changed.  After each
run, \Prog{omake} stores the dependency information in a file called \File{.omakedb} in the project
root directory.  When a rule is considered for execution, the command is not executed if the target,
dependencies, and command sequence are unchanged since the last run of \Prog{omake}.  As an
optimization, \Prog{omake} does not recompute the digest for a file that has an unchanged
modification time, size, and inode number.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% References
%
See the following manual pages for more information.

\section{Guide}
\label{section:guide}

If you are new to OMake, you the \href{omake-quickstart.html}{omake-quickstart} presents a short
introduction that describes how to set up a project.  The
\href{omake-build-examples.html}{omake-build-examples} gives larger examples of build projects, and
\href{omake-language-examples.html}{omake-language-examples} presents programming examples.

\begin{description}
\item[Quickstart \ref{chapter:quickstart}]
%
   A quickstart guide to using \Prog{omake}.
\item[Build examples \ref{chapter:build-examples}]
%
   Advanced build examples.
\item[The OMake language~\ref{chapter:language}]
%
   The \Prog{omake} language, including a description of objects, expressions, and values.
\item[Language examples \ref{chapter:language-examples}]
%
   Advanced language examples.
\item[Build rules~\ref{chapter:rules}]
%
   Using \Prog{omake} rules to build program.
\item[Base builtin functions~\ref{chapter:base}]
%
   Functions and variables in the core standard library.
\item[System functions~\ref{chapter:system}]
%
   Functions on files, input/output, and system commands.
\item[Shell commands~\ref{chapter:shell}]
%
   Using the \Prog{omake} shell for command-line interpretation.
\item[The standard objects Pervasives.om~\ref{chapter:pervasives}]
%
   Pervasives defines the built-in objects.
\item[Standard build functions~\ref{chapter:rule}]
%
   The standard build library.
\item[The interactive command interpreter~\ref{chapter:osh}]
%
   The \Prog{osh} command-line interpreter.
\item[\textbf{Appendices}]
\begin{description}
\item[OMake command-line options~\ref{chapter:options}]
%
   Command-line options for \Prog{omake}.
%
\item[The OMake language grammar~\ref{chapter:grammar}]
%
   A more precise specification of the OMake language.
\end{description}
\item[\href{omake-doc.html}{All the documentation on a single page}]
%
   All the OMake documentation in a single page.
\end{description}

% -*-
% Local Variables:
% Mode: LaTeX
% fill-column: 100
% TeX-master: "paper"
% TeX-command-default: "LaTeX/dvips Interactive"
% End:
% -*-
