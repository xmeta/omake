%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Description
%
\chapter{OMake concepts and syntax}
\label{chapter:language}
\cutname{omake-language.html}

Projects are specified to \Prog{omake} with \File{OMakefile}s.  The \File{OMakefile} has a format
similar to a \File{Makefile}.  An \File{OMakefile} has three main kinds of syntactic objects:
variable definitions, function definitions, and rule definitions.

\section{Variables}
\label{section:variables}

Variables are defined with the following syntax.  The name is any sequence of alphanumeric
characters, underscore \verb+_+, and hyphen \verb+-+.

\begin{verbatim}
   <name> = <value>
\end{verbatim}

Values are defined as a sequence of literal characters and variable expansions.  A variable
expansion has the form \verb+$(<name>)+, which represents the value of the \verb+<name>+
variable in the current environment.  Some examples are shown below.

\begin{verbatim}
   CC = gcc
   CFLAGS = -Wall -g
   COMMAND = $(CC) $(CFLAGS) -O2
\end{verbatim}

In this example, the value of the \verb+COMMAND+ variable is the string \verb+gcc -Wall -g -O2+.

Unlike \Cmd{make}{1}, variable expansion is \emph{eager} and \emph{functional} (see also the section
on Scoping).  That is, variable values are expanded immediately and new variable definitions do not
affect old ones.  For example, suppose we extend the previous example with following variable
definitions.

\begin{verbatim}
   X = $(COMMAND)
   COMMAND = $(COMMAND) -O3
   Y = $(COMMAND)
\end{verbatim}

In this example, the value of the \verb+X+ variable is the string \verb+gcc -Wall -g -O2+ as
before, and the value of the \verb+Y+ variable is \verb+gcc -Wall -g -O2 -O3+.

\section{Adding to a variable definition}

Variables definitions may also use the += operator, which adds the new text to an existing
definition.  The following two definitions are equivalent.

\begin{verbatim}
   # Add options to the CFLAGS variable
   CFLAGS = $(CFLAGS) -Wall -g

   # The following definition is equivalent
   CFLAGS += -Wall -g
\end{verbatim}

\section{Arrays}
\index{arrays}

Arrays can be defined by appending the \verb+[]+ sequence to the variable name and defining initial
values for the elements as separate lines.  Whitespace is significant on each line.  The following
code sequence prints \verb+c d e+.

\begin{verbatim}
    X[] =
        a b
        c d e
        f

    println($(nth 2, $(X)))
\end{verbatim}

\section{Special characters and quoting}
\index{quotations}

The following characters are special to \Prog{omake}: \verb+$():,=#\+.  To treat
any of these characters as normal text, they should be escaped with the backslash
character \verb+\+.

\begin{verbatim}
    DOLLAR = \$
\end{verbatim}

Newlines may also be escaped with a backslash to concatenate several lines.

\begin{verbatim}
    FILES = a.c\
            b.c\
            c.c
\end{verbatim}

Note that the backslash is \emph{not} an escape for any other character, so the following
works as expected (that is, it preserves the backslashes in the string).

\begin{verbatim}
    DOSTARGET = C:\WINDOWS\control.ini
\end{verbatim}

An alternative mechanism for quoting special text is the use \verb+$"..."+ escapes.  The number of
double-quotations is arbitrary.  The outermost quotations are not included in the text.

\begin{verbatim}
    A = $""String containing "quoted text" ""
    B = $"""Multi-line
        text.
        The # character is not special"""
\end{verbatim}

\section{Function definitions}
\label{section:functions}
\index{functions}

Functions are defined using the following syntax.

\begin{verbatim}
   <name>(<params>) =
      <indented-body>
\end{verbatim}

The parameters are a comma-separated list of identifiers, and the body must be placed on a separate
set of lines that are indented from the function definition itself.  For example, the following text
defines a function that concatenates its arguments, separating them with a colon.

\begin{verbatim}
    ColonFun(a, b) =
        return($(a):$(b))
\end{verbatim}

The \verb+return+ expression can be used to return a value from the function.  A \verb+return+
statement is not required; if it is omitted, the returned value is the value of the last expression
in the body to be evaluated.  NOTE: as of version \verb+0.9.6+, \verb+return+ is a control
operation, causing the function to immediately return.  In the following example, when the argument
\verb+a+ is true, the function \verb+f+ immediately returns the value 1 without evaluating the print
statement.

\begin{verbatim}
    f(a) =
       if $(a)
          return 1
       println(The argument is false)
       return 0
\end{verbatim}

In many cases, you may wish to return a value from a section or code block without returning from
the function.  In this case, you would use the \verb+value+ operator.  In fact, the \verb+value+
operator is not limited to functions, it can be used any place where a value is required.  In the
following definition, the variable \verb+X+ is defined as $1$ or $2$, depending on the value of $a$,
then result is printed, and returned from the function.

\begin{verbatim}
    f_value(a) =
       X =
          if $(a)
             value 1
          else
             value 2
       println(The value of X is $(X))
       value $(X)
\end{verbatim}

Functions are called using the GNU-make syntax, \verb+$(<name> <args))+,
where \verb+<args>+ is a comma-separated list of values.  For example,
in the following program, the variable \verb+X+ contains the
value \verb+foo:bar+.

\begin{verbatim}
   X = $(ColonFun foo, bar)
\end{verbatim}

If the value of a function is not needed, the function may also be called
using standard function call notation.  For example, the following program
prints the string ``She says: Hello world''.

\begin{verbatim}
    Printer(name) =
        println($(name) says: Hello world)

    Printer(She)
\end{verbatim}

\section{Comments}

Comments begin with the \verb+#+ character and continue to the end of the line.

\section{File inclusion}
\label{section:include}
\index{include}
\index[fun]{include}

Files may be included with the \verb+include+ form.  The included file must use
the same syntax as an \File{OMakefile}.

\begin{verbatim}
    include files.omake
\end{verbatim}

%%%
%%% This stuff is not finished, so we are not advertizing its availability.
%%%

% The \verb+open+ operation is similar to an \verb+include+, but the file is included at most once.
% If the file specified is not an absolute or relative filenmame, \verb+open+ operation searches for the file
% based on the \verb+OMAKEPATH+ environment variable.  Searching is performed at \emph{parse} time.
%
% \begin{verbatim}
%     open Config
%
%     # Repeated opens are ignored, so this
%     # line has no effect.
%     open Config
% \end{verbatim}

\section{Scoping, sections}
\label{section:section}
\index{section}

Scopes in \Prog{omake} are defined by indentation level.  When indentation is
increased, such as in the body of a function, a new scope is introduced.

The \verb+section+ form can also be used to define a new scope.  For example, the following code
prints the line \verb+X = 2+, followed by the line \verb+X = 1+.

\begin{verbatim}
    X = 1
    section
        X = 2
        println(X = $(X))

    println(X = $(X))
\end{verbatim}

This result may seem surprising--the variable definition within the
\verb+section+ is not visible outside the scope of the \verb+section+.

The \verb+export+ form can be used to circumvent this restriction by
exporting variable values from an inner scope.  It must be the final
expression in a scope.  For example, if we modify the previous example
by adding an \verb+export+ expression, the new value for the \verb+X+
variable is retained, and the code prints the line \verb+X = 2+ twice.

\begin{verbatim}
    X = 1
    section
        X = 2
        println(X = $(X))
        export

    println(X = $(X))
\end{verbatim}

There are also cases where separate scoping is quite important.  For example,
each \File{OMakefile} is evaluated in its own scope.  Since each part of a project
may have its own configuration, it is important that variable definitions in one
\File{OMakefile} do not affect the definitions in another.

To give another example, in some cases it is convenient to specify a
separate set of variables for different build targets.  A frequent
idiom in this case is to use the \verb+section+ command to define a
separate scope.

\begin{verbatim}
   section
      CFLAGS += -g
      %.c: %.y
          $(YACC) $<
      .SUBDIRS: foo

   .SUBDIRS: bar baz
\end{verbatim}

In this example, the \verb+-g+ option is added to the \verb+CFLAGS+
variable by the \verb+foo+ subdirectory, but not by the \verb+bar+ and
\verb+baz+ directories. The implicit rules are scoped as well and in this
example, the newly added yacc rule will be inherited by the \verb+foo+
subdirectory, but not by the \verb+bar+ and \verb+baz+ ones; furthermore
this implicit rule will not be in scope in the current directory.

\section{Conditionals}
\label{section:conditionals}
\index{conditionals}
\index{if}

Top level conditionals have the following form.

\begin{verbatim}
    if <test>
       <true-clause>
    elseif <text>
       <elseif-clause>
    else
       <else-clause>
\end{verbatim}

The \verb+<test>+ expression is evaluated, and if it evaluates to a \emph{true} value (see
Section~\ref{section:logic} for more information on logical values, and Boolean functions), the code
for the \verb+<true-clause>+ is evaluated; otherwise the remaining clauses are evaluated.  There may
be multiple \verb+elseif+ clauses; both the \verb+elseif+ and \verb+else+ clauses are optional.
Note that the clauses are indented, so they introduce new scopes.

When viewed as a predicate, a value corresponds to the Boolean \emph{false}E, if its string
representation is the empty string, or one of the strings \verb+false+, \verb+no+, \verb+nil+,
\verb+undefined+, or \verb+0+.  All other values are \emph{true}.

The following example illustrates a typical use of a conditional.  The
\verb+OSTYPE+ variable is the current machine architecture.

\begin{verbatim}
    # Common suffixes for files
    if $(equal $(OSTYPE), Win32)
       EXT_LIB = .lib
       EXT_OBJ = .obj
       EXT_ASM = .asm
       EXE = .exe
       export
    elseif $(mem $(OSTYPE), Unix Cygwin)
       EXT_LIB = .a
       EXT_OBJ = .o
       EXT_ASM = .s
       EXE =
       export
    else
       # Abort on other architectures
       eprintln(OS type $(OSTYPE) is not recognized)
       exit(1)
\end{verbatim}

\section{Matching}
\label{section:match}
\index{switch}
\index{match}
\index[fun]{switch}
\index[fun]{match}

Pattern matching is performed with the \verb+switch+ and \verb+match+ forms.

\begin{verbatim}
    switch <string>
    case <pattern1>
        <clause1>
    case <pattern2>
        <clause2>
    ...
    default
       <default-clause>
\end{verbatim}

The number of cases is arbitrary.
The \verb+default+ clause is optional; however, if it is used it should
be the last clause in the pattern match.

For \verb+switch+, the string is compared with the patterns literally.

\begin{verbatim}
    switch $(HOST)
    case mymachine
        println(Building on mymachine)
    default
        println(Building on some other machine)
\end{verbatim}

Patterns need not be constant strings.  The following function tests
for a literal match against \verb+pattern1+, and a match against
\verb+pattern2+ with \verb+##+ delimiters.

\begin{verbatim}
   Switch2(s, pattern1, pattern2) =
      switch $(s)
      case $(pattern1)
          println(Pattern1)
      case $"##$(pattern2)##"
          println(Pattern2)
      default
          println(Neither pattern matched)
\end{verbatim}

For \verb+match+ the patterns are \Cmd{egrep}{1}-style regular expressions.
The numeric variables \verb+$1, $2, ...+ can be used to retrieve values
that are matched by \verb+\(...\)+ expressions.

\begin{verbatim}
    match $(NODENAME)@$(SYSNAME)@$(RELEASE)
    case $"mymachine.*@\(.*\)@\(.*\)"
        println(Compiling on mymachine; sysname $1 and release $2 are ignored)

    case $".*@Linux@.*2\.4\.\(.*\)"
        println(Compiling on a Linux 2.4 system; subrelease is $1)

    default
        eprintln(Machine configuration not implemented)
        exit(1)
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Objects
%
\section{Objects}
\label{section:objects}
\index{objects}

OMake is an object-oriented language.  Generally speaking, an object is a value that contains fields
and methods.  An object is defined with a \verb+.+ suffix for a variable.  For example, the
following object might be used to specify a point $(1, 5)$ on the two-dimensional plane.

\begin{verbatim}
    Coord. =
        x = 1
        y = 5
        print(message) =
           println($"$(message): the point is ($(x), $(y)")

    # Define X to be 5
    X = $(Coord.x)

    # This prints the string, "Hi: the point is (1, 5)"
    Coord.print(Hi)
\end{verbatim}

The fields \verb+x+ and \verb+y+ represent the coordinates of the point.  The method \verb+print+
prints out the position of the point.

\section{Classes}
\index{classes}

We can also define \emph{classes}.  For example, suppose we wish to define a generic \verb+Point+
class with some methods to create, move, and print a point.  A class is really just an object with
a name, defined with the \verb+class+ directive.

\begin{verbatim}
    Point. =
        class Point

        # Default values for the fields
        x = 0
        y = 0

        # Create a new point from the coordinates
        new(x, y) =
           this.x = $(x)
           this.y = $(y)
           return $(this)

        # Move the point to the right
        move-right() =
           x = $(add $(x), 1)
           return $(this)

        # Print the point
        print() =
           println($"The point is ($(x), $(y)")

    p1 = $(Point.new 1, 5)
    p2 = $(p1.move-right)

    # Prints "The point is (1, 5)"
    p1.print()

    # Prints "The point is (2, 5)"
    p2.print()
\end{verbatim}

Note that the variable \verb+$(this)+ is used to refer to the current object.  Also, classes and
objects are \emph{functional}---the \verb+new+ and \verb+move-right+ methods return new objects.  In
this example, the object \verb+p2+ is a different object from \verb+p1+, which retains the original
$(1, 5)$ coordinates.

\section{Inheritance}
\index{inheritance}

Classes and objects support inheritance (including multiple inheritance) with the \verb+extends+
directive.  The following definition of \verb+Point3D+ defines a point with \verb+x+, \verb+y+, and
\verb+z+ fields.  The new object inherits all of the methods and fields of the parent classes/objects.

\begin{verbatim}
    Z. =
       z = 0

    Point3D. =
       extends $(Point)
       extends $(Z)
       class Point3D

       print() =
          println($"The 3D point is ($(x), $(y), $(z))")

    # The "new" method was not redefined, so this
    # defines a new point (1, 5, 0).
    p = $(Point3D.new 1, 5)
\end{verbatim}

\section{Special objects/sections}

Objects provide one way to manage the OMake namespace.  There are also four special objects that are
further used to control the namespace.

\section{private.}
\index{private.}

The \verb+private.+ section is used to define variables that are private to the current file/scope.
The values are not accessible outside the scope.  Variables defined in a \verb+private.+ object can
be accessed only from within the section where they are defined.

\begin{verbatim}
    Obj. =
       private. =
          X = 1

       print() =
          println(The value of X is: $(X))

    # Prints:
    #    The private value of X is: 1
    Obj.print()

    # This is an error--X is private in Obj
    y = $(Obj.X)
\end{verbatim}

In addition, private definitions do not affect the global value of a variable.

\begin{verbatim}
   # The public value of x is 1
   x = 1
   f() =
       println(The public value of x is: $(x))

   # This object uses a private value of x
   Obj. =
       private. =
          x = 2

       print() =
          x = 3
          println(The private value of x is: $(x))
          f()

   # Prints:
   #    The private value of x is: 3
   #    The public value of x is: 1
   Obj.print()
\end{verbatim}

Private variables have two additional properties.

\begin{enumerate}
\item Private variables are local to the file in which they are defined.
\item Private variables are not exported by the \verb+export+ directive, unless they are
  mentioned explicitly.

  \begin{verbatim}
       private. =
          FLAG = true

       section
          FLAG = false
          export

       # FLAG is still true
       section
          FLAG = false
          export FLAG

       # FLAG is now false
  \end{verbatim}
\end{enumerate}

\section{protected.}
\index{protected.}

The \verb+protected.+ object is used to define fields that are local to an object.  They can
be accessed as fields, but they are not passed dynamically to other functions.  The purpose of a
protected variable is to prevent a variable definition within the object from affecting other parts
of the project.

\begin{verbatim}
    X = 1
    f() =
       println(The public value of X is: $(X))

    # Prints:
    #    The public value of X is: 2
    section
       X = 2
       f()

    # X is a protected field in the object
    Obj. =
       protected. =
          X = 3

       print() =
          println(The protected value of X is: $(X))
          f()

    # Prints:
    #    The protected value of X is: 3
    #    The public value of X is: 1
    Obj.print()

    # This is legal, it defines Y as 3
    Y = $(Obj.X)
\end{verbatim}

In general, it is a good idea to define object variables as protected.  The resulting code is more
modular because variables in your object will not produce unexpected clashes with variables defined
in other parts of the project.

\section{public.}
\index{public.}

The \verb+public.+ object is used to specify public dynamically-scoped variables.  In the following
example, the \verb+public.+ object specifies that the value \verb+X = 4+ is to be dynamically
scoped.  Public variables \emph{are not} defined as fields of an object.

\begin{verbatim}
    X = 1
    f() =
       println(The public value of X is: $(X))

    # Prints:
    #    The public value of X is: 2
    section
       X = 2
       f()

    Obj. =
       protected. =
          X = 3

       print() =
          println(The protected value of X is: $(X))
          public. =
             X = 4
          f()

    # Prints:
    #    The protected value of X is: 3
    #    The public value of X is: 4
    Obj.print()
\end{verbatim}

\section{static.}
\index{static.}

The \verb+static.+ object is used to specify values that are persistent across runs of OMake.  They
are frequently used for configuring a project.  Configuring a project can be expensive, so the
\verb+static.+ object ensure that the configuration is performed just once.  In the following
(somewhat trivial) example, a \verb+static+ section is used to determine if the \LaTeX\ command is
available.  The \verb+$(where latex)+ function returns the full pathname for \verb+latex+, or
\verb+false+ if the command is not found.

\begin{verbatim}
   static. =
      LATEX_ENABLED = false
      print(--- Determining if LaTeX is installed )
      if $(where latex)
          LATEX_ENABLED = true
          export

      if $(LATEX_ENABLED)
         println($'(enabled)')
      else
         println($'(disabled)')
\end{verbatim}

As a matter of style, a \verb+static.+ section that is used for configuration should print what it
is doing, using \verb+---+ as a print prefix.

\section{Short syntax for scoping objects}

The usual dot-notation can be used for private, protected, and public variables (but not
static variables).

\begin{verbatim}
    # Public definition of X
    public.X = 1

    # Private definition of X
    private.X = 2

    # Prints:
    #    The public value of X is: 1
    #    The private value of X is: 2
    println(The public value of X is: $(public.X))
    println(The private value of X is: $(private.X))
\end{verbatim}

\section{Modular programming}

The scoping objects help provide a form of modularity.  When you write a new file or program,
explicit scoping declarations can be used to define an explicit interface for your code, and help
avoid name clashes with other parts of the project.  Variable definitions are public by default, but
you can control this with private definitions.

\begin{verbatim}
    # These variables are private to this file
    private. =
       FILES = foo1 foo2 foo3
       SUFFIX = .o
       OFILES = $(addsuffix $(SUFFIX), $(FILES))

    # These variables are public
    public. =
       CFLAGS += -g

    # Build the files with the -g option
    $(OFILES):
\end{verbatim}

%%%
%%% This stuff is not finished, so we are not advertizing its availability.
%%%

% \section{Policy directives for scoping}
%
% In some cases, you may wish to be careful that you don't accidentally shadow public variables that
% may be used in other parts of the project.  Running \Prog{omake} with the \verb+--strict+ option
% will do two things.
%
% \begin{enumerate}
% \item In \verb+--strict+ mode, all variables must be declared before being used.
% \item In \verb+--strict+ mode, all new definitions are \verb+protected+ by default.
% \end{enumerate}
%
% You can also control the scoping policy on a per-file basis with the \verb+policy+ directive.  The
% \verb+policy scope=<options>+ directive is used to specify scoping options.  The options are a
% comma-separated list of options as follows.
%
% \begin{description}
% \item[strict] Variables must be defined or declared before they are used.
% \item[relaxed] Variables do not have to be defined or declared before being used.
% \item[private] The default scope is private.
% \item[protected] The default scope is protected.
% \item[public] The default scope is public.
% \end{description}
%
% One common style is to declare all variables in a file as private except for specific variables that
% are public.  The \verb+declare+ operator declares variables without defining them.
%
% \begin{verbatim}
%     # strict: variables must be declared or
%     #    defined before being used.
%     # private: the default scope for variables
%     #    is private.
%     policy scope=strict,private
%
%     # CC and CFLAGS are public variables.
%     public. =
%         declare CC CFLAGS
%
%     # The following variables are private definitions
%     FILES = foo1 foo2 foo3
%     SUFFIX = .o
%     OFILES = $(addsuffix $(SUFFIX), $(FILES))
%
%     # Build the files with gcc -g
%     CC = gcc
%     CFLAGS += -g
%     $(OFILES):
%
%     # The following private function definition
%     # refers to a public variable X explicitly;
%     # it is not an error.
%     f() =
%        println(The public value of X is: $(public.X))
%
%     # The following private function definition
%     # produces an error because the variable X
%     # has not been defined.
%     f() =
%        println(The value of X is: $(X))
% \end{verbatim}
%
% When scoping is \verb+strict+, the \verb+open+ directive can be used to import the variables from
% another file.  Since the variables \verb+CC+ and \verb+CFLAGS+ are defined in the system build file
% \verb+build/C+, instead of declaring them explicitly, we can open the \verb+C+ file.
%
% \begin{verbatim}
%     # strict: variables must be declared or
%     #    defined before being used.
%     # private: the default scope for variables
%     #    is private.
%     policy scope=strict,private
%
%     # Import public variables from the file C
%     open build/C
%
%     # The following variables are private definitions
%     FILES = foo1 foo2 foo3
%     ...
% \end{verbatim}

% -*-
% Local Variables:
% Mode: LaTeX
% fill-column: 100
% TeX-master: "paper"
% TeX-command-default: "LaTeX/dvips Interactive"
% End:
% -*-
