<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="generator" content="hevea 2.06">
<link rel="stylesheet" type="text/css" href="omake-doc.css">
<title>Base library</title>
</head>
<body>

<img src="../images/omake-manual.gif" border="0" align="top" alt=""><br>

<table class="c000 cellpading0"><tr><td class="c006">Jump to:</td><td class="c005">&#XA0;&#XA0;</td><td class="c006"><a href="../index.html">OMake Home</a>
&bull;&nbsp;<a href="omake.html">Guide Home</a>
&bull;&nbsp;<a href="omake-doc.html">Guide (single-page)</a>
&bull;&nbsp;<a href="omake-toc.html">Contents (short)</a>
&bull;&nbsp;<a href="omake-contents.html">Contents (long)</a></td></tr>
<tr><td class="c006">Index:</td><td class="c005">&#XA0;&#XA0;</td><td class="c006"><a href="omake-all-index.html">All</a>
&bull;&nbsp;<a href="omake-var-index.html">Variables</a>
&bull;&nbsp;<a href="omake-fun-index.html">Functions</a>
&bull;&nbsp;<a href="omake-obj-index.html">Objects</a>
&bull;&nbsp;<a href="omake-target-index.html">Targets</a>
&bull;&nbsp;<a href="omake-option-index.html">Options</a>
</td></tr>
</table>
<h1 class="chapter" id="sec104">Chapter&#XA0;9&#XA0;&#XA0;Base library</h1>
<ul>
<li><a href="omake-base.html#sec105">Builtin variables</a>
</li><li><a href="omake-base.html#sec121">Logic, Boolean functions, and control flow</a>
</li><li><a href="omake-base.html#sec139">Arrays and sequences</a>
</li><li><a href="omake-base.html#sec186">Arithmetic</a>
</li><li><a href="omake-base.html#sec191">First-class functions</a>
</li><li><a href="omake-base.html#sec196">Iteration and mapping</a>
</li><li><a href="omake-base.html#sec198">Boolean tests</a>
</li></ul>
<p>
<a id="chapter:base"></a>
</p>
<h2 class="section" id="sec105">9.1&#XA0;&#XA0;Builtin variables</h2>
<h5 class="paragraph" id="sec106">OMAKE_VERSION</h5>
<p><a id="var:OMAKE_VERSION"></a><a id="hevea_default67"></a><a id="hevea_var5"></a>
Version of OMake.
</p>
<h5 class="paragraph" id="sec107">STDLIB</h5>
<p><a id="var:STDLIB"></a><a id="hevea_default68"></a><a id="hevea_var6"></a>
The directory where the OMake standard library files reside. At startup, the default
value is determined as follows.
</p><ul class="itemize"><li class="li-itemize">
The value of the <code>OMAKELIB</code> environment variable, if set (must contain
an absolute path, if set), otherwise
</li><li class="li-itemize">On Windows, the registry keys <code>HKEY_CURRENT_USER\SOFTWARE\MetaPRL\OMake\OMAKELIB</code> and
<code>HKEY_LOCAL_MACHINE\SOFTWARE\MetaPRL\OMake\OMAKELIB</code> are looked up and the value is used,
if exist.
</li><li class="li-itemize">Otherwise a compile-time default it used.
</li></ul><p>
The current default value may be accessed by running <code>omake --version</code>
</p>
<h5 class="paragraph" id="sec108">OMAKEPATH</h5>
<p><a id="var:OMAKEPATH"></a><a id="hevea_default69"></a><a id="hevea_var7"></a>
An array of directories specifying the lookup path for the <code>include</code> and <code>open</code> directives (see
Section&#XA0;<a href="omake-language.html#section%3Ainclude">4.8</a>).
The default value is an array of two elements &#X2014; <code>.</code> and <code>$(STDLIB)</code>.
</p>
<h5 class="paragraph" id="sec109">OSTYPE</h5>
<p><a id="var:OSTYPE"></a><a id="hevea_default70"></a><a id="hevea_var8"></a>
Set to the machine architecture <span class="c001">omake</span> is running on. Possible values are
<code>Unix</code> (for all Unix versions, including Linux and Mac OS X), <code>Win32</code>
(for MS-Windows, OMake compiled with MSVC++ or Mingw), and <code>Cygwin</code> (for
MS-Windows, OMake compiled with Cygwin).
</p>
<h5 class="paragraph" id="sec110">SYSNAME</h5>
<p><a id="var:SYSNAME"></a><a id="hevea_default71"></a><a id="hevea_var9"></a>
The name of the operating system for the current machine.
</p>
<h5 class="paragraph" id="sec111">NODENAME</h5>
<p><a id="var:NODENAME"></a><a id="hevea_default72"></a><a id="hevea_var10"></a>
The hostname of the current machine.
</p>
<h5 class="paragraph" id="sec112">OS_VERSION</h5>
<p><a id="var:OS_VERSION"></a><a id="hevea_default73"></a><a id="hevea_var11"></a>
The operating system release.
</p>
<h5 class="paragraph" id="sec113">MACHINE</h5>
<p><a id="var:MACHINE"></a><a id="hevea_default74"></a><a id="hevea_var12"></a>
The machine architecture, e.g. <code>i386</code>, <code>sparc</code>, etc.
</p>
<h5 class="paragraph" id="sec114">HOST</h5>
<p><a id="var:HOST"></a><a id="hevea_default75"></a><a id="hevea_var13"></a>
Same as <code>NODENAME</code>.
</p>
<h5 class="paragraph" id="sec115">USER</h5>
<p><a id="var:USER"></a><a id="hevea_default76"></a><a id="hevea_var14"></a>
The login name of the user executing the process.
</p>
<h5 class="paragraph" id="sec116">HOME</h5>
<p><a id="var:HOME"></a><a id="hevea_default77"></a><a id="hevea_var15"></a>
The home directory of the user executing the process.
</p>
<h5 class="paragraph" id="sec117">PID</h5>
<p><a id="var:PID"></a><a id="hevea_default78"></a><a id="hevea_var16"></a>
The OMake process id.
</p>
<h5 class="paragraph" id="sec118">TARGETS</h5>
<p><a id="var:TARGETS"></a><a id="hevea_default79"></a><a id="hevea_var17"></a>
The command-line target strings. For example, if OMake is invoked with the
following command line,
</p><pre class="verbatim">      omake CFLAGS=1 foo bar.c
</pre><p>then <code>TARGETS</code> is defined as <code>foo bar.c</code>.</p>
<h5 class="paragraph" id="sec119">BUILD_SUMMARY</h5>
<p><a id="var:BUILD_SUMMARY"></a><a id="hevea_default80"></a><a id="hevea_var18"></a>
The <code>BUILD_SUMMARY</code> variable refers to the file that <code>omake</code> uses
to summarize a build (the message that is printed at the very end of a build).
The file is empty when the build starts. If you wish to add additional messages
to the build summary, you can edit/modify this file during the build.</p><p>For example, if you want to point out that some action was taken,
you can append a message to the build summary.</p><pre class="verbatim">   foo: boo
       echo "The file foo was built" &gt;&gt; $(BUILD_SUMMARY)
       ...build foo...
</pre>
<h5 class="paragraph" id="sec120">VERBOSE</h5>
<p><a id="var:VERBOSE"></a><a id="hevea_default81"></a><a id="hevea_var19"></a>
Whether certain commands should be verbose. A boolean flag that is <code>false</code>
by default and is set to <code>true</code> when OMake is invoked with the
<code>--verbose</code> option.
</p>
<h2 class="section" id="sec121">9.2&#XA0;&#XA0;Logic, Boolean functions, and control flow</h2>
<p>
<a id="section:logic"></a></p><p>Boolean values in omake are represented by case-insensitive strings. The
<em>false</em> value can be represented by the strings <code>false</code>, <code>no</code>,
<code>nil</code>, <code>undefined</code> or <code>0</code>, and everything else is true.</p>
<h3 class="subsection" id="sec122">9.2.1&#XA0;&#XA0;not</h3>
<p><a id="fun:not"></a><a id="function:not"></a><a id="hevea_default82"></a><a id="hevea_fun5"></a></p><pre class="verbatim">   $(not e) : String
      e : String
</pre><p>The <code>not</code> function negates a Boolean value.</p><p>For example, <code>$(not false)</code> expands to the string <code>true</code>, and
<code>$(not hello world)</code> expands to <code>false</code>.
</p>
<h3 class="subsection" id="sec123">9.2.2&#XA0;&#XA0;equal</h3>
<p><a id="fun:equal"></a><a id="function:equal"></a><a id="hevea_default83"></a><a id="hevea_fun6"></a></p><pre class="verbatim">   $(equal e1, e2) : String
      e1 : String
      e2 : String
</pre><p>The <code>equal</code> function tests for equality of two values.</p><p>For example <code>$(equal a, b)</code> expands to <code>false</code>, and <code>$(equal hello world, hello world)</code> expands to <code>true</code>.
</p>
<h3 class="subsection" id="sec124">9.2.3&#XA0;&#XA0;and</h3>
<p><a id="fun:and"></a><a id="function:and"></a><a id="hevea_default84"></a><a id="hevea_fun7"></a></p><pre class="verbatim">    $(and e1, ..., en) : String
       e1, ..., en: Sequence
</pre><p>The <code>and</code> function evaluates to the conjunction of its arguments.</p><p>For example, in the following code, <code>X</code> is true, and <code>Y</code> is false.</p><pre class="verbatim">    A = a
    B = b
    X = $(and $(equal $(A), a) true $(equal $(B), b))
    Y = $(and $(equal $(A), a) true $(equal $(A), $(B)))
</pre>
<h3 class="subsection" id="sec125">9.2.4&#XA0;&#XA0;or</h3>
<p><a id="fun:or"></a><a id="function:or"></a><a id="hevea_default85"></a><a id="hevea_fun8"></a></p><pre class="verbatim">   $(or e1, ..., en) : String
      e1, ..., en: String Sequence
</pre><p>The <code>or</code> function evaluates to the disjunction of its arguments.</p><p>For example, in the following code, <code>X</code> is true, and <code>Y</code> is false.</p><pre class="verbatim">    A = a
    B = b
    X = $(or $(equal $(A), a) false $(equal $(A), $(B)))
    Y = $(or $(equal $(A), $(B)) $(equal $(A), b))
</pre>
<h3 class="subsection" id="sec126">9.2.5&#XA0;&#XA0;if</h3>
<p><a id="fun:if"></a><a id="function:if"></a><a id="hevea_default86"></a><a id="hevea_fun9"></a><a id="hevea_default87"></a><a id="hevea_default88"></a></p><pre class="verbatim">    $(if e1, e2[, e3]) : value
       e1 : String
       e2, e3 : value
</pre><p>The <code>if</code> function represents a conditional based on a Boolean value.
For example <code>$(if $(equal a, b), c, d)</code> evaluates to <code>d</code>.</p><p>Conditionals may also be declared with an alternate syntax.</p><pre class="verbatim">   if e1
      body1
   elseif e2
      body2
   ...
   else
      bodyn
</pre><p>If the expression <code>e1</code> is not false, then the expressions in <code>body1</code>
are evaluated and the result is returned as the value of the conditional. Otherwise,
if <code>e1</code> evaluates to false, the evaluation continues with the <code>e2</code>
expression. If none of the conditional expressions is true, then the expressions
in <code>bodyn</code> are evaluated and the result is returned as the value
of the conditional.</p><p>There can be any number of <code>elseif</code> clauses; the <code>else</code> clause is
optional.</p><p>Note that each branch of the conditional defines its own scope, so variables
defined in the branches are normally not visible outside the conditional.
The <code>export</code> command may be used to export the variables defined in
a scope. For example, the following expression represents a common idiom
for defining the C compiler configuration.</p><pre class="verbatim">   if $(equal $(OSTYPE), Win32)
      CC = cl
      CFLAGS += /DWIN32
      export
   else
      CC = gcc
      CFLAGS += -g -O2
      export
</pre>
<h3 class="subsection" id="sec127">9.2.6&#XA0;&#XA0;switch, match</h3>
<p><a id="fun:switch"></a><a id="function:switch"></a><a id="hevea_default89"></a><a id="hevea_fun10"></a><a id="fun:match"></a><a id="function:match"></a><a id="hevea_default90"></a><a id="hevea_fun11"></a><a id="hevea_default91"></a><a id="hevea_default92"></a></p><p>The <code>switch</code> and <code>match</code> functions perform pattern matching.</p><p><code>$(switch &lt;arg&gt;, &lt;pattern_1&gt;, &lt;value_1&gt;, ..., &lt;pattern_n&gt;, &lt;value_n&gt;)</code>
<code>$(match &lt;arg&gt;, &lt;pattern_1&gt;, &lt;value_1&gt;, ..., &lt;pattern_n&gt;, &lt;value_n&gt;)</code></p><p>The number of <code>&lt;pattern&gt;/&lt;value&gt;</code> pairs is arbitrary. They strictly
alternate; the total number of arguments to <code>&lt;match&gt;</code> must be odd.</p><p>The <code>&lt;arg&gt;</code> is evaluated to a string, and compared with <code>&lt;pattern_1&gt;</code>.
If it matches, the result of the expression is <code>&lt;value_1&gt;</code>. Otherwise
evaluation continues with the remaining patterns until a match is found.
If no pattern matches, the value is the empty string.</p><p>The <code>switch</code> function uses string comparison to compare
the argument with the patterns. For example, the following
expression defines the <code>FILE</code> variable to be either
<code>foo</code>, <code>bar</code>, or the empty string, depending
on the value of the <code>OSTYPE</code> variable.</p><pre class="verbatim">    FILE = $(switch $(OSTYPE), Win32, foo, Unix, bar)
</pre><p>The <code>match</code> function uses regular expression patterns (see the
<code>grep</code> function). If a match is found, the variables
<code>$1, $2, ...</code> are bound to the substrings matched between
<code>\(</code> and <code>\)</code> delimiters.
The <code>$0</code> variable contains the entire match, and <code>$*</code>
is an array of the matched substrings.
to the matched substrings.</p><pre class="verbatim">    FILE = $(match foo_xyz/bar.a, foo_\\\(.*\\\)/\\\(.*\\\)\.a, foo_$2/$1.o)
</pre><p>The <code>switch</code> and <code>match</code> functions also have an alternate (more usable)
form.</p><pre class="verbatim">   match e
   case pattern1
      body1
   case pattern2
      body2
   ...
   default
      bodyd
</pre><p>If the value of expression <code>e</code> matches <code>pattern_i</code> and no previous pattern,
then <code>body_i</code> is evaluated and returned as the result of the <code>match</code>.
The <code>switch</code> function uses string comparison; the <code>match</code> function
uses regular expression matching.</p><pre class="verbatim">   match $(FILE)
   case $".*\(\.[^\/.]*\)"
      println(The string $(FILE) has suffix $1)
   default
      println(The string $(FILE) has no suffix)
</pre>
<h3 class="subsection" id="sec128">9.2.7&#XA0;&#XA0;try</h3>
<p><a id="fun:try"></a><a id="function:try"></a><a id="hevea_default93"></a><a id="hevea_fun12"></a></p><pre class="verbatim">   try
      try-body
   catch class1(v1)
      catch-body
   when expr
      when-body
   ...
   finally
      finally-body
</pre><p>The <code>try</code> form is used for exception handling.
First, the expressions in the <code>try-body</code> are evaluated.</p><p>If evaluation results in a value <code>v</code> without raising an
exception, then the expressions in the <code>finally-body</code>
are evaluated and the value <code>v</code> is returned as the result.</p><p>If evaluation of the <code>try-body</code> results in a exception object <code>obj</code>,
the <code>catch</code> clauses are examined in order. When examining <code>catch</code>
clause <code>catch class(v)</code>, if the exception object <code>obj</code>
is an instance of the class name <code>class</code>, the variable <code>v</code> is bound
to the exception object, and the expressions in the <code>catch-body</code>
are evaluated.</p><p>If a <code>when</code> clause is encountered while a <code>catch</code> body is being evaluated,
the predicate <code>expr</code> is evaluated. If the result is true, evaluation continues
with the expressions in the <code>when-body</code>. Otherwise, the next <code>catch</code>
clause is considered for evaluation.</p><p>If evaluation of a <code>catch-body</code> or <code>when-body</code> completes successfully,
returning a value <code>v</code>, without encountering another <code>when</code> clause,
then the expressions in the <code>finally-body</code>
are evaluated and the value <code>v</code> is returned as the result.</p><p>There can be any number of <code>catch</code> clauses; the <code>finally</code> clause
is optional.
</p>
<h3 class="subsection" id="sec129">9.2.8&#XA0;&#XA0;raise</h3>
<p><a id="fun:raise"></a><a id="function:raise"></a><a id="hevea_default94"></a><a id="hevea_fun13"></a></p><pre class="verbatim">   raise exn
      exn : Exception
</pre><p>The <code>raise</code> function raises an exception.
The <code>exn</code> object can be any object. However,
the normal convention is to raise an <a href="omake-pervasives.html#obj%3AException"><CODE>Exception</CODE> object</a>.</p><p>If the exception is never caught, the whole object will be verbosely
printed in the error message. However, if the object is an <code>Exception</code> one
and contains a <code>message</code> field, only that field will be included in the
error message.
</p>
<h3 class="subsection" id="sec130">9.2.9&#XA0;&#XA0;exit</h3>
<p><a id="fun:exit"></a><a id="function:exit"></a><a id="hevea_default95"></a><a id="hevea_fun14"></a></p><pre class="verbatim">   exit(code)
      code : Int
</pre><p>The <code>exit</code> function terminates <span class="c001">omake</span> abnormally.</p><p><code>$(exit &lt;code&gt;)</code></p><p>The <code>exit</code> function takes one integer argument, which is exit code.
Non-zero values indicate abnormal termination.
</p>
<h3 class="subsection" id="sec131">9.2.10&#XA0;&#XA0;defined</h3>
<p><a id="fun:defined"></a><a id="function:defined"></a><a id="hevea_default96"></a><a id="hevea_fun15"></a></p><pre class="verbatim">   $(defined sequence) : String
      sequence : Sequence
</pre><p>The <code>defined</code> function test whether all the variables in the sequence are
currently defined. For example, the following code defines the <code>X</code> variable
if it is not already defined.</p><pre class="verbatim">    if $(not $(defined X))
       X = a b c
       export
</pre><p>It is acceptable to use qualified names.</p><pre class="verbatim">    $(defined X.a.b)
    $(defined public.X)
</pre>
<h3 class="subsection" id="sec132">9.2.11&#XA0;&#XA0;defined-env</h3>
<p><a id="fun:defined-env"></a><a id="function:defined-env"></a><a id="hevea_default97"></a><a id="hevea_fun16"></a></p><pre class="verbatim">   $(defined-env sequence) : String
      sequence : String
</pre><p>The <code>defined-env</code> function tests whether a variable is defined
as part of the process environment.</p><p>For example, the following code adds the <code>-g</code> compile
option if the environment variable <code>DEBUG</code> is defined.</p><pre class="verbatim">if $(defined-env DEBUG)
    CFLAGS += -g
    export
</pre>
<h3 class="subsection" id="sec133">9.2.12&#XA0;&#XA0;getenv</h3>
<p><a id="fun:getenv"></a><a id="function:getenv"></a><a id="hevea_default98"></a><a id="hevea_fun17"></a></p><pre class="verbatim">   $(getenv name) : String
   $(getenv name, default) : String
</pre><p>The <code>getenv</code> function gets the value of a variable from
the process environment. The function takes one or two arguments.</p><p>In the single argument form, an exception is raised if the variable
variable is not defined in the environment. In the two-argument form,
the second argument is returned as the result if the value is not
defined.</p><p>For example, the following code defines the variable <code>X</code>
to be a space-separated list of elements of the <code>PATH</code>
environment variable if it is defined, and to <code>/bin /usr/bin</code>
otherwise.</p><pre class="verbatim">    X = $(split $(PATHSEP), $(getenv PATH, /bin:/usr/bin))
</pre><p>You may also use the alternate form.
</p><pre class="verbatim">     getenv(NAME)
         default
</pre>
<h3 class="subsection" id="sec134">9.2.13&#XA0;&#XA0;setenv</h3>
<p><a id="fun:setenv"></a><a id="function:setenv"></a><a id="hevea_default99"></a><a id="hevea_fun18"></a></p><pre class="verbatim">   setenv(name, value)
      name : String
      value : String
</pre><p>The <code>setenv</code> function sets the value of a variable in
the process environment. Environment variables are scoped
like normal variables.</p>
<h3 class="subsection" id="sec135">9.2.14&#XA0;&#XA0;unsetenv</h3>
<p><a id="fun:unsetenv"></a><a id="function:unsetenv"></a><a id="hevea_default100"></a><a id="hevea_fun19"></a></p><pre class="verbatim">   unsetenv(names)
      names : String Array
</pre><p>The <code>unsetenv</code> function removes some variable definitions from
the process environment. Environment variables are scoped
like normal variables.</p>
<h3 class="subsection" id="sec136">9.2.15&#XA0;&#XA0;get-registry</h3>
<p><a id="fun:get-registry"></a><a id="function:get-registry"></a><a id="hevea_default101"></a><a id="hevea_fun20"></a></p><pre class="verbatim">   get-registry(hkey, key, field) : String
   get-registry(hkey, key, field, default) : String
       hkey : String
       key : String
       field : String
</pre><p>The <code>get-registry</code> function retrieves a string value from the
system registry on Win32. On other architectures, there is no
registry.</p><p>The <code>hive</code> (I think that is the right word), indicates which part
of the registry to use. It should be one of the following values.</p><ul class="itemize"><li class="li-itemize">
<code>HKEY_CLASSES_ROOT</code>
</li><li class="li-itemize"><code>HKEY_CURRENT_CONFIG</code>
</li><li class="li-itemize"><code>HKEY_CURRENT_USER</code>
</li><li class="li-itemize"><code>HKEY_LOCAL_MACHINE</code>
</li><li class="li-itemize"><code>HKEY_USERS</code>
</li></ul><p>
Refer to the Microsoft documentation if you want to know what these mean.</p><p>The <code>key</code> is the field you want to get from the registry.
It should have a form like <code>A\B\C</code> (if you use forward slashes, they will
be converted to backslashes). The field is the sub-field of the key.</p><p>In the 4-argument form, the <code>default</code> is returned on failure.
You may also use the alternate form.</p><pre class="verbatim">    get-registry(hkey, key, field)
       default
</pre>
<h3 class="subsection" id="sec137">9.2.16&#XA0;&#XA0;getvar</h3>
<p><a id="fun:getvar"></a><a id="function:getvar"></a><a id="hevea_default102"></a><a id="hevea_fun21"></a></p><pre class="verbatim">   $(getvar name) : String
</pre><p>The <code>getvar</code> function gets the value of a variable.</p><p>An exception is raised if the variable
variable is not defined.</p><p>For example, the following code defines X to be the string abc.</p><pre class="verbatim">    NAME = foo
    foo_1 = abc
    X = $(getvar $(NAME)_1)
</pre><p>It is acceptable to use qualified names.</p><pre class="verbatim">    $(getvar X.a.b)
</pre>
<h3 class="subsection" id="sec138">9.2.17&#XA0;&#XA0;setvar</h3>
<p><a id="fun:setvar"></a><a id="function:setvar"></a><a id="hevea_default103"></a><a id="hevea_fun22"></a></p><pre class="verbatim">   setvar(name, value)
      name : String
      value : String
</pre><p>The <code>setvar</code> function defines a new variable. For example, the
following code defines the variable <code>X</code> to be the string <code>abc</code>.</p><pre class="verbatim">   NAME = X
   setvar($(NAME), abc)
</pre><p>It is acceptable to use qualified names.</p><pre class="verbatim">    setvar(public.X, abc)
</pre>
<h2 class="section" id="sec139">9.3&#XA0;&#XA0;Arrays and sequences</h2>
<h3 class="subsection" id="sec140">9.3.1&#XA0;&#XA0;array</h3>
<p><a id="fun:array"></a><a id="function:array"></a><a id="hevea_default104"></a><a id="hevea_fun23"></a></p><pre class="verbatim">    $(array elements) : Array
       elements : Sequence
</pre><p>The <code>array</code> function creates an array from a sequence.
If the <code>&lt;arg&gt;</code> is a string, the elements of the array
are the whitespace-separated elements of the string, respecting
quotes.</p><p>In addition, array variables can be declared as follows.</p><pre class="verbatim">    A[] =
       &lt;val1&gt;
       ...
       &lt;valn&gt;
</pre><p>In this case, the elements of the array are exactly
<code>&lt;val1&gt;</code>, ..., <code>&lt;valn&gt;</code>, and whitespace is
preserved literally.
</p>
<h3 class="subsection" id="sec141">9.3.2&#XA0;&#XA0;split</h3>
<p><a id="fun:split"></a><a id="function:split"></a><a id="hevea_default105"></a><a id="hevea_fun24"></a></p><pre class="verbatim">   $(split sep, elements) : Array
      sep : String
      elements : Sequence
</pre><p>The <code>split</code> function takes two arguments, a string of separators, and
a string argument. The result is an array of elements determined by
splitting the elements by all occurrence of the separator in the
<code>elements</code> sequence.</p><p>For example, in the following code, the <code>X</code> variable is
defined to be the array <code>/bin /usr/bin /usr/local/bin</code>.</p><pre class="verbatim">    PATH = /bin:/usr/bin:/usr/local/bin
    X = $(split :, $(PATH))
</pre><p>The <code>sep</code> argument may be omitted. In this case <code>split</code> breaks its
arguments along the white space. Quotations are not split.
</p>
<h3 class="subsection" id="sec142">9.3.3&#XA0;&#XA0;concat</h3>
<p><a id="fun:concat"></a><a id="function:concat"></a><a id="hevea_default106"></a><a id="hevea_fun25"></a></p><pre class="verbatim">   $(concat sep, elements) : String
      sep : String
      elements : Sequence
</pre><p>The <code>concat</code> function takes two arguments, a separator string, and
a sequence of elements. The result is a string formed by concatenating
the elements, placing the separator between adjacent elements.</p><p>For example, in the following code, the <code>X</code> variable is
defined to be the string <code>foo_x_bar_x_baz</code>.</p><pre class="verbatim">    X = foo  bar     baz
    Y = $(concat _x_, $(X))
</pre>
<h3 class="subsection" id="sec143">9.3.4&#XA0;&#XA0;length</h3>
<p><a id="fun:length"></a><a id="function:length"></a><a id="hevea_default107"></a><a id="hevea_fun26"></a></p><pre class="verbatim">   $(length sequence) : Int
      sequence : Sequence
</pre><p>The <code>length</code> function returns the number of elements in its argument.</p><p>For example, the expression <code>$(length a  b "c d")</code> evaluates to 3.
</p>
<h3 class="subsection" id="sec144">9.3.5&#XA0;&#XA0;nth</h3>
<p><a id="fun:nth"></a><a id="function:nth"></a><a id="hevea_default108"></a><a id="hevea_fun27"></a></p><pre class="verbatim">   $(nth i, sequence) : value
      i : Int
      sequence : Sequence
   raises RuntimeException
</pre><p>The <code>nth</code> function returns the nth element of its argument, treated as
a list. Counting starts at 0. An exception is raised if the index is not in bounds.</p><p>For example, the expression <code>$(nth 1, a "b c" d)</code> evaluates to <code>"b c"</code>.</p>
<h3 class="subsection" id="sec145">9.3.6&#XA0;&#XA0;replace-nth</h3>
<p><a id="fun:replace-nth"></a><a id="function:replace-nth"></a><a id="hevea_default109"></a><a id="hevea_fun28"></a></p><pre class="verbatim">   $(replace-nth i, sequence, x) : value
      i : Int
      sequence : Sequence
      x : value
   raises RuntimeException
</pre><p>The <code>replace-nth</code> function replaces the nth element of its argument with a new
value <code>x</code>. Counting starts at 0. An exception is raised if the index is not in bounds.</p><p>For example, the expression <code>$(replace-nth 1, a "b c" d, x)</code> evaluates to <code>a x d</code>.
</p>
<h3 class="subsection" id="sec146">9.3.7&#XA0;&#XA0;nth-hd</h3>
<p><a id="fun:nth-hd"></a><a id="function:nth-hd"></a><a id="hevea_default110"></a><a id="hevea_fun29"></a></p><pre class="verbatim">   $(nth-hd i, sequence) : value
      i : Int
      sequence : Sequence
   raises RuntimeException
</pre><p>The <code>nth-hd</code> function returns the first <code>i</code> elements of
the sequence. An exception is raised if the sequence is not
at least <code>i</code> elements long.</p><p>For example, the expression <code>$(nth-hd 2, a "b c" d)</code> evaluates to <code>a "b c"</code>.</p>
<h3 class="subsection" id="sec147">9.3.8&#XA0;&#XA0;nth-tl</h3>
<p><a id="fun:nth-tl"></a><a id="function:nth-tl"></a><a id="hevea_default111"></a><a id="hevea_fun30"></a></p><pre class="verbatim">   $(nth-tl i, sequence) : value
      i : Int
      sequence : Sequence
   raises RuntimeException
</pre><p>The <code>nth-tl</code> function skips <code>i</code> elements of the sequence
and returns the rest. An exception is raised if the sequence is not
at least <code>i</code> elements long.</p><p>For example, the expression <code>$(nth-tl 1, a "b c" d)</code> evaluates to <code>"b c" d</code>.</p>
<h3 class="subsection" id="sec148">9.3.9&#XA0;&#XA0;subrange</h3>
<p><a id="fun:subrange"></a><a id="function:subrange"></a><a id="hevea_default112"></a><a id="hevea_fun31"></a></p><pre class="verbatim">   $(subrange off, len, sequence) : value
      off : Int
      len : Int
      sequence : Sequence
   raises RuntimeException
</pre><p>The <code>subrange</code> function returns a subrange of the sequence.
Counting starts at 0. An exception is raised if the specified
range is not in bounds.</p><p>For example, the expression <code>$(subrange 1, 2, a "b c" d e)</code> evaluates to <code>"b c" d</code>.
</p>
<h3 class="subsection" id="sec149">9.3.10&#XA0;&#XA0;rev</h3>
<p><a id="fun:rev"></a><a id="function:rev"></a><a id="hevea_default113"></a><a id="hevea_fun32"></a></p><pre class="verbatim">    $(rev sequence) : Sequence
       sequence : Sequence
</pre><p>The <code>rev</code> function returns the elements of a sequence in reverse order.
For example, the expression <code>$(rev a "b c" d)</code> evaluates to <code>d "b c" a</code>.
</p>
<h3 class="subsection" id="sec150">9.3.11&#XA0;&#XA0;join</h3>
<p><a id="fun:join"></a><a id="function:join"></a><a id="hevea_default114"></a><a id="hevea_fun33"></a></p><pre class="verbatim">   $(join sequence1, sequence2) : Sequence
      sequence1 : Sequence
      sequence2 : Sequence
</pre><p>The <code>join</code> function joins together the elements of the two sequences. For example,
<code>$(join a b c, .c .cpp .h)</code> evaluates to <code>a.c b.cpp c.h</code>. If the two input
sequences have different lengths, the remainder of the longer sequence is copied at the end
of the output unmodified.
</p>
<h3 class="subsection" id="sec151">9.3.12&#XA0;&#XA0;string</h3>
<p><a id="fun:string"></a><a id="function:string"></a><a id="hevea_default115"></a><a id="hevea_fun34"></a></p><pre class="verbatim">   $(string sequence) : String
      sequence : Sequence
</pre><p>The <code>string</code> function flattens a sequence into a single string.
This is similar to the <code>concat</code> function, but the elements are
separated by whitespace. The result is treated as a unit; whitespace
is significant.
</p>
<h3 class="subsection" id="sec152">9.3.13&#XA0;&#XA0;string-length</h3>
<p><a id="fun:string-length"></a><a id="function:string-length"></a><a id="hevea_default116"></a><a id="hevea_fun35"></a></p><pre class="verbatim">   $(string-length sequence) : Int
      sequence : Sequence
</pre><p>The <code>string-lenght</code> returns a length (number of characters) in
its argument. If the argument is a sequence, it flattens it, so <code>$(string-length sequence)</code>
is equivalent to <code>$(string-length $(string sequence))</code>.
</p>
<h3 class="subsection" id="sec153">9.3.14&#XA0;&#XA0;string-escaped, ocaml-escaped, html-escaped, html-pre-escaped</h3>
<p><a id="fun:string-escaped"></a><a id="function:string-escaped"></a><a id="hevea_default117"></a><a id="hevea_fun36"></a><a id="fun:ocaml-escaped"></a><a id="function:ocaml-escaped"></a><a id="hevea_default118"></a><a id="hevea_fun37"></a><a id="fun:html-escaped"></a><a id="function:html-escaped"></a><a id="hevea_default119"></a><a id="hevea_fun38"></a><a id="fun:html-pre-escaped"></a><a id="function:html-pre-escaped"></a><a id="hevea_default120"></a><a id="hevea_fun39"></a>
</p>
<h3 class="subsection" id="sec154">9.3.15&#XA0;&#XA0;c-escaped, id-escaped, sql-escaped, uri-escaped</h3>
<p><a id="fun:c-escaped"></a><a id="function:c-escaped"></a><a id="hevea_default121"></a><a id="hevea_fun40"></a><a id="fun:id-escaped"></a><a id="function:id-escaped"></a><a id="hevea_default122"></a><a id="hevea_fun41"></a><a id="fun:sql-escaped"></a><a id="function:sql-escaped"></a><a id="hevea_default123"></a><a id="hevea_fun42"></a><a id="fun:uri-escaped"></a><a id="function:uri-escaped"></a><a id="hevea_default124"></a><a id="hevea_fun43"></a></p><pre class="verbatim">   $(string-escaped sequence) : String Array
   $(ocaml-escaped sequence) : String Array
   $(html-escaped sequence) : String Array
   $(html-pre-escaped sequence) : String Array
   $(c-escaped sequence) : String Array
   $(id-escaped sequence) : StringArray
   $(sql-escaped sequence) : StringArray
   $(uri-escaped sequence) : StringArray
      sequence : Array
</pre><p>The <code>string-escaped</code> function converts each element of its
argument to a string, escaping it, if it contains symbols that are
special to OMake.
The special characters include <code>:()\,$'"#</code> and whitespace.
This function can be used in scanner rules to escape file names before
printing then to <code>stdout</code>.</p><p>The <code>ocaml-escaped</code> function converts each element of its
argument to a string, escaping characters that are special to OCaml.</p><p>The <code>c-escaped</code> function converts a string to a form that
can be used as a string constant in C.</p><p>The <code>id-escaped</code> function turns a string into an identifier that
may be used in OMake.</p><p>The <code>html-escaped</code> function turns a literal string into a form acceptable
as HTML. The <code>html-pre-escaped</code> function is similar, but it does not
translate newlines into <code>&lt;br&gt;</code>.</p><pre class="verbatim">    println($(string $(string-escaped $"a b" $"y:z")))
    a\ b y\:z
</pre>
<h3 class="subsection" id="sec155">9.3.16&#XA0;&#XA0;hexify, unhexify</h3>
<p><a id="fun:hexify"></a><a id="function:hexify"></a><a id="hevea_default125"></a><a id="hevea_fun44"></a><a id="fun:unhexify"></a><a id="function:unhexify"></a><a id="hevea_default126"></a><a id="hevea_fun45"></a></p><pre class="verbatim">   $(hexify sequence) : sequence
       sequence : Sequence
</pre><p>The function <code>hexify</code> converts a string to a HEX ASCII representation.
The inverse function is <code>unhexify</code>.</p><pre class="verbatim">   osh&gt; hexify($"Hello world")
   - : &lt;array &lt;data "48656c6c6f"&gt; &lt;data "776f726c64"&gt;&gt;
</pre>
<h3 class="subsection" id="sec156">9.3.17&#XA0;&#XA0;decode-uri, encode-uri</h3>
<p><a id="fun:decode-uri"></a><a id="function:decode-uri"></a><a id="hevea_default127"></a><a id="hevea_fun46"></a><a id="fun:encode-uri"></a><a id="function:encode-uri"></a><a id="hevea_default128"></a><a id="hevea_fun47"></a></p><pre class="verbatim">    $(decode-uri sequence) : sequence
        sequence : Sequence
</pre><p>These two functions perform URI encoding, where special characters
are represented by hexadecimal characters.</p><pre class="verbatim">    osh&gt; s = $(encode-uri $'a b~c')
    "a+b%7ec"
    osh&gt; decode-uri($s)
    "a b~c"
</pre>
<h3 class="subsection" id="sec157">9.3.18&#XA0;&#XA0;quote</h3>
<p><a id="fun:quote"></a><a id="function:quote"></a><a id="hevea_default129"></a><a id="hevea_fun48"></a></p><pre class="verbatim">   $(quote sequence) : String
      sequence : Sequence
</pre><p>The <code>quote</code> function flattens a sequence into a single string
and adds quotes around the string. Inner quotation symbols are
escaped.</p><p>For example, the expression <code>$(quote a "b c" d)</code> evaluates
to <code>"a \"b c\" d"</code>, and <code>$(quote abc)</code> evaluates to
<code>"abc"</code>.
</p>
<h3 class="subsection" id="sec158">9.3.19&#XA0;&#XA0;quote-argv</h3>
<p><a id="fun:quote-argv"></a><a id="function:quote-argv"></a><a id="hevea_default130"></a><a id="hevea_fun49"></a></p><pre class="verbatim">   $(quote-argv sequence) : String
      sequence : Sequence
</pre><p>The <code>quote-argv</code> function flattens a sequence into a single string,
and adds quotes around the string. The quotation is formed so that
a command-line parse can separate the string back into its components.
</p>
<h3 class="subsection" id="sec159">9.3.20&#XA0;&#XA0;html-string</h3>
<p><a id="fun:html-string"></a><a id="function:html-string"></a><a id="hevea_default131"></a><a id="hevea_fun50"></a></p><pre class="verbatim">   $(html-string sequence) : String
      sequence : Sequence
</pre><p>The <code>html-string</code> function flattens a sequence into a single string,
and escapes special HTML characters.
This is similar to the <code>concat</code> function, but the elements are
separated by whitespace. The result is treated as a unit; whitespace
inside sequence elements is preserved literally.
</p>
<h3 class="subsection" id="sec160">9.3.21&#XA0;&#XA0;addsuffix</h3>
<p><a id="fun:addsuffix"></a><a id="function:addsuffix"></a><a id="hevea_default132"></a><a id="hevea_fun51"></a></p><pre class="verbatim">   $(addsuffix suffix, sequence) : Array
      suffix : String
      sequence : Sequence
</pre><p>The <code>addsuffix</code> function adds a suffix to each component of sequence.
The number of elements in the array is exactly the same as the number of
elements in the sequence.</p><p>For example, <code>$(addsuffix .c, a b "c d")</code> evaluates to <code>a.c b.c "c d".c</code>.
</p>
<h3 class="subsection" id="sec161">9.3.22&#XA0;&#XA0;mapsuffix</h3>
<p><a id="fun:mapsuffix"></a><a id="function:mapsuffix"></a><a id="hevea_default133"></a><a id="hevea_fun52"></a></p><pre class="verbatim">   $(mapsuffix suffix, sequence) : Array
      suffix : value
      sequence : Sequence
</pre><p>The <code>mapsuffix</code> function adds a suffix to each component of sequence.
It is similar to <code>addsuffix</code>, but uses array concatenation instead
of string concatenation. The number of elements in the array is
twice the number of elements in the sequence.</p><p>For example, <code>$(mapsuffix .c, a b "c d")</code> evaluates to <code>a .c b .c "c d" .c</code>.
</p>
<h3 class="subsection" id="sec162">9.3.23&#XA0;&#XA0;addsuffixes, addprefixes</h3>
<p><a id="fun:addsuffixes"></a><a id="function:addsuffixes"></a><a id="hevea_default134"></a><a id="hevea_fun53"></a><a id="fun:addprefixes"></a><a id="function:addprefixes"></a><a id="hevea_default135"></a><a id="hevea_fun54"></a></p><pre class="verbatim">   $(addsuffixes suffixes, sequence) : Array
      suffixes : Sequence
      sequence : Sequence
   $(addprefixes prefixes, sequence) : Array
      prefixes : Sequence
      sequence : Sequence
</pre><p>The <code>addsuffixes</code> function adds all suffixes in its first argument
to each component of a sequence. If <code>suffixes</code> has <code>n</code> elements,
and <code>sequence</code> has <code>m</code> elements, the the result has <code>n * m</code> elements.</p><p>For example, the <code>$(addsuffixes .c .o, a b c)</code> expressions evaluates to
<code>a.c a.o b.c b.o c.o c.a</code>.</p><p><code>$(addprefixes prefixes, sequence)</code> is roughly equivalent to <code>$(addsuffixes sequence, prefixes)</code>.
</p>
<h3 class="subsection" id="sec163">9.3.24&#XA0;&#XA0;removeprefix</h3>
<p><a id="fun:removeprefix"></a><a id="function:removeprefix"></a><a id="hevea_default136"></a><a id="hevea_fun55"></a></p><pre class="verbatim">   $(removeprefix prefix, sequence) : Array
      prefix : String
      sequence : Array
</pre><p>The <code>removeprefix</code> function removes a prefix from each component
of a sequence.
</p>
<h3 class="subsection" id="sec164">9.3.25&#XA0;&#XA0;removesuffix</h3>
<p><a id="fun:removesuffix"></a><a id="function:removesuffix"></a><a id="hevea_default137"></a><a id="hevea_fun56"></a></p><pre class="verbatim">   $(removesuffix sequence) : Array
      sequence : String
</pre><p>The <code>removesuffix</code> function removes the suffixes from each component
of a sequence.</p><p>For example, <code>$(removesuffix a.c b.foo "c d")</code> expands to <code>a b "c d"</code>.
</p>
<h3 class="subsection" id="sec165">9.3.26&#XA0;&#XA0;replacesuffixes</h3>
<p><a id="fun:replacesuffixes"></a><a id="function:replacesuffixes"></a><a id="hevea_default138"></a><a id="hevea_fun57"></a></p><pre class="verbatim">   $(replacesuffixes old-suffixes, new-suffixes, sequence) : Array
      old-suffixes : Sequence
      new-suffixes : Sequence
      sequence : Sequence
</pre><p>The <code>replacesuffixes</code> function modifies the suffix of each component
in sequence. The <code>old-suffixes</code> and <code>new-suffixes</code> sequences
should have the same length.</p><p>For example, <code>$(replacesuffixes .h .c, .o .o, a.c b.h c.z)</code> expands to <code>a.o b.o c.z</code>.
</p>
<h3 class="subsection" id="sec166">9.3.27&#XA0;&#XA0;addprefix</h3>
<p><a id="fun:addprefix"></a><a id="function:addprefix"></a><a id="hevea_default139"></a><a id="hevea_fun58"></a></p><pre class="verbatim">   $(addprefix prefix, sequence) : Array
      prefix : String
      sequence : Sequence
</pre><p>The <code>addprefix</code> function adds a prefix to each component of a sequence.
The number of element in the result array is exactly the same as the number
of elements in the argument sequence.</p><p>For example, <code>$(addprefix foo/, a b "c d")</code> evaluates to <code>foo/a foo/b foo/"c d"</code>.
</p>
<h3 class="subsection" id="sec167">9.3.28&#XA0;&#XA0;mapprefix</h3>
<p><a id="fun:mapprefix"></a><a id="function:mapprefix"></a><a id="hevea_default140"></a><a id="hevea_fun59"></a></p><pre class="verbatim">   $(mapprefix prefix, sequence) : Array
      prefix : String
      sequence : Sequence
</pre><p>The <code>mapprefix</code> function adds a prefix to each component of a sequence.
It is similar to <code>addprefix</code>, but array concatenation is used instead of
string concatenation. The result array contains twice as many elements
as the argument sequence.</p><p>For example, <code>$(mapprefix foo, a b "c d")</code> expands to <code>foo a foo b foo "c d"</code>.
</p>
<h3 class="subsection" id="sec168">9.3.29&#XA0;&#XA0;add-wrapper</h3>
<p><a id="fun:add-wrapper"></a><a id="function:add-wrapper"></a><a id="hevea_default141"></a><a id="hevea_fun60"></a></p><pre class="verbatim">   $(add-wrapper prefix, suffix, sequence) : Array
      prefix : String
      suffix : String
      sequence : Sequence
</pre><p>The <code>add-wrapper</code> functions adds both a prefix and a suffix to each component of a sequence.
For example, the expression <code>$(add-wrapper dir/, .c, a b)</code> evaluates to
<code>dir/a.c dir/b.c</code>. String concatenation is used. The array result
has the same number of elements as the argument sequence.
</p>
<h3 class="subsection" id="sec169">9.3.30&#XA0;&#XA0;set</h3>
<p><a id="fun:set"></a><a id="function:set"></a><a id="hevea_default142"></a><a id="hevea_fun61"></a></p><pre class="verbatim">   $(set sequence) : Array
      sequence : Sequence
</pre><p>The <code>set</code> function sorts a set of string components, eliminating duplicates.</p><p>For example, <code>$(set z y z "m n" w a)</code> expands to <code>"m n" a w y z</code>.
</p>
<h3 class="subsection" id="sec170">9.3.31&#XA0;&#XA0;mem</h3>
<p><a id="fun:mem"></a><a id="function:mem"></a><a id="hevea_default143"></a><a id="hevea_fun62"></a></p><pre class="verbatim">   $(mem elem, sequence) : Boolean
      elem : String
      sequence : Sequence
</pre><p>The <code>mem</code> function tests for membership in a sequence.</p><p>For example, <code>$(mem "m n", y z "m n" w a)</code> evaluates to <code>true</code>,
while <code>$(mem m n, y z "m n" w a)</code> evaluates to <code>false</code>.
</p>
<h3 class="subsection" id="sec171">9.3.32&#XA0;&#XA0;intersection</h3>
<p><a id="fun:intersection"></a><a id="function:intersection"></a><a id="hevea_default144"></a><a id="hevea_fun63"></a></p><pre class="verbatim">   $(intersection sequence1, sequence2) : Array
      sequence1 : Sequence
      sequence2 : Sequence
</pre><p>The <code>intersection</code> function takes two arguments, treats them
as sets of strings, and computes their intersection. The order of the result
is undefined, and it may contain duplicates. Use the <code>set</code>
function to sort the result and eliminate duplicates in the result
if desired.</p><p>For example, the expression <code>$(intersection c a b a, b a)</code> evaluates to
<code>a b a</code>.
</p>
<h3 class="subsection" id="sec172">9.3.33&#XA0;&#XA0;intersects</h3>
<p><a id="fun:intersects"></a><a id="function:intersects"></a><a id="hevea_default145"></a><a id="hevea_fun64"></a></p><pre class="verbatim">   $(intersects sequence1, sequence2) : Boolean
      sequence1 : Sequence
      sequence2 : Sequence
</pre><p>The <code>intersects</code> function tests whether two sets have a non-empty intersection.
This is slightly more efficient than computing the intersection and testing whether
it is empty.</p><p>For example, the expression <code>$(intersects a b c, d c e)</code> evaluates to <code>true</code>,
and <code>$(intersects a b c a, d e f)</code> evaluates to <code>false</code>.
</p>
<h3 class="subsection" id="sec173">9.3.34&#XA0;&#XA0;set-diff</h3>
<p><a id="fun:set-diff"></a><a id="function:set-diff"></a><a id="hevea_default146"></a><a id="hevea_fun65"></a></p><pre class="verbatim">   $(set-diff sequence1, sequence2) : Array
      sequence1 : Sequence
      sequence2 : Sequence
</pre><p>The <code>set-diff</code> function takes two arguments, treats them
as sets of strings, and computes their difference (all the elements of the
first set that are not present in the second one). The order of the result
is undefined and it may contain duplicates. Use the <code>set</code>
function to sort the result and eliminate duplicates in the result
if desired.</p><p>For example, the expression <code>$(set-diff c a b a e, b a)</code> evaluates to
<code>c e</code>.
</p>
<h3 class="subsection" id="sec174">9.3.35&#XA0;&#XA0;filter</h3>
<p><a id="fun:filter"></a><a id="function:filter"></a><a id="hevea_default147"></a><a id="hevea_fun66"></a></p><pre class="verbatim">   $(filter patterns, sequence) : Array
      patterns : Sequence
      sequence : Sequence
</pre><p>The <code>filter</code> function picks elements from a sequence.
The patterns is a non-empty sequence of patterns, each may contain one occurrence of the wildcard
<code>%</code> character.</p><p>For example <code>$(filter %.h %.o, a.c x.o b.h y.o "hello world".c)</code> evaluates to <code>x.o b.h y.o</code>.
</p>
<h3 class="subsection" id="sec175">9.3.36&#XA0;&#XA0;filter-out</h3>
<p><a id="fun:filter-out"></a><a id="function:filter-out"></a><a id="hevea_default148"></a><a id="hevea_fun67"></a></p><pre class="verbatim">   $(filter-out patterns, sequence) : Array
      patterns : Sequence
      sequence : Sequence
</pre><p>The <code>filter-out</code> function removes elements from a sequence.
The patterns is a non-empty sequence of patterns, each may contain one occurrence of the wildcard
<code>%</code> character.</p><p>For example <code>$(filter-out %.c %.h, a.c x.o b.h y.o "hello world".c)</code> evaluates to <code>x.o y.o</code>.
</p>
<h3 class="subsection" id="sec176">9.3.37&#XA0;&#XA0;capitalize</h3>
<p><a id="fun:capitalize"></a><a id="function:capitalize"></a><a id="hevea_default149"></a><a id="hevea_fun68"></a></p><pre class="verbatim">   $(capitalize sequence) : Array
      sequence : Sequence
</pre><p>The <code>capitalize</code> function capitalizes each word in a sequence.
For example, <code>$(capitalize through the looking Glass)</code> evaluates to
<code>Through The Looking Glass</code>.
</p>
<h3 class="subsection" id="sec177">9.3.38&#XA0;&#XA0;uncapitalize</h3>
<p><a id="fun:uncapitalize"></a><a id="function:uncapitalize"></a><a id="hevea_default150"></a><a id="hevea_fun69"></a></p><pre class="verbatim">   $(uncapitalize sequence) : Array
      sequence : Sequence
</pre><p>The <code>uncapitalize</code> function uncapitalizes each word in its argument.</p><p>For example, <code>$(uncapitalize through the looking Glass)</code> evaluates to
<code>through the looking glass</code>.
</p>
<h3 class="subsection" id="sec178">9.3.39&#XA0;&#XA0;uppercase</h3>
<p><a id="fun:uppercase"></a><a id="function:uppercase"></a><a id="hevea_default151"></a><a id="hevea_fun70"></a></p><pre class="verbatim">   $(uppercase sequence) : Array
      sequence : Sequence
</pre><p>The <code>uppercase</code> function converts each word in a sequence to uppercase.
For example, <code>$(uppercase through the looking Glass)</code> evaluates to
<code>THROUGH THE LOOKING GLASS</code>.
</p>
<h3 class="subsection" id="sec179">9.3.40&#XA0;&#XA0;lowercase</h3>
<p><a id="fun:lowercase"></a><a id="function:lowercase"></a><a id="hevea_default152"></a><a id="hevea_fun71"></a></p><pre class="verbatim">   $(lowercase sequence) : Array
      sequence : Sequence
</pre><p>The <code>lowercase</code> function reduces each word in its argument to lowercase.</p><p>For example, <code>$(lowercase through tHe looking Glass)</code> evaluates to
<code>through the looking glass</code>.
</p>
<h3 class="subsection" id="sec180">9.3.41&#XA0;&#XA0;system</h3>
<p><a id="fun:system"></a><a id="function:system"></a><a id="hevea_default153"></a><a id="hevea_fun72"></a></p><pre class="verbatim">   system(s)
      s : Sequence
</pre><p>The <code>system</code> function is used to evaluate a shell expression.
This function is used internally by <span class="c001">omake</span> to evaluate
shell commands.</p><p>For example, the following program is equivalent to the
expression <code>system(ls foo)</code>.</p><pre class="verbatim">   ls foo
</pre>
<h3 class="subsection" id="sec181">9.3.42&#XA0;&#XA0;shell</h3>
<p><a id="fun:shell"></a><a id="function:shell"></a><a id="hevea_default154"></a><a id="hevea_fun73"></a></p><pre class="verbatim">   $(shell command) : Array
   $(shella command) : Array
   $(shell-code command) : Int
      command : Sequence
</pre><p>The <code>shell</code> function evaluates a command using the command shell,
and returns the whitespace-separated words of the standard output as the result.</p><p>The <code>shella</code> function acts similarly, but it returns the lines
as separate items in the array.</p><p>The <code>shell-code</code> function returns the exit code. The output is not
diverted.</p><p>For example, if the current directory contains the files <code>OMakeroot</code>,
<code>OMakefile</code>, and <code>hello.c</code>, then <code>$(shell ls)</code> evaluates to
<code>hello.c OMakefile OMakeroot</code> (on a Unix system).
</p>
<h3 class="subsection" id="sec182">9.3.43&#XA0;&#XA0;export</h3>
<p><a id="fun:export"></a><a id="function:export"></a><a id="hevea_default155"></a><a id="hevea_fun74"></a>
The <code>export</code> function allows one to capture the current environment in a variable.</p><p>For example, the following code:
</p><pre class="verbatim">A = 1
B = 1
C = 1
SAVE_ENV = $(export A B)
A = 2
B = 2
C = 2
export($(SAVE_ENV))
println($A $B $C)
</pre><p>will print <code>1 1 2</code>.</p><p>The arguments to this function are interpreted the exact same way as the arguments to the <code>export</code>
special form (see Section&#XA0;<a href="omake-detail.html#section%3Aexport">6.3</a>).
<a id="while"></a>
</p>
<h3 class="subsection" id="sec183">9.3.44&#XA0;&#XA0;while</h3>
<p><a id="fun:while"></a><a id="function:while"></a><a id="hevea_default156"></a><a id="hevea_fun75"></a></p><pre class="verbatim">   while &lt;test&gt;
      &lt;body&gt;
</pre><p>&#X2013;or&#X2013;</p><pre class="verbatim">    while &lt;test&gt;
    case &lt;test1&gt;
       &lt;body1&gt;
    ...
    case &lt;testn&gt;
       &lt;bodyn&gt;
    default
       &lt;bodyd&gt;
</pre><p>The loop is executed while the test is true.
In the first form, the <code>&lt;body&gt;</code> is executed on every loop iteration.
In the second form, the body <code>&lt;bodyI&gt;</code> is selected, as the first
case where the test <code>&lt;testI&gt;</code> is true. If none apply, the optional
default case is evaluated. If no cases are true, the loop exits.
The environment is automatically exported.</p><p>Examples.</p><p>Iterate for <code>i</code> from <code>0</code> to <code>9</code>.</p><pre class="verbatim">    i = 0
    while $(lt $i, 10)
       echo $i
       i = $(add $i, 1)
</pre><p>The following example is equivalent.</p><pre class="verbatim">   i = 0
   while true
   case $(lt $i, 10)
      echo $i
      i = $(add $i, 1)
</pre><p>The following example is similar, but some special cases are printed.
value is printed.</p><pre class="verbatim">    i = 0
    while $(lt $i, 10)
    case $(equal $i, 0)
       echo zero
       i = $(add $i, 1)
    case $(equal $i, 1)
       echo one
       i = $(add $i, 1)
    default
       echo $i
       i = $(add $i, 1)
</pre><p>The <a href="#fun%3Abreak"><CODE>break</CODE> function</a> can be used to break out of the <code>while</code> loop
early.
<a id="break"></a>
</p>
<h3 class="subsection" id="sec184">9.3.45&#XA0;&#XA0;break</h3>
<p><a id="fun:break"></a><a id="function:break"></a><a id="hevea_default157"></a><a id="hevea_fun76"></a></p><pre class="verbatim">   break
</pre><p>Terminate execution of the innermost loop, returning the current state.
</p>
<h3 class="subsection" id="sec185">9.3.46&#XA0;&#XA0;random, random-init</h3>
<p><a id="fun:random"></a><a id="function:random"></a><a id="hevea_default158"></a><a id="hevea_fun77"></a><a id="fun:random-init"></a><a id="function:random-init"></a><a id="hevea_default159"></a><a id="hevea_fun78"></a></p><pre class="verbatim">    random-init(i)
        i : Int
    random() : Int
</pre><p>Produce a random number. The numbers are pseudo-random,
and are not cryptographically secure.</p><p>The generator is initialized from semi-random system data.
Subsequent runs should produce different results.
The <code>rando-init</code> function can be used to return
the generator to a known state.
</p>
<h2 class="section" id="sec186">9.4&#XA0;&#XA0;Arithmetic</h2>
<h3 class="subsection" id="sec187">9.4.1&#XA0;&#XA0;int</h3>
<p><a id="fun:int"></a><a id="function:int"></a><a id="hevea_default160"></a><a id="hevea_fun79"></a></p><p>The <code>int</code> function can be used to create integers.
It returns an <code>Int</code> object.</p><p><code>$(int 17)</code>.</p>
<h3 class="subsection" id="sec188">9.4.2&#XA0;&#XA0;float</h3>
<p><a id="fun:float"></a><a id="function:float"></a><a id="hevea_default161"></a><a id="hevea_fun80"></a>
The <code>float</code> function can be used to create floating-point numbers.
It returns a <code>Float</code> object.</p><p><code>$(float 3.1415926)</code>.
</p>
<h3 class="subsection" id="sec189">9.4.3&#XA0;&#XA0;Basic arithmetic</h3>
<p>
<a id="fun:neg"></a><a id="function:neg"></a><a id="hevea_default162"></a><a id="hevea_fun81"></a>
<a id="fun:add"></a><a id="function:add"></a><a id="hevea_default163"></a><a id="hevea_fun82"></a>
<a id="fun:sub"></a><a id="function:sub"></a><a id="hevea_default164"></a><a id="hevea_fun83"></a>
<a id="fun:mul"></a><a id="function:mul"></a><a id="hevea_default165"></a><a id="hevea_fun84"></a>
<a id="fun:div"></a><a id="function:div"></a><a id="hevea_default166"></a><a id="hevea_fun85"></a>
<a id="fun:mod"></a><a id="function:mod"></a><a id="hevea_default167"></a><a id="hevea_fun86"></a>
<a id="fun:lnot"></a><a id="function:lnot"></a><a id="hevea_default168"></a><a id="hevea_fun87"></a>
<a id="fun:land"></a><a id="function:land"></a><a id="hevea_default169"></a><a id="hevea_fun88"></a>
<a id="fun:lor"></a><a id="function:lor"></a><a id="hevea_default170"></a><a id="hevea_fun89"></a>
<a id="fun:lxor"></a><a id="function:lxor"></a><a id="hevea_default171"></a><a id="hevea_fun90"></a>
<a id="fun:lsl"></a><a id="function:lsl"></a><a id="hevea_default172"></a><a id="hevea_fun91"></a>
<a id="fun:lsr"></a><a id="function:lsr"></a><a id="hevea_default173"></a><a id="hevea_fun92"></a>
<a id="fun:asr"></a><a id="function:asr"></a><a id="hevea_default174"></a><a id="hevea_fun93"></a>
<a id="fun:min"></a><a id="function:min"></a><a id="hevea_default175"></a><a id="hevea_fun94"></a>
<a id="fun:max"></a><a id="function:max"></a><a id="hevea_default176"></a><a id="hevea_fun95"></a></p><p>The following functions can be used to perform basic arithmetic.</p><ul class="itemize"><li class="li-itemize">
<code>$(neg &lt;numbers&gt;)</code>: arithmetic inverse
</li><li class="li-itemize"><code>$(add &lt;numbers&gt;)</code>: addition.
</li><li class="li-itemize"><code>$(sub &lt;numbers&gt;)</code>: subtraction.
</li><li class="li-itemize"><code>$(mul &lt;numbers&gt;)</code>: multiplication.
</li><li class="li-itemize"><code>$(div &lt;numbers&gt;)</code>: division.
</li><li class="li-itemize"><code>$(mod &lt;numbers&gt;)</code>: remainder.
</li><li class="li-itemize"><code>$(lnot &lt;numbers&gt;)</code>: bitwise inverse.
</li><li class="li-itemize"><code>$(land &lt;numbers&gt;)</code>: bitwise and.
</li><li class="li-itemize"><code>$(lor &lt;numbers&gt;)</code>: bitwise or.
</li><li class="li-itemize"><code>$(lxor &lt;numbers&gt;)</code>: bitwise exclusive-or.
</li><li class="li-itemize"><code>$(lsl &lt;numbers&gt;)</code>: logical shift left.
</li><li class="li-itemize"><code>$(lsr &lt;numbers&gt;)</code>: logical shift right.
</li><li class="li-itemize"><code>$(asr &lt;numbers&gt;)</code>: arithmetic shift right.
</li><li class="li-itemize"><code>$(min &lt;numbers&gt;)</code>: smallest element.
</li><li class="li-itemize"><code>$(max &lt;numbers&gt;)</code>: largest element.
</li></ul>
<h3 class="subsection" id="sec190">9.4.4&#XA0;&#XA0;Comparisons</h3>
<p>
<a id="fun:lt"></a><a id="function:lt"></a><a id="hevea_default177"></a><a id="hevea_fun96"></a>
<a id="fun:le"></a><a id="function:le"></a><a id="hevea_default178"></a><a id="hevea_fun97"></a>
<a id="fun:eq"></a><a id="function:eq"></a><a id="hevea_default179"></a><a id="hevea_fun98"></a>
<a id="fun:ge"></a><a id="function:ge"></a><a id="hevea_default180"></a><a id="hevea_fun99"></a>
<a id="fun:gt"></a><a id="function:gt"></a><a id="hevea_default181"></a><a id="hevea_fun100"></a>
<a id="fun:ult"></a><a id="function:ult"></a><a id="hevea_default182"></a><a id="hevea_fun101"></a>
<a id="fun:ule"></a><a id="function:ule"></a><a id="hevea_default183"></a><a id="hevea_fun102"></a>
<a id="fun:uge"></a><a id="function:uge"></a><a id="hevea_default184"></a><a id="hevea_fun103"></a>
<a id="fun:ugt"></a><a id="function:ugt"></a><a id="hevea_default185"></a><a id="hevea_fun104"></a></p><p>The following functions can be used to perform numerical comparisons.</p><ul class="itemize"><li class="li-itemize">
<code>$(lt &lt;numbers&gt;)</code>: less then.
</li><li class="li-itemize"><code>$(le &lt;numbers&gt;)</code>: no more than.
</li><li class="li-itemize"><code>$(eq &lt;numbers&gt;)</code>: equal.
</li><li class="li-itemize"><code>$(ge &lt;numbers&gt;)</code>: no less than.
</li><li class="li-itemize"><code>$(gt &lt;numbers&gt;)</code>: greater than.
</li><li class="li-itemize"><code>$(ult &lt;numbers&gt;)</code>: unsigned less than.
</li><li class="li-itemize"><code>$(ule &lt;numbers&gt;)</code>: unsigned greater than.
</li><li class="li-itemize"><code>$(uge &lt;numbers&gt;)</code>: unsigned greater than or equal.
</li><li class="li-itemize"><code>$(ugt &lt;numbers&gt;)</code>: unsigned greater than.
</li></ul>
<h2 class="section" id="sec191">9.5&#XA0;&#XA0;First-class functions</h2>
<h3 class="subsection" id="sec192">9.5.1&#XA0;&#XA0;fun</h3>
<p><a id="fun:fun"></a><a id="function:fun"></a><a id="hevea_default186"></a><a id="hevea_fun105"></a></p><p>The <code>fun</code> form introduces anonymous functions.</p><p><code>$(fun &lt;v1&gt;, ..., &lt;vn&gt; =&gt; &lt;body&gt;)</code></p><p>The last argument is the body of the function.
The other arguments are the parameter names.</p><p>The three following definitions are equivalent.</p><pre class="verbatim">    F(X, Y) =
       return($(addsuffix $(Y), $(X)))

    F = $(fun X, Y =&gt; $(addsuffix $(Y), $(X)))

    F =
       fun(X, Y) =&gt;
          value $(addsuffix $(Y), $(X))
</pre>
<h3 class="subsection" id="sec193">9.5.2&#XA0;&#XA0;apply</h3>
<p><a id="fun:apply"></a><a id="function:apply"></a><a id="hevea_default187"></a><a id="hevea_fun106"></a></p><p>The <code>apply</code> operator is used to apply a function.</p><p><code>$(apply &lt;fun&gt;, &lt;args&gt;)</code></p><p>Suppose we have the following function definition.</p><pre class="verbatim">    F(X, Y) =
       return($(addsuffix $(Y), $(X)))
</pre><p>The the two expressions below are equivalent.</p><pre class="verbatim">    X = F(a b c, .c)
    X = $(apply $(F), a b c, .c)
</pre><p>The <code>apply</code> form can also be used for partial applications,
where a function is passed fewer arguments than it expects. The
result is a function that takes the remaining arguments,
and calls the function with the full set of arguments.</p><pre class="verbatim">    add2(i, j) =
       add($i, $j)
    succ = $(apply $(add2), 1)
    i = $(succ 5)   # Computes 1+5
</pre>
<h3 class="subsection" id="sec194">9.5.3&#XA0;&#XA0;applya</h3>
<p><a id="fun:applya"></a><a id="function:applya"></a><a id="hevea_default188"></a><a id="hevea_fun107"></a></p><p>The <code>applya</code> operator is used to apply a function to
an array of arguments.</p><p><code>$(applya &lt;fun&gt;, &lt;args&gt;)</code></p><p>For example, in the following program, the value
of <code>Z</code> is <code>file.c</code>.</p><pre class="verbatim">    F(X, Y) =
       return($(addsuffix $(Y), $(X)))
    args[] =
       file
       .c
    Z = $(applya $(F), $(args))
</pre><p>The <code>applya</code> form can also be used for partial applications.
</p>
<h3 class="subsection" id="sec195">9.5.4&#XA0;&#XA0;create-map, create-lazy-map</h3>
<p><a id="fun:create-map"></a><a id="function:create-map"></a><a id="hevea_default189"></a><a id="hevea_fun108"></a><a id="fun:create-lazy-map"></a><a id="function:create-lazy-map"></a><a id="hevea_default190"></a><a id="hevea_fun109"></a></p><p>The <code>create-map</code> is a simplified form for creating <code>Map</code> objects.
The <code>create-map</code> function takes an even number of arguments that specify
key/value pairs. For example, the following values are equivalent.</p><pre class="verbatim">    X = $(create-map name1, xxx, name2, yyy)

    X. =
        extends $(Map)
        $|name1| = xxx
        $|name2| = yyy
</pre><p>The <code>create-lazy-map</code> function is similar, but the values are computed
lazily. The following two definitions are equivalent.</p><pre class="verbatim">    Y = $(create-lazy-map name1, $(xxx), name2, $(yyy))

    Y. =
        extends $(Map)
        $|name1| = $`(xxx)
        $|name2| = $`(yyy)
</pre><p>The <a href="#fun%3Acreate-lazy-map"><CODE>create-lazy-map</CODE> function</a> is used in rule construction.
</p>
<h2 class="section" id="sec196">9.6&#XA0;&#XA0;Iteration and mapping</h2>
<h3 class="subsection" id="sec197">9.6.1&#XA0;&#XA0;foreach</h3>
<p><a id="fun:foreach"></a><a id="function:foreach"></a><a id="hevea_default191"></a><a id="hevea_fun110"></a></p><p>The <code>foreach</code> function maps a function over a sequence.</p><pre class="verbatim">    $(foreach &lt;fun&gt;, &lt;args&gt;)

    foreach(&lt;var&gt; =&gt; ..., &lt;args&gt;)
       &lt;body&gt;
</pre><p>For example, the following program defines the variable <code>X</code>
as an array <code>a.c b.c c.c</code>.</p><pre class="verbatim">    X =
       foreach(x =&gt; ..., a b c)
          value $(x).c

    # Equivalent expression
    X = $(foreach $(fun x =&gt; ..., $(x).c), a b c)
</pre><p>There is also an abbreviated syntax.</p><p>The <code>export</code> form can also be used in a <code>foreach</code>
body. The final value of <code>X</code> is <code>a.c b.c c.c</code>.</p><pre class="verbatim">    X =
    foreach(x =&gt; ..., a b c)
       X += $(x).c
       export
</pre><p>The <a href="#fun%3Abreak"><CODE>break</CODE> function</a> can be used to break out of the loop early.
</p>
<h2 class="section" id="sec198">9.7&#XA0;&#XA0;Boolean tests</h2>
<h3 class="subsection" id="sec199">9.7.1&#XA0;&#XA0;sequence-forall</h3>
<p><a id="fun:sequence-forall"></a><a id="function:sequence-forall"></a><a id="hevea_default192"></a><a id="hevea_fun111"></a></p><p>The <code>forall</code> function tests whether a predicate holds for each
element of a sequence.</p><pre class="verbatim">    $(sequence-forall &lt;fun&gt;, &lt;args&gt;)

    sequence-forall(&lt;var&gt; =&gt; ..., &lt;args&gt;)
       &lt;body&gt;
</pre>
<h3 class="subsection" id="sec200">9.7.2&#XA0;&#XA0;sequence-exists</h3>
<p>The <code>exists</code> function tests whether a predicate holds for
some element of a sequence.</p><pre class="verbatim">    $(sequence-exists &lt;fun&gt;, &lt;args&gt;)

    sequence-exists(&lt;var&gt; =&gt; ..., &lt;args&gt;)
       &lt;body&gt;
</pre>
<h3 class="subsection" id="sec201">9.7.3&#XA0;&#XA0;sequence-sort</h3>
<p><a id="fun:sequence-sort"></a><a id="function:sequence-sort"></a><a id="hevea_default193"></a><a id="hevea_fun112"></a></p><p>The <code>sort</code> function sorts the elements in an array,
given a comparison function. Given two elements (x, y),
the comparison should return a negative number if x &lt; y;
a positive number if x &gt; y; and 0 if x = y.</p><pre class="verbatim">    $(sequence-sort &lt;fun&gt;, &lt;args&gt;)

    sort(&lt;var&gt;, &lt;var&gt; =&gt; ..., &lt;args&gt;)
       &lt;body&gt;
</pre>
<h3 class="subsection" id="sec202">9.7.4&#XA0;&#XA0;compare</h3>
<p><a id="fun:compare"></a><a id="function:compare"></a><a id="hevea_default194"></a><a id="hevea_fun113"></a></p><p>The <code>compare</code> function compares two values (x, y) generically
returning a negative number if x &lt; y;
a positive number if x &gt; y; and 0 if x = y.</p><pre class="verbatim">    $(compare x, y) : Int
</pre>

<table class="c000 cellpading0"><tr><td class="c006">Jump to:</td><td class="c005">&#XA0;&#XA0;</td><td class="c006"><a href="../index.html">OMake Home</a>
&bull;&nbsp;<a href="omake.html">Guide Home</a>
&bull;&nbsp;<a href="omake-doc.html">Guide (single-page)</a>
&bull;&nbsp;<a href="omake-toc.html">Contents (short)</a>
&bull;&nbsp;<a href="omake-contents.html">Contents (long)</a></td></tr>
<tr><td class="c006">Index:</td><td class="c005">&#XA0;&#XA0;</td><td class="c006"><a href="omake-all-index.html">All</a>
&bull;&nbsp;<a href="omake-var-index.html">Variables</a>
&bull;&nbsp;<a href="omake-fun-index.html">Functions</a>
&bull;&nbsp;<a href="omake-obj-index.html">Objects</a>
&bull;&nbsp;<a href="omake-target-index.html">Targets</a>
&bull;&nbsp;<a href="omake-option-index.html">Options</a>
</td></tr>
</table>
</body>
</html>
