########################################################################
# Building C files.
#
# Copyright (C) 2003-2005 Jason Hickey and Mojave Group
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this file, to deal in the File without
# restriction, including without limitation the rights to use,
# copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the File, and to permit persons to whom the File
# is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the File.
#
# THE FILE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
# OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
# FILE OR THE USE OR OTHER DEALINGS IN THE FILE.

open build/Common

#
# \begin{doc}
# \section{Building C programs}
#
# \Prog{omake} provides extensive support for building C programs.
#
# \subsection{C configuration variables}
#
# The following variables can be redefined in your project.
#
# \var{CC} The name of the C compiler (on \verb+Unix+ it defaults to \verb+gcc+ when \verb+gcc+ is present and
#   to \verb+cc+ otherwise; on \verb+Win32+ defaults to \verb+cl /nologo+).
# \var{CXX} The name of the C++ compiler (on \verb+Unix+ it defaults to \verb+gcc+ when \verb+gcc+ is present
#   and to \verb+c+++ otherwise; on \verb+Win32+ defaults to \verb+cl /nologo+).
# \var{CPP} The name of the C preprocessor (defaults to \verb+cpp+ on \verb+Unix+, and \verb+cl /E+ on \verb+Win32+).
# \var{CFLAGS} Compilation flags to pass to the C compiler (default empty on \verb+Unix+, and \verb+/DWIN32+
#   on \verb+Win32+).
# \var{CXXFLAGS} Compilation flags to pass to the C++ compiler (default empty on \verb+Unix+, and \verb+/DWIN32+
#   on \verb+Win32+).
# \var{INCLUDES} Additional directories that specify the search path to the C and C++ compilers (default is \verb+.+).
#   The directories are passed to the C and C++ compilers with the \verb+-I+ option.
#   The include path with \verb+-I+ prefixes is defined in the \verb+PREFIXED_INCLUDES+ variable.
# \var{LIBS} Additional libraries needed when building a program (default is empty).
# \var{AS} The name of the assembler (defaults to \verb+as+ on \verb+Unix+, and \verb+ml+ on \verb+Win32+).
# \var{ASFLAGS} Flags to pass to the assembler (default is empty on \verb+Unix+, and \verb+/c /coff+ on \verb+Win32+).
# \var{AR} The name of the program to create static libraries (defaults to \verb+ar cq+ on \verb+Unix+,
#     and \verb+lib+ on \verb+Win32+).
# \var{AROUT} The option string that specifies the output file for \verb+AR+.
# \var{LD} The name of the linker (defaults to \verb+ld+ on \verb+Unix+, and \verb+cl+ on \verb+Win32+).
# \var{LDFLAGS} Options to pass to the linker (default is empty).
# \var{YACC} The name of the \verb+yacc+ parser generator (default is \verb+yacc+ on \verb+Unix+, empty on \verb+Win32+).
# \var{LEX} The name of the \verb+lex+ lexer generator (default is \verb+lex+ on \verb+Unix+, empty on \verb+Win32+).
# \end{doc}
#
if $(equal $(OSTYPE), Win32)
    CC = cl /nologo
    CXX = cl /nologo
    CPP = cl /nologo /E
    CFLAGS = /DWIN32
    CXXFLAGS = /DWIN32
    AR(name) =
        return(lib /nologo /debugtype:CV /out:$(name))
    RANLIB = echo ranlib
    LD = cl
    INCLUDES[] = .
    INCLUDES_OPT = /I
    YACC = echo yacc
    LEX = echo lex
    LIBS =
    LDFLAGS =

    AS = ml /nologo
    ASOUT = /Fo
    ASFLAGS = /c /coff

    export
else
    static. =
        open configure/Configure
        GCC_FOUND = $(CheckProg gcc)
        GXX_FOUND = $(and $(GCC_FOUND), $(CheckProg g++))
    CC = $(if $(GCC_FOUND), gcc, cc)
    CXX = $(if $(GXX_FOUND), g++, c++)
    CPP = cpp
    CFLAGS =
    CXXFLAGS =
    AR(name) =
        return(ar cq $(name))
    RANLIB = ranlib
    LD = ld
    INCLUDES[] = .
    INCLUDES_OPT = -I
    YACC = yacc
    LEX = lex
    LIBS =
    LDFLAGS =

    AS = as
    ASOUT = $(array -o)
    ASFLAGS =

    export

#
# Add the -I option to the includes lazily.
# Don't redefine this variable unless you know what you are doing.
#
PREFIXED_INCLUDES = $`(addprefix $(INCLUDES_OPT), $(INCLUDES))

#
# Special flags for compiling C files for use in OCaml
#
BYTE_CFLAGS =
NATIVE_CFLAGS =

#
# Generic build rules
#
#
CXX_EXTS[] = .cpp .cc .c++

%$(EXT_OBJ): %.c :scanner: scan-c-%.c
    $(CC) $(CFLAGS) $(PREFIXED_INCLUDES) -c -o $@ $*.c

foreach(CXX_EXT, $(CXX_EXTS))
    %$(EXT_OBJ): %$(CXX_EXT) :scanner: scan-cxx-%$(CXX_EXT)
        $(CXX) $(CXXFLAGS) $(PREFIXED_INCLUDES) -c -o $@ $<

    export

%$(EXT_OBJ): %$(EXT_ASM)
    $(AS) $(ASFLAGS) $(PREFIXED_INCLUDES) $(ASOUT)$@ $*$(EXT_ASM)

%.c: %.y
    $(YACC) $*.y

%.c: %.l
    $(LEX) $*.l

#
# Default C scanner
#

#
# Make sure generated files are built before scanning
#
# \begin{doc}
# \fun{CGeneratedFiles}
# \fun{LocalCGeneratedFiles}
# \begin{verbatim}
# CGeneratedFiles(files)
# LocalCGeneratedFiles(files)
# \end{verbatim}
#
# The \verb+CGeneratedFiles+ and \verb+LocalCGeneratedFiles+ functions specify files
# that need to be generated before any C files are scanned for dependencies. For example,
# if \verb+config.h+ and \verb+inputs.h+ are both generated files, specify:
# \begin{verbatim}
# CGeneratedFiles(config.h inputs.h)
# \end{verbatim}
#
# The \verb+CGeneratedFiles+ function is \emph{global} --- its arguments will be generated
# before any C files anywhere in the project are scanned for dependencies. The
# \verb+LocalCGeneratedFiles+ function follows the normal scoping rules of OMake.
#
# \end{doc}
#
.PHONY: CGeneratedFilesTarget

CGeneratedFiles(files) =
    CGeneratedFilesTarget: $(files)

LocalCGeneratedFiles(files) =
    .SCANNER: scan-c-%: $(files)
    .SCANNER: scan-cxx-%: $(files)
    .SCANNER: %$(EXT_OBJ): $(files)
    export

#
# We use digest-path-exists value dependency to make sure the SCANNER is re-run
# whenever the scanned dependencies change.
#
if $(equal $(OSTYPE), Win32)
    #
    # Somehow Win32 doesn't have good dependency analysis,
    # so we try to construct it by extracting the #line
    # directives from the preprocessor.
    #
    Shell. +=
        builtin-cpp-filenames(argv) =
           fsubst($(argv))
           case $'^[^"]*\("[^"]+"\).*'
              value $1

        builtin-cc-depend(argv) =
           filename = $(last $(argv))
           pipeline =\
              $(argv) |\
              grep "^#(line)? [0-9]" |\
              builtin-cpp-filenames |\
              grep "^[^<]"
           if $(VERBOSE)
              eprintln(+ $(string $(pipeline)))
           depends = $(set $(shell $(pipeline)))
           objname = $(rootname $(filename))$(EXT_OBJ)
           println($(string $(objname): $(depends)))

    .SCANNER: scan-c-%.c: %.c /.PHONY/CGeneratedFilesTarget :value: $(digest-in-path-optional $(INCLUDES), $&)
        builtin-cc-depend $(CC) $(CFLAGS) $(PREFIXED_INCLUDES) -E $<

    # Include default rule for backwards-compatibility
    .SCANNER: %$(EXT_OBJ): %.c /.PHONY/CGeneratedFilesTarget :value: $(digest-in-path-optional $(INCLUDES), $&)
        builtin-cc-depend $(CC) $(CFLAGS) $(PREFIXED_INCLUDES) -E $<

    foreach(CXX_EXT, $(CXX_EXTS))
        .SCANNER: scan-cxx-%$(CXX_EXT): %$(CXX_EXT) /.PHONY/CGeneratedFilesTarget :value: $(digest-in-path-optional $(INCLUDES), $&)
            builtin-cc-depend $(CXX) $(CXXFLAGS) $(PREFIXED_INCLUDES) -E $<

        # Include default rule for backwards-compatibility
        .SCANNER: %$(EXT_OBJ): %$(CXX_EXT) /.PHONY/CGeneratedFilesTarget :value: $(digest-in-path-optional $(INCLUDES), $&)
            builtin-cc-depend $(CXX) $(CXXFLAGS) $(PREFIXED_INCLUDES) -E $<

        export
    export
else
    .SCANNER: scan-c-%.c: %.c /.PHONY/CGeneratedFilesTarget :value: $(digest-in-path-optional $(INCLUDES), $&)
        $(CC) $(CFLAGS) $(PREFIXED_INCLUDES) -MM $<

    # Include default rule for backwards-compatibility
    .SCANNER: %$(EXT_OBJ): %.c /.PHONY/CGeneratedFilesTarget :value: $(digest-in-path-optional $(INCLUDES), $&)
        $(CC) $(CFLAGS) $(PREFIXED_INCLUDES) -MM $<

    foreach(CXX_EXT, $(CXX_EXTS))
        .SCANNER: scan-cxx-%$(CXX_EXT): %$(CXX_EXT) /.PHONY/CGeneratedFilesTarget :value: $(digest-in-path-optional $(INCLUDES), $&)
            $(CXX) $(CXXFLAGS) $(PREFIXED_INCLUDES) -MM $<

        # Include default rule for backwards-compatibility
        .SCANNER: %$(EXT_OBJ): %$(CXX_EXT) /.PHONY/CGeneratedFilesTarget :value: $(digest-in-path-optional $(INCLUDES), $&)
            $(CXX) $(CXXFLAGS) $(PREFIXED_INCLUDES) -MM $<

        export
    export

# Define a function to build a C-library
#
# \begin{doc}
# \fun{StaticCLibrary}
#
# The \verb+StaticCLibrary+ builds a static library.
#
# \verb+StaticCLibrary(<target>, <files>)+
#
# The \verb+<target>+ does \emph{not} include the library suffix, and
# The \verb+<files>+ list does not include the object suffix.  These
# are obtained from the \verb+EXT_LIB+ and \verb+EXT_OBJ+ variables.
#
# This function returns the library filename.
#
# The following command builds the library \verb+libfoo.a+ from the
# files \verb+a.o b.o c.o+ on \verb+Unix+, or the library
# \verb+libfoo.lib+ from the files \verb+a.obj b.obj c.obj+
# on \verb+Win32+.
#
# \begin{verbatim}
# StaticCLibrary(libfoo, a b c)
# .DEFAULT: $(StaticCLibrary libbar, a b c d)
# \end{verbatim}
# \end{doc}
#
StaticCLibrary(name, files) =
    #
    # Generic library that can be used on byte and native-code
    #
    OFILES = $(addsuffix $(EXT_OBJ), $(files))

    #
    # Names of libs
    #
    NORMALLIB = $(file $(name)$(EXT_LIB))

    if $(equal $(OSTYPE), Win32)
        $(NORMALLIB): $(OFILES)
            echo $(OFILES) > $@.tmp
            $(AR $@) @$@.tmp
            rm -f $@.tmp

    else
        $(NORMALLIB): $(OFILES)
            rm -f $@
            $(AR $@) $(OFILES)
            $(RANLIB) $@

    return $(NORMALLIB)

#
# Copy to an install directory
#
# \begin{doc}
# \fun{StaticCLibraryCopy}
#
# The \verb+StaticCLibraryCopy+ function copies the static library
# to an install location.
#
# \verb+StaticCLibraryCopy(<tag>, <dir>, <lib>)+
#
# The \verb+<tag>+ is the name of a target (typically a \verb+.PHONY+ target);
# the \verb+<dir>+ is the installation directory, and \verb+<lib>+ is
# the library to be copied (without the library suffix).
#
# This function returns the filename of the library in the target directory.
#
# For example, the following code copies the library
# \verb+libfoo.a+ to the \verb+/usr/lib+ directory.
#
# \begin{verbatim}
# .PHONY: install
#
# StaticCLibraryCopy(install, /usr/lib, libfoo)
# \end{verbatim}
# \end{doc}
#
StaticCLibraryCopy(tag, lib, name) =
    #
    # Names of libs
    #
    NORMALLIB = $(file $(name)$(EXT_LIB))
    LIBNORMAL = $(file $(lib)/$(basename $(name))$(EXT_LIB))

    #
    # Linking the library into the root lib dir
    #
    $(LIBNORMAL): $(NORMALLIB) $(lib) :scanner: $(NOSCANNER)
        $(symlink $<, $@)

    #
    # Add dependency to the tag
    #
    $(tag): $(LIBNORMAL)

    return $(LIBNORMAL)

#
# We often use them together
#
# \begin{doc}
# \fun{StaticCLibraryInstall}
#
# The \verb+StaticCLibraryInstall+ function builds a library, and
# sets the install location in one step. It returns the filename of the library
# in the target directory.
#
# \verb+StaticCLibraryInstall(<tag>, <dir>, <libname>, <files>)+
#
# \begin{verbatim}
# StaticCLibraryInstall(install, /usr/lib, libfoo, a b c)
# \end{verbatim}
# \end{doc}
#
StaticCLibraryInstall(tag, lib, name, files) =
    StaticCLibrary($(name), $(files))
    return $(StaticCLibraryCopy $(tag), $(lib), $(name))

#
# Build a .o file.  This is like a library,
# but use the linker instead.
#
# \begin{doc}
# \fun{StaticCObject}
# \fun{StaticCObjectCopy}
# \fun{StaticCObjectInstall}
#
# These functions mirror the \verb+StaticCLibrary+, \verb+StaticCLibraryCopy+,
# and \verb+StaticCLibraryInstall+ functions, but they build an \emph{object}
# file (a \verb+.o+ file on \verb+Unix+, and a \verb+.obj+ file on \verb+Win32+).
# \end{doc}
#
StaticCObject(name, files) =
    #
    # Generic library that can be used on byte and native-code
    #
    OFILES = $(addsuffix $(EXT_OBJ), $(files))

    #
    # Names of libs
    #
    NORMALLIB = $(file $(name)$(EXT_OBJ))

    $(NORMALLIB): $(OFILES)
        $(LD) $(LDFLAGS) -r -o $@ $(OFILES)

    return $(NORMALLIB)

#
# Copy to an install directory
#
StaticCObjectCopy(tag, lib, name) =
    #
    # Names of libs
    #
    NORMALLIB = $(file $(name)$(EXT_OBJ))
    LIBNORMAL = $(file $(lib)/$(basename $(name))$(EXT_OBJ))

    #
    # Linking the library into the root lib dir
    #
    $(LIBNORMAL): $(NORMALLIB) $(lib) :scanner: $(NOSCANNER)
        $(symlink $<, $@)

    #
    # Add dependency to the tag
    #
    $(tag): $(LIBNORMAL)

    return $(LIBNORMAL)

#
# We often use them together
#
StaticCObjectInstall(tag, lib, name, files) =
    StaticCObject($(name), $(files))
    return $(StaticCObjectCopy $(tag), $(lib), $(name))

#
# Define a function to build a C-program
#
# \begin{doc}
# \fun{CProgram}
#
# The \verb+CProgram+ function builds a C program from a set
# of object files and libraries.
#
# \verb+CProgram(<name>, <files>)+
#
# The \verb+<name>+ argument specifies the name of the program to be built;
# the \verb+<files>+ argument specifies the files to be linked. The function
# returns the filename of the executable.
#
# Additional options can be passed through the following variables.
# \begin{description}
# \item[CFLAGS] Flags used by the C compiler during the link step.
# \item[LDFLAGS] Flags to pass to the loader.
# \item[LIBS] Additional libraries to be linked.
# \end{description}
#
# For example, the following code specifies that the program
# \verb+foo+ is to be produced by linking the files \verb+bar.o+
# and \verb+baz.o+ and libraries \verb+libfoo.a+.
#
# \begin{verbatim}
# section
#    LIBS = libfoo$(EXT_LIB)
#    CProgram(foo, bar baz)
# \end{verbatim}
# \end{doc}
#
CProgram(name, files) =
   #
   # Generic program
   #
   OFILES = $(addsuffix $(EXT_OBJ), $(files))
   NAME   = $(file $(name)$(EXE))

   $(NAME): $(OFILES)
        $(CC) $(CFLAGS) -o $@ $,(OFILES) $(LIBS) $(LDFLAGS)

   return $(NAME)

#
# Copy to a bin directory
#
# \begin{doc}
# \fun{CProgramCopy}
#
# The \verb+CProgramCopy+ function copies a file to an install location.
#
# \verb+CProgramCopy(<tag>, <dir>, <program>)+
#
# \begin{verbatim}
# CProgramCopy(install, /usr/bin, foo)
# \end{verbatim}
# \end{doc}
#
CProgramCopy(tag, bin, name) =
   #
   # Name of the program
   #
   NAME   = $(file $(name)$(EXE))
   BINNAME = $(file $(bin)/$(basename $(name))$(EXE))

   #
   # Linking the program into the root bin dir
   #
   $(BINNAME): $(NAME) $(bin) :scanner: $(NOSCANNER)
      $(symlink $<, $@)

   #
   # Add the dependency to the tag
   #
   $(tag): $(BINNAME)

   return $(BINNAME)

#
# We often use them together
#
# \begin{doc}
# \fun{CProgramInstall}
#
# The \verb+CProgramInstall+ function specifies a program to build,
# and a location to install, simultaneously.
#
# \verb+CProgramInstall(<tag>, <dir>, <name>, <files>)+
#
# \begin{verbatim}
# section
#    LIBS = libfoo$(EXT_LIB)
#    CProgramInstall(install, /usr/bin, foo, bar baz)
# \end{verbatim}
# \end{doc}
#
CProgramInstall(tag, bin, name, files) =
   CProgram($(name), $(files))
   return $(CProgramCopy $(tag), $(bin), $(name))

#
# The C++ versions.
#
# \begin{doc}
# \fun{CXXProgram}
# \fun{CXXProgramInstall}
#
# The \verb+CXXProgram+ and \verb+CXXProgramInstall+ functions are
# equivalent to their C counterparts, except that would use \verb+$(CXX)+ and \verb+$(CXXFLAGS)+
# for linking instead of \verb+$(CC)+ and \verb+$(CFLAGS)+.
# \end{doc}
#
CXXProgram(name, files) =
    CC = $(CXX)
    CFLAGS = $(CXXFLAGS)
    return $(CProgram $(name), $(files))

CXXProgramInstall(tag, bin, name, files) =
   CXXProgram($(name), $(files))
   return $(CProgramCopy $(tag), $(bin), $(name))

